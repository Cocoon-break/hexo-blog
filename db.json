{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/coloradoablaze.jpg","path":"img/coloradoablaze.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/apple-touch-icon.png","path":"img/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/lufei.jpg","path":"img/lufei.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/ali_pay.jpg","path":"images/ali_pay.jpg","modified":0,"renderable":0},{"_id":"source/images/ali_pay1.jpg","path":"images/ali_pay1.jpg","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/coloradoablaze.jpg","path":"images/coloradoablaze.jpg","modified":0,"renderable":0},{"_id":"source/images/wechat_pay.jpg","path":"images/wechat_pay.jpg","modified":0,"renderable":0},{"_id":"source/images/java/jna.jpg","path":"images/java/jna.jpg","modified":0,"renderable":0},{"_id":"source/images/golang/logo.jpg","path":"images/golang/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/golang/string.jpg","path":"images/golang/string.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/MySQL_Architecture.jpg","path":"images/mysql/MySQL_Architecture.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/join.jpg","path":"images/mysql/join.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/logo-mysql.png","path":"images/mysql/logo-mysql.png","modified":0,"renderable":0},{"_id":"source/images/other/banner.png","path":"images/other/banner.png","modified":0,"renderable":0},{"_id":"source/images/screenShot/iterm2_color.jpg","path":"images/screenShot/iterm2_color.jpg","modified":0,"renderable":0},{"_id":"source/images/screenShot/iterm2_keymap.jpg","path":"images/screenShot/iterm2_keymap.jpg","modified":0,"renderable":0},{"_id":"source/images/screenShot/iterm2_tmux_keymap.jpg","path":"images/screenShot/iterm2_tmux_keymap.jpg","modified":0,"renderable":0},{"_id":"source/images/shell/idcard_front.jpg","path":"images/shell/idcard_front.jpg","modified":0,"renderable":0},{"_id":"source/images/other/wm.jpg","path":"images/other/wm.jpg","modified":0,"renderable":0},{"_id":"source/images/golang/goroutine.jpg","path":"images/golang/goroutine.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"a379f052f0b5aeda0a90caf171f5336693705c0b","modified":1582697499450},{"_id":"source/_posts/Linux下打RPM包.md","hash":"e76a111bf0e960abf88f38655c99972c903c79ae","modified":1584957215960},{"_id":"source/_config.yml","hash":"135508674a6df897aa5e79be171812a46c14dd06","modified":1582696898240},{"_id":"source/_posts/Mac下打造流畅的终端使用环境.md","hash":"335381919fa98f6b15cfc62d8cd33fd7894f7d9d","modified":1582775064080},{"_id":"source/CNAME","hash":"682d2eaebba01726aaf8d32981f6388716146047","modified":1603171077058},{"_id":"source/_posts/MySQL系列一.md","hash":"4623eaa476b94773edea70c83e7305c3363a22e8","modified":1585037407270},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1587549433730},{"_id":"source/_posts/MySQL系列二.md","hash":"fa5faf6d6d511a59ed3194dc506d0205b2f7267b","modified":1585036914440},{"_id":"source/_posts/RN中使用mobx来进行状态管理.md","hash":"ccac6a3a2f9da998d6367015f6e6e58e17007f4b","modified":1582775325760},{"_id":"source/_posts/MySQL系列五.md","hash":"e43a60ea88d67d27607702f5207e3eb153ab3a85","modified":1585037426030},{"_id":"source/_posts/MySQL系列三.md","hash":"9fdf6cef6aead262762079ae018bcf0a652cc685","modified":1585037418130},{"_id":"source/_posts/caddy的简易使用.md","hash":"a70313dbbdd872e580852fbc3ef16065bfd88e88","modified":1582775510450},{"_id":"source/_posts/MySQL系列四.md","hash":"0b4721811b63086d3fdc80651eaca1de4f3aaff6","modified":1585036898540},{"_id":"source/_posts/golang之slice and map.md","hash":"a4f335db7216e2e3677d6dd2ce0d4ee9c7e9a3b5","modified":1585203133150},{"_id":"source/_posts/ffmpeg简易介绍.md","hash":"092eef3640cf9ea297186df2e8b7701c3bd24be1","modified":1584957901080},{"_id":"source/_posts/golang之cgo.md","hash":"2525b378e574555b1175896172fbc8bdf900b9b0","modified":1585199275030},{"_id":"source/_posts/python 开发服务端.md","hash":"ffe5a023d7130bcb90ad35bada3c4e720f488ce6","modified":1582775273210},{"_id":"source/_posts/iterm,tmux,vim的常用快捷键.md","hash":"4f3302833050c2281d5665bb6c04a949b01168fa","modified":1582774918960},{"_id":"source/_posts/supervisor 是基于python的进程管理工具.md","hash":"44c09a23fa7fee3be75715b4c6db06678ea4e6ef","modified":1584956943640},{"_id":"source/_posts/shell 脚本中读取参数值.md","hash":"6b5212cc9d8a00fe3fcbacd2bdddd79828d23f82","modified":1582775370350},{"_id":"source/_posts/java 之 JNA.md","hash":"c7cf936f89d45758f23025fa2cf6e031b190727b","modified":1603100252479},{"_id":"source/_posts/公众号web开发过程记录.md","hash":"d8fae31e9aa55112c4c34cc15d6e91ee35eeaeae","modified":1582775302430},{"_id":"source/_posts/加密算法简介.md","hash":"f8b32aa8b56656f60e74574a3f9a7e240507cf1e","modified":1582773726490},{"_id":"source/_posts/传统POS流程及名词解释.md","hash":"33c790d9fe5565c5ec277625da4abecaa1e10854","modified":1603104891192},{"_id":"source/_posts/私有化的坑.md","hash":"3a6ff30bfcd584a4c2bbda8b42d6e0e669e75812","modified":1582774375700},{"_id":"source/_posts/xargs和jq.md","hash":"41e87e8e695aa86b22abf785274be0871cdae58d","modified":1582775640820},{"_id":"source/_posts/脚本跑批.md","hash":"5fa1acc2c5dd99155aad61ef5f77332093692372","modified":1585038333870},{"_id":"source/_posts/各个平台上传图片.md","hash":"d3d8b25012a60adf36e0fdfd676b0b9fe6d10a0f","modified":1582772719620},{"_id":"source/_posts/内网端口映射到外网.md","hash":"1694e938ee69c2e4ea02b2780fa866ecb67ffcaa","modified":1582774267590},{"_id":"source/images/.DS_Store","hash":"514e39ff2d52c4e434f73257de566d5301982c60","modified":1604919463681},{"_id":"source/images/ali_pay1.jpg","hash":"e148168a1ecd2047cfc4477271e0b3a2bbb95db9","modified":1494831538000},{"_id":"source/images/avatar.jpg","hash":"419755f44dfcd73ed13ae43d9d74adb0b6ef4e4d","modified":1494322683000},{"_id":"source/about/index.md","hash":"2494285319044135ad6f322cdaf5fb1b72b09648","modified":1603105091019},{"_id":"source/images/golang/logo.jpg","hash":"f9d0fb3714e505f4e1c7bbb9e5f0db93042adb89","modified":1585203015580},{"_id":"source/images/java/jna.jpg","hash":"c37a876a1e15271d7e350f9bf1b6cda816b36749","modified":1603100124002},{"_id":"source/images/golang/string.jpg","hash":"72570fc66f7f503c18cb18f4f9acc5abe5de683b","modified":1584941568910},{"_id":"source/images/mysql/logo-mysql.png","hash":"4778178f2c8a10fef2787534f116dc258637d0b5","modified":1585037331780},{"_id":"source/images/ali_pay.jpg","hash":"6e555acc6f2b1c5f25a3dda2c4559248e7f69714","modified":1497863075000},{"_id":"source/images/mysql/MySQL_Architecture.jpg","hash":"f528f4983b168716f13ebff749013ec986fccd58","modified":1583207535390},{"_id":"source/images/mysql/join.jpg","hash":"85c83a6923f5feb8bdb1a4aa581fc311d499c9dd","modified":1583286332150},{"_id":"source/images/wechat_pay.jpg","hash":"cb369604dbab18468279e5a3292e93c4fd47bc9a","modified":1497862984000},{"_id":"source/images/shell/idcard_front.jpg","hash":"c75027f4ee8e541aed1508d925aaba5fb0dbf420","modified":1550718283470},{"_id":"source/images/other/banner.png","hash":"a79a3cec3dba526e6c51eddc071e7267026b2b76","modified":1601774904043},{"_id":"source/images/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1583462844000},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602940783000},{"_id":"source/images/screenShot/iterm2_color.jpg","hash":"62a8abd33d8dbebdcc9ab53f6c4975311e3c3f41","modified":1495875048000},{"_id":"themes/fluid/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1603104373704},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1602940783000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1602940783000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1602940783000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1602940783000},{"_id":"themes/fluid/_config.yml","hash":"4c7e70668b4b88df0c89034daf9bd94ab632444f","modified":1606200585288},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1602940783000},{"_id":"themes/fluid/package.json","hash":"e2772a7e62badea6d404887d8c2723f0fb7af07d","modified":1602940783000},{"_id":"themes/fluid/README_en.md","hash":"1c4c47d45746c6741167ba5e8153e235e73f7172","modified":1602940783000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1602940783000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1602940783000},{"_id":"themes/fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1602940783000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1602940783000},{"_id":"themes/fluid/README.md","hash":"046950dfee8bb3934baed67678e60a002cb20c3c","modified":1602940783000},{"_id":"themes/fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1602940783000},{"_id":"themes/fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1602940783000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1602940783000},{"_id":"themes/fluid/layout/layout.ejs","hash":"92474673da8f6016be9f4c0184b746ec21954a4d","modified":1602940783000},{"_id":"themes/fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1602940783000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1602940783000},{"_id":"themes/fluid/layout/post.ejs","hash":"8cbfe4dee760631df26d23c49edaab18b8340526","modified":1602940783000},{"_id":"themes/fluid/layout/index.ejs","hash":"58e994d28fd72d585d2e4c63d0c0fd3e61dd14b8","modified":1602940783000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1602940783000},{"_id":"themes/fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1602940783000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"bccd7961fa146dd5f0d70f77e7ab94e9f58d5bd3","modified":1602940783000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":1602940783000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1602940783000},{"_id":"themes/fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1602940783000},{"_id":"themes/fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"a44f0abeb75039804f33771c9c3bdeb78ed2cd7a","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"382bd3ee27bc6d90776fc9171a487ff208bc4caa","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"450918516e50065774e64cae293d39161f0ea137","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1602940783000},{"_id":"themes/fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1602940783000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1602940783000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1602940783000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1602940783000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":1602940783000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1602940783000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1602940783000},{"_id":"themes/fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1583214946290},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1602940783000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1602940783000},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1602940783000},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1602940783000},{"_id":"themes/fluid/source/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1581745631000},{"_id":"themes/fluid/source/img/lufei.jpg","hash":"64a7f41e948344e239872ab52a0b4d42e10e6361","modified":1582706884290},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1602940783000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1602940783000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1602940783000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1602940783000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"8a70f2016d9df68d29800b3bceb8f4c021158248","modified":1602940783000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1602940783000},{"_id":"themes/fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1602940783000},{"_id":"themes/fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1602940783000},{"_id":"themes/fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1602940783000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"2264bec80ba051a19ba80396618f3d0c22948f0b","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1602940783000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1602940783000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":1602940783000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1602940783000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"4304bab8ad087911cbf5025a41014fbb67f20b5a","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"40a198e741805fdd51117bcb0d373660ab7dfdf9","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":1602940783000},{"_id":"source/images/screenShot/iterm2_keymap.jpg","hash":"d0325aac666446894a687567edb5b4b5e14bad18","modified":1496384594000},{"_id":"themes/fluid/source/img/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1583462844000},{"_id":"source/images/screenShot/iterm2_tmux_keymap.jpg","hash":"91a1ba4c89e8dd9c8036962268333b508c9264eb","modified":1496386335000},{"_id":"public/local-search.xml","hash":"4149008f82000cab95fefbfe4cd38f58c54d859f","modified":1603174027146},{"_id":"public/about/index.html","hash":"e717f6860e1f9a6e879f0f8533377f6c682a0faf","modified":1603174027146},{"_id":"public/2020/10/19/传统POS流程及名词解释/index.html","hash":"dc9b498400dd48f3c94644e195df2f051471ac98","modified":1603174027146},{"_id":"public/2018/10/15/java 之 JNA/index.html","hash":"492be940b2777a2f9d75d9f89758cd7301aeb2a7","modified":1603174027146},{"_id":"public/2018/09/10/golang之slice and map/index.html","hash":"30d0f6ad0e9235b6aeb22604f07887c20785275b","modified":1603174027146},{"_id":"public/2018/08/30/golang之cgo/index.html","hash":"654bcf0a1d95fc89aa1d2b3930655f3260606911","modified":1603174027146},{"_id":"public/2018/08/25/MySQL系列五/index.html","hash":"721dd4d92b580ae8c1a2d1585b4368820851d8a0","modified":1603174027146},{"_id":"public/2018/08/22/MySQL系列四/index.html","hash":"d1045ff7f633a5ea7ef3b12495f1b246ab67e54a","modified":1603174027146},{"_id":"public/2018/08/18/MySQL系列三/index.html","hash":"e12d99e632f7445e206b6b9a99e274616167b2ef","modified":1603174027146},{"_id":"public/2018/08/15/MySQL系列二/index.html","hash":"4295e3bd9d53a36ed21be5bead3662e4890a846e","modified":1603174027146},{"_id":"public/2018/08/12/MySQL系列一/index.html","hash":"1d1cabdcc22514dda8cdd5862039725ac73c194d","modified":1603174027146},{"_id":"public/2018/03/21/脚本跑批/index.html","hash":"90a099b73194f6e6e815d7854a7d8b5c34645a9b","modified":1603174027146},{"_id":"public/2017/08/28/加密算法简介/index.html","hash":"45f2ab80e5b185a4fa46a335d07e1af0cd51fb72","modified":1603174027146},{"_id":"public/2017/08/21/内网端口映射到外网/index.html","hash":"948146f8e7b40e483133760504144b045845bb68","modified":1603174027146},{"_id":"public/2017/07/20/私有化的坑/index.html","hash":"31fd50245fc8c4dd8fb009897f59e1d411517ff0","modified":1603174027146},{"_id":"public/2017/07/05/xargs和jq/index.html","hash":"4b83951547f19410af5febb0be0bf034a0b9edc2","modified":1603174027146},{"_id":"public/2017/06/30/caddy的简易使用/index.html","hash":"b78976bac6ed28672232aa0be280260ea41788cd","modified":1603174027146},{"_id":"public/2017/06/19/公众号web开发过程记录/index.html","hash":"2b7b5e136a83e392dacb5ea6f95072de6f25c752","modified":1603174027146},{"_id":"public/2017/06/19/python 开发服务端/index.html","hash":"4515d5294736f7a730a44713b874b91aa61e3a21","modified":1603174027146},{"_id":"public/2017/06/13/RN中使用mobx来进行状态管理/index.html","hash":"633e3a35c613c611699d0d2d1e34eecaea9c091d","modified":1603174027146},{"_id":"public/2017/06/13/各个平台上传图片/index.html","hash":"a17630056832ffbf46e421599a417eb2e2788786","modified":1603174027146},{"_id":"public/2017/06/02/iterm,tmux,vim的常用快捷键/index.html","hash":"b200126a99116ac710056809deb5a122f3263bb9","modified":1603174027146},{"_id":"public/2017/05/27/Mac下打造流畅的终端使用环境/index.html","hash":"79cea761cf86502b8435b87f237cfe25fe074d4d","modified":1603174027146},{"_id":"public/2017/05/25/shell 脚本中读取参数值/index.html","hash":"39bf0e6b608d64ddae564169d7c1b4b737d09ddf","modified":1603174027146},{"_id":"public/2017/05/22/ffmpeg简易介绍/index.html","hash":"24fc628c77282f60638bc2ff6ea608bcdcf7090c","modified":1603174027146},{"_id":"public/2017/05/15/Linux下打RPM包/index.html","hash":"3db95e89b7632afeff9ab7f751d9b96c4c9a7c46","modified":1603174027146},{"_id":"public/2017/04/28/supervisor 是基于python的进程管理工具/index.html","hash":"f79aabea978b3998e32de7aa4f79b445fb5cf277","modified":1603174027146},{"_id":"public/index.html","hash":"dfcaf81b645fa531aa7b32eaa1e7e48ba89157a0","modified":1603174027146},{"_id":"public/page/2/index.html","hash":"854fff9c6b0635ec84adcf1ae3ce0284786b1fc8","modified":1603174027146},{"_id":"public/page/3/index.html","hash":"0f419586dedf9c4f06862779481dcc52110919ae","modified":1603174027146},{"_id":"public/page/4/index.html","hash":"d45d550a040548a4d1b4035082b971c28d0d89cd","modified":1603174027146},{"_id":"public/page/5/index.html","hash":"12f9cb4734495fdb3ea67d7f6d3b4ea8f64908fc","modified":1603174027146},{"_id":"public/categories/开发效率/index.html","hash":"848de0b716c8a98140bb433611e9711996666236","modified":1603174027146},{"_id":"public/categories/Linux/index.html","hash":"255c025c1200545f7ed1a964845a22d0446ea83d","modified":1603174027146},{"_id":"public/categories/DB/index.html","hash":"1dc4b150c0a1bb16991dd6f0d00027fa58013779","modified":1603174027146},{"_id":"public/categories/前端/index.html","hash":"ba44354a9edea9bc385604a358ee4933ac7129bb","modified":1603174027146},{"_id":"public/categories/开源工具/index.html","hash":"1b0b440019ee4d50a82923f82190d3b41dde1550","modified":1603174027146},{"_id":"public/categories/golang/index.html","hash":"b634454c4f31da7c33b8a66f026202d4ee9fbbca","modified":1603174027146},{"_id":"public/categories/Java/index.html","hash":"9fd8148691fbaac5b60c186b6dce7e995ec16a86","modified":1603174027146},{"_id":"public/categories/Python/index.html","hash":"fac28a90613764bb1784dafd9dc4edb4e0823cb6","modified":1603174027146},{"_id":"public/categories/随笔/index.html","hash":"8bdd03d60c8e0b8b253df1d39dd4db75acf58322","modified":1603174027146},{"_id":"public/categories/算法/index.html","hash":"2181cd2b27c44a0fa5c0b90607a4e05d3516fd4a","modified":1603174027146},{"_id":"public/archives/index.html","hash":"5c0e315a69a25028c4c002607879ab61a7f19f42","modified":1603174027146},{"_id":"public/archives/page/2/index.html","hash":"3daaafde7fff661f9fe6084a1287fe15503ec52e","modified":1603174027146},{"_id":"public/archives/page/3/index.html","hash":"91843502c9212124078174597d1559903120744d","modified":1603174027146},{"_id":"public/archives/page/4/index.html","hash":"f96f03938fdc819c4f05414d0621bef3936d1575","modified":1603174027146},{"_id":"public/archives/page/5/index.html","hash":"2a3af16eeba0128c60a4f14d2fd849b8ed657272","modified":1603174027146},{"_id":"public/archives/2017/index.html","hash":"eef6ee092b464042d38bb1dd032e85de3f4fddec","modified":1603174027146},{"_id":"public/archives/2017/page/2/index.html","hash":"7615b238dcdafba37049765ee98d56e08d8674c7","modified":1603174027146},{"_id":"public/archives/2017/page/3/index.html","hash":"1813edc56e90fb46acccb4f8194c618c9ed30123","modified":1603174027146},{"_id":"public/archives/2017/04/index.html","hash":"5c77e826ffa70d5f747cfcc7a11454bf43056370","modified":1603174027146},{"_id":"public/archives/2017/05/index.html","hash":"7ce35a18983c2387e92f57f8fcd0eeb216be0e8a","modified":1603174027146},{"_id":"public/archives/2017/06/index.html","hash":"a497c74fa29c7f93faba0b27970776fb9b4fc544","modified":1603174027146},{"_id":"public/archives/2017/07/index.html","hash":"6b0aab865297be5e5ec464a0e6d53df75be5c704","modified":1603174027146},{"_id":"public/archives/2017/08/index.html","hash":"f7b168ad8adb22f6d48cdf4a67ea23a6ba653682","modified":1603174027146},{"_id":"public/archives/2018/index.html","hash":"d9bf5f97ca0ba1729574838ffdc3caa83c70869c","modified":1603174027146},{"_id":"public/archives/2018/page/2/index.html","hash":"b622d03e44ba0fbd9f593449e8feb298107946d2","modified":1603174027146},{"_id":"public/archives/2018/03/index.html","hash":"ae1c3403c5c5d4aa843c9ccea324af9d62509d60","modified":1603174027146},{"_id":"public/archives/2018/08/index.html","hash":"f02174e8725ea7e65b11031fbbbd489f525c2b28","modified":1603174027146},{"_id":"public/archives/2018/09/index.html","hash":"e932ea2f40cf29051889323e31da309d4cac85ae","modified":1603174027146},{"_id":"public/archives/2018/10/index.html","hash":"55fb7d8fd7d5144fac5c01312707590732c0b4b7","modified":1603174027146},{"_id":"public/archives/2020/index.html","hash":"62ce120f74df560abb87d2399ff90e0cf90db94c","modified":1603174027146},{"_id":"public/archives/2020/10/index.html","hash":"6ba9523c96c5b5c9a604243681c2b2bfba028b47","modified":1603174027146},{"_id":"public/tags/开发效率/index.html","hash":"65dcb5d4b0fd566635613029be751b1ede1ffbbc","modified":1603174027146},{"_id":"public/tags/Linux/index.html","hash":"a59922b4dd315086478eb8b823f328c505ff1fb5","modified":1603174027146},{"_id":"public/tags/mysql/index.html","hash":"28c94fbbe1e899cf5abdbf2f393597aae274d89c","modified":1603174027146},{"_id":"public/tags/react-native/index.html","hash":"b0cecc547b8faa84a679dc9048f8cbf14dcfa28d","modified":1603174027146},{"_id":"public/tags/扩展/index.html","hash":"cad070b8d8e5f1ffc6e5049a62b3a04347555095","modified":1603174027146},{"_id":"public/tags/golang/index.html","hash":"60e1844bc5963f2e179da4415039ad959e642d7b","modified":1603174027146},{"_id":"public/tags/golang-cgo/index.html","hash":"9ecfc357300b144bc847db4ca169cb224c1fc675","modified":1603174027146},{"_id":"public/tags/jna/index.html","hash":"f2fcd5286b314bf05d18477901a0e16d73fdfdc8","modified":1603174027146},{"_id":"public/tags/Python/index.html","hash":"79c7ca80392a9d302f3a456b78a7ca7de29e6c60","modified":1603174027146},{"_id":"public/tags/shell/index.html","hash":"ad046456921287a7379107f01d090693e04d50b8","modified":1603174027146},{"_id":"public/tags/随笔/index.html","hash":"e36b834ebd786ef98aa7ad9cb1a48e482a740c05","modified":1603174027146},{"_id":"public/tags/react-web/index.html","hash":"bdd8969db8c1883f25c5a721e09f935ec674ea52","modified":1603174027146},{"_id":"public/404.html","hash":"9ea735bd3263b3bd7287730a354404d68aa6a5c7","modified":1603174027146},{"_id":"public/tags/index.html","hash":"60d7bbef09fe975c3b5edd11285693079c31192c","modified":1603174027146},{"_id":"public/categories/index.html","hash":"1f25eda7cf1c351687332deaa5c40bad21f2140e","modified":1603174027146},{"_id":"public/links/index.html","hash":"4ff199500d1c545de2cc584d43600f73b3927d5b","modified":1603174027146},{"_id":"public/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1603174027146},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1603174027146},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1603174027146},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1603174027146},{"_id":"public/img/lufei.jpg","hash":"64a7f41e948344e239872ab52a0b4d42e10e6361","modified":1603174027146},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1603174027146},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1603174027146},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1603174027146},{"_id":"public/CNAME","hash":"682d2eaebba01726aaf8d32981f6388716146047","modified":1603174027146},{"_id":"public/images/avatar.jpg","hash":"419755f44dfcd73ed13ae43d9d74adb0b6ef4e4d","modified":1603174027146},{"_id":"public/images/ali_pay1.jpg","hash":"e148168a1ecd2047cfc4477271e0b3a2bbb95db9","modified":1603174027146},{"_id":"public/images/java/jna.jpg","hash":"c37a876a1e15271d7e350f9bf1b6cda816b36749","modified":1603174027146},{"_id":"public/images/golang/logo.jpg","hash":"f9d0fb3714e505f4e1c7bbb9e5f0db93042adb89","modified":1603174027146},{"_id":"public/images/golang/string.jpg","hash":"72570fc66f7f503c18cb18f4f9acc5abe5de683b","modified":1603174027146},{"_id":"public/images/mysql/logo-mysql.png","hash":"4778178f2c8a10fef2787534f116dc258637d0b5","modified":1603174027146},{"_id":"public/images/ali_pay.jpg","hash":"6e555acc6f2b1c5f25a3dda2c4559248e7f69714","modified":1603174027146},{"_id":"public/images/wechat_pay.jpg","hash":"cb369604dbab18468279e5a3292e93c4fd47bc9a","modified":1603174027146},{"_id":"public/images/mysql/MySQL_Architecture.jpg","hash":"f528f4983b168716f13ebff749013ec986fccd58","modified":1603174027146},{"_id":"public/images/mysql/join.jpg","hash":"85c83a6923f5feb8bdb1a4aa581fc311d499c9dd","modified":1603174027146},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1603174027146},{"_id":"public/images/shell/idcard_front.jpg","hash":"c75027f4ee8e541aed1508d925aaba5fb0dbf420","modified":1603174027146},{"_id":"public/js/color-schema.js","hash":"8a70f2016d9df68d29800b3bceb8f4c021158248","modified":1603174027146},{"_id":"public/css/main.css","hash":"4c092bcb04cb3793cac7f62efc49bed5b4fa4d76","modified":1603174027146},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1603174027146},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1603174027146},{"_id":"public/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1603174027146},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1603174027146},{"_id":"public/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1603174027146},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1603174027146},{"_id":"public/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1603174027146},{"_id":"public/images/other/banner.png","hash":"a79a3cec3dba526e6c51eddc071e7267026b2b76","modified":1603174027146},{"_id":"public/img/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1603174027146},{"_id":"public/images/screenShot/iterm2_color.jpg","hash":"62a8abd33d8dbebdcc9ab53f6c4975311e3c3f41","modified":1603174027146},{"_id":"public/images/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1603174027146},{"_id":"public/images/screenShot/iterm2_keymap.jpg","hash":"d0325aac666446894a687567edb5b4b5e14bad18","modified":1603174027146},{"_id":"public/images/screenShot/iterm2_tmux_keymap.jpg","hash":"91a1ba4c89e8dd9c8036962268333b508c9264eb","modified":1603174027146},{"_id":"source/_posts/并发模型及线程模型概述.md","hash":"a2771d8d90d5dc16a131bf711c56e153f8800f03","modified":1604919810309},{"_id":"source/images/other/wm.jpg","hash":"45837871e640802ce05b3098c677be563f06103d","modified":1604919432739},{"_id":"source/_posts/Goroutine & Scheduler.md","hash":"fdebc64e1041c119a1408af99791e0ae7fa668f0","modified":1606200536163},{"_id":"source/images/golang/goroutine.jpg","hash":"18757e32eccd45c21aec0559c0b71571bc47275f","modified":1606200502313}],"Category":[{"name":"开发效率","_id":"ckghk0s030003mdym14sl9w28"},{"name":"Linux","_id":"ckghk0s070008mdym6mf3deg5"},{"name":"DB","_id":"ckghk0s09000emdymhuux6l3b"},{"name":"前端","_id":"ckghk0s0j0016mdym747o6af5"},{"name":"开源工具","_id":"ckghk0s0l001dmdym1loe8dap"},{"name":"golang","_id":"ckghk0s0q001rmdymgvivhnax"},{"name":"Java","_id":"ckghk0s0t0026mdymbvpd97i8"},{"name":"Python","_id":"ckghk0s0u002cmdymbzy187kp"},{"name":"随笔","_id":"ckghk0s0w002lmdym6qxtdmaq"},{"name":"算法","_id":"ckghk0s0x002qmdymdrm24oar"}],"Data":[],"Page":[{"title":"关于我","date":"2020-10-19T10:34:00.000Z","banner_img":"/images/coloradoablaze.jpg","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-10-19 18:34:00\nbanner_img: /images/coloradoablaze.jpg\n---\n","updated":"2020-10-19T10:58:11.019Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckghk0rzu0000mdyme1449etz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Mac下打造流畅的终端使用环境","date":"2017-05-27T09:02:12.000Z","_content":"\n作为程序员Mac上自带的终端是远远满足不了我们的，这时我们就要自己手动搭一个我们顺手的终端环境。下面我们就来搭建iterm2+ oh my zsh + tmux  的终端工具\n\n## ITerm2 安装\n\n1. 上Iterm2的官网下载iterm2,[iterm2下载](http://www.iterm2.com/)\n\n2. 下载完成之后，发现iterm2 自带的配色我不太喜欢，安装完成之后进行item2的配色，这个纯属看个人喜好了。\n\n   - 要进行配色，我们当然得要有配色的方案啦！什么你要自己配一个，嗯...... 这也是可以的，不过有很多现成的方案你要不要啊。github 上有超多的配色方案，我们先把这个库给clone下来。\n\n     ```sh\n     git clone git@github.com:mbadolato/iTerm2-Color-Schemes.git\n     ```\n\n     要是你没有git，那我觉得你没太必要继续下去了。当然你还想继续的话，你就上GitHub手动download 下来。\n\n     <!-- more -->\n\n   - 好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案，这就看个人喜好了哈，这样你的iterm2配色方案就完成了\n\n     ![](https://cocoon-break.github.io/images/screenShot/iterm2_color.jpg)\n\n\n\n\n\n\n## Mac下shell介绍\n\nShell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。\n\n\n\nLinux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。\n\n```sh\ncat /etc/shells\n```\n\n\n\n在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh，这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」\n\n\n\n### 安装使用on-my-zsh\n\n1. 通过git 把oh-my-zsh 下载下来\n\n   ```sh\n   git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\n   ```\n\n2. 添加配置文件并设置为默认的shell\n\n   ```sh\n   cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n   chsh -s /bin/zsh\n   ```\n\n   **注:** .zshrc 就相当于.bashrc了以后配置环境就在.zshrc中配置就行\n\n3. 配置oh-my-zsh 的主题\n\n   oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考[主题预览](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)，选好主题了，接下来就是配置了。编辑~/.zshrc 文件\n\n   ```sh\n   vim ~/.zshrc\n   #编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的\n   ZSH_THEME=\"af-magic\"\n   ```\n\n4. oh-my-zsh 就配置完了。这里只是简单的介绍oh-my-zsh。oh-my-zsh  功能还是很丰富的，更多oh-my-zsh请移步[oh-my-zsh GitHub地址](https://github.com/robbyrussell/oh-my-zsh)\n\n## 安装tmux\n\nTmux 是一个工具，用于在一个终端窗口中运行多个终端会话。不仅如此，你还可以通过 Tmux 使终端会话运行于后台或是按需接入、断开会话，这个功能非常实用。\n\n1. 先安装Homebrew，这个是Mac平台的包管理器。用来安装一些开发工具还是很方便。Mac系统自带了ruby的环境，我们通过ruby来安装Homebrew\n\n   ```sh\n   /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n   ```\n\n2. 通过homebrew 安装tmux\n\n   ```sh\n   brew install tmux\n   ```\n\n3. 就是这么简单tmux就装完了\n\n\n\n下一篇会讲具体的使用方法，包括iterm快捷键，tmux的使用","source":"_posts/Mac下打造流畅的终端使用环境.md","raw":"---\ntitle: Mac下打造流畅的终端使用环境\ndate: 2017-05-27 17:02:12\ntags: \n- 开发效率\ncategories:\n- 开发效率\n---\n\n作为程序员Mac上自带的终端是远远满足不了我们的，这时我们就要自己手动搭一个我们顺手的终端环境。下面我们就来搭建iterm2+ oh my zsh + tmux  的终端工具\n\n## ITerm2 安装\n\n1. 上Iterm2的官网下载iterm2,[iterm2下载](http://www.iterm2.com/)\n\n2. 下载完成之后，发现iterm2 自带的配色我不太喜欢，安装完成之后进行item2的配色，这个纯属看个人喜好了。\n\n   - 要进行配色，我们当然得要有配色的方案啦！什么你要自己配一个，嗯...... 这也是可以的，不过有很多现成的方案你要不要啊。github 上有超多的配色方案，我们先把这个库给clone下来。\n\n     ```sh\n     git clone git@github.com:mbadolato/iTerm2-Color-Schemes.git\n     ```\n\n     要是你没有git，那我觉得你没太必要继续下去了。当然你还想继续的话，你就上GitHub手动download 下来。\n\n     <!-- more -->\n\n   - 好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案，这就看个人喜好了哈，这样你的iterm2配色方案就完成了\n\n     ![](https://cocoon-break.github.io/images/screenShot/iterm2_color.jpg)\n\n\n\n\n\n\n## Mac下shell介绍\n\nShell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。\n\n\n\nLinux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。\n\n```sh\ncat /etc/shells\n```\n\n\n\n在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh，这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」\n\n\n\n### 安装使用on-my-zsh\n\n1. 通过git 把oh-my-zsh 下载下来\n\n   ```sh\n   git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\n   ```\n\n2. 添加配置文件并设置为默认的shell\n\n   ```sh\n   cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n   chsh -s /bin/zsh\n   ```\n\n   **注:** .zshrc 就相当于.bashrc了以后配置环境就在.zshrc中配置就行\n\n3. 配置oh-my-zsh 的主题\n\n   oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考[主题预览](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)，选好主题了，接下来就是配置了。编辑~/.zshrc 文件\n\n   ```sh\n   vim ~/.zshrc\n   #编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的\n   ZSH_THEME=\"af-magic\"\n   ```\n\n4. oh-my-zsh 就配置完了。这里只是简单的介绍oh-my-zsh。oh-my-zsh  功能还是很丰富的，更多oh-my-zsh请移步[oh-my-zsh GitHub地址](https://github.com/robbyrussell/oh-my-zsh)\n\n## 安装tmux\n\nTmux 是一个工具，用于在一个终端窗口中运行多个终端会话。不仅如此，你还可以通过 Tmux 使终端会话运行于后台或是按需接入、断开会话，这个功能非常实用。\n\n1. 先安装Homebrew，这个是Mac平台的包管理器。用来安装一些开发工具还是很方便。Mac系统自带了ruby的环境，我们通过ruby来安装Homebrew\n\n   ```sh\n   /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n   ```\n\n2. 通过homebrew 安装tmux\n\n   ```sh\n   brew install tmux\n   ```\n\n3. 就是这么简单tmux就装完了\n\n\n\n下一篇会讲具体的使用方法，包括iterm快捷键，tmux的使用","slug":"Mac下打造流畅的终端使用环境","published":1,"updated":"2020-02-27T03:44:24.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0rzy0001mdym47ba5zwb","content":"<p>作为程序员Mac上自带的终端是远远满足不了我们的，这时我们就要自己手动搭一个我们顺手的终端环境。下面我们就来搭建iterm2+ oh my zsh + tmux  的终端工具</p>\n<h2 id=\"ITerm2-安装\"><a href=\"#ITerm2-安装\" class=\"headerlink\" title=\"ITerm2 安装\"></a>ITerm2 安装</h2><ol>\n<li><p>上Iterm2的官网下载iterm2,<a href=\"http://www.iterm2.com/\">iterm2下载</a></p>\n</li>\n<li><p>下载完成之后，发现iterm2 自带的配色我不太喜欢，安装完成之后进行item2的配色，这个纯属看个人喜好了。</p>\n<ul>\n<li><p>要进行配色，我们当然得要有配色的方案啦！什么你要自己配一个，嗯…… 这也是可以的，不过有很多现成的方案你要不要啊。github 上有超多的配色方案，我们先把这个库给clone下来。</p>\n<pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> git@github.com:mbadolato/iTerm2-Color-Schemes.git</code></pre>\n\n<p>要是你没有git，那我觉得你没太必要继续下去了。当然你还想继续的话，你就上GitHub手动download 下来。</p>\n<a id=\"more\"></a>\n</li>\n<li><p>好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案，这就看个人喜好了哈，这样你的iterm2配色方案就完成了</p>\n<p><img src=\"https://cocoon-break.github.io/images/screenShot/iterm2_color.jpg\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Mac下shell介绍\"><a href=\"#Mac下shell介绍\" class=\"headerlink\" title=\"Mac下shell介绍\"></a>Mac下shell介绍</h2><p>Shell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。</p>\n<p>Linux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。</p>\n<pre><code class=\"hljs sh\">cat /etc/shells</code></pre>\n\n\n\n<p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh，这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」</p>\n<h3 id=\"安装使用on-my-zsh\"><a href=\"#安装使用on-my-zsh\" class=\"headerlink\" title=\"安装使用on-my-zsh\"></a>安装使用on-my-zsh</h3><ol>\n<li><p>通过git 把oh-my-zsh 下载下来</p>\n<pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre>\n</li>\n<li><p>添加配置文件并设置为默认的shell</p>\n<pre><code class=\"hljs sh\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh</code></pre>\n\n<p><strong>注:</strong> .zshrc 就相当于.bashrc了以后配置环境就在.zshrc中配置就行</p>\n</li>\n<li><p>配置oh-my-zsh 的主题</p>\n<p>oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\">主题预览</a>，选好主题了，接下来就是配置了。编辑~/.zshrc 文件</p>\n<pre><code class=\"hljs sh\">vim ~/.zshrc\n<span class=\"hljs-comment\">#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的</span>\nZSH_THEME=<span class=\"hljs-string\">&quot;af-magic&quot;</span></code></pre>\n</li>\n<li><p>oh-my-zsh 就配置完了。这里只是简单的介绍oh-my-zsh。oh-my-zsh  功能还是很丰富的，更多oh-my-zsh请移步<a href=\"https://github.com/robbyrussell/oh-my-zsh\">oh-my-zsh GitHub地址</a></p>\n</li>\n</ol>\n<h2 id=\"安装tmux\"><a href=\"#安装tmux\" class=\"headerlink\" title=\"安装tmux\"></a>安装tmux</h2><p>Tmux 是一个工具，用于在一个终端窗口中运行多个终端会话。不仅如此，你还可以通过 Tmux 使终端会话运行于后台或是按需接入、断开会话，这个功能非常实用。</p>\n<ol>\n<li><p>先安装Homebrew，这个是Mac平台的包管理器。用来安装一些开发工具还是很方便。Mac系统自带了ruby的环境，我们通过ruby来安装Homebrew</p>\n<pre><code class=\"hljs sh\">/usr/bin/ruby -e <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></code></pre>\n</li>\n<li><p>通过homebrew 安装tmux</p>\n<pre><code class=\"hljs sh\">brew install tmux</code></pre>\n</li>\n<li><p>就是这么简单tmux就装完了</p>\n</li>\n</ol>\n<p>下一篇会讲具体的使用方法，包括iterm快捷键，tmux的使用</p>\n","site":{"data":{}},"excerpt":"<p>作为程序员Mac上自带的终端是远远满足不了我们的，这时我们就要自己手动搭一个我们顺手的终端环境。下面我们就来搭建iterm2+ oh my zsh + tmux  的终端工具</p>\n<h2 id=\"ITerm2-安装\"><a href=\"#ITerm2-安装\" class=\"headerlink\" title=\"ITerm2 安装\"></a>ITerm2 安装</h2><ol>\n<li><p>上Iterm2的官网下载iterm2,<a href=\"http://www.iterm2.com/\">iterm2下载</a></p>\n</li>\n<li><p>下载完成之后，发现iterm2 自带的配色我不太喜欢，安装完成之后进行item2的配色，这个纯属看个人喜好了。</p>\n<ul>\n<li><p>要进行配色，我们当然得要有配色的方案啦！什么你要自己配一个，嗯…… 这也是可以的，不过有很多现成的方案你要不要啊。github 上有超多的配色方案，我们先把这个库给clone下来。</p>\n<pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> git@github.com:mbadolato/iTerm2-Color-Schemes.git</code></pre>\n\n<p>要是你没有git，那我觉得你没太必要继续下去了。当然你还想继续的话，你就上GitHub手动download 下来。</p>","more":"</li>\n<li><p>好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案，这就看个人喜好了哈，这样你的iterm2配色方案就完成了</p>\n<p><img src=\"https://cocoon-break.github.io/images/screenShot/iterm2_color.jpg\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Mac下shell介绍\"><a href=\"#Mac下shell介绍\" class=\"headerlink\" title=\"Mac下shell介绍\"></a>Mac下shell介绍</h2><p>Shell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。</p>\n<p>Linux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。</p>\n<pre><code class=\"hljs sh\">cat /etc/shells</code></pre>\n\n\n\n<p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh，这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」</p>\n<h3 id=\"安装使用on-my-zsh\"><a href=\"#安装使用on-my-zsh\" class=\"headerlink\" title=\"安装使用on-my-zsh\"></a>安装使用on-my-zsh</h3><ol>\n<li><p>通过git 把oh-my-zsh 下载下来</p>\n<pre><code class=\"hljs sh\">git <span class=\"hljs-built_in\">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></pre>\n</li>\n<li><p>添加配置文件并设置为默认的shell</p>\n<pre><code class=\"hljs sh\">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh</code></pre>\n\n<p><strong>注:</strong> .zshrc 就相当于.bashrc了以后配置环境就在.zshrc中配置就行</p>\n</li>\n<li><p>配置oh-my-zsh 的主题</p>\n<p>oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\">主题预览</a>，选好主题了，接下来就是配置了。编辑~/.zshrc 文件</p>\n<pre><code class=\"hljs sh\">vim ~/.zshrc\n<span class=\"hljs-comment\">#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的</span>\nZSH_THEME=<span class=\"hljs-string\">&quot;af-magic&quot;</span></code></pre>\n</li>\n<li><p>oh-my-zsh 就配置完了。这里只是简单的介绍oh-my-zsh。oh-my-zsh  功能还是很丰富的，更多oh-my-zsh请移步<a href=\"https://github.com/robbyrussell/oh-my-zsh\">oh-my-zsh GitHub地址</a></p>\n</li>\n</ol>\n<h2 id=\"安装tmux\"><a href=\"#安装tmux\" class=\"headerlink\" title=\"安装tmux\"></a>安装tmux</h2><p>Tmux 是一个工具，用于在一个终端窗口中运行多个终端会话。不仅如此，你还可以通过 Tmux 使终端会话运行于后台或是按需接入、断开会话，这个功能非常实用。</p>\n<ol>\n<li><p>先安装Homebrew，这个是Mac平台的包管理器。用来安装一些开发工具还是很方便。Mac系统自带了ruby的环境，我们通过ruby来安装Homebrew</p>\n<pre><code class=\"hljs sh\">/usr/bin/ruby -e <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></code></pre>\n</li>\n<li><p>通过homebrew 安装tmux</p>\n<pre><code class=\"hljs sh\">brew install tmux</code></pre>\n</li>\n<li><p>就是这么简单tmux就装完了</p>\n</li>\n</ol>\n<p>下一篇会讲具体的使用方法，包括iterm快捷键，tmux的使用</p>"},{"title":"Linux下打RPM包","date":"2017-05-15T06:34:12.000Z","_content":"\ncentos 6.5下打rpm包，由于不想给客户更多的安装信息，所以将服务打成rpm包，方便客户安装。不是计划给系统使用建议还是不要将服务打成RPM包。以下的打包也是简易的打包流程，仅记录使用。\n\n## 工具准备\n\n1. 安装rpmtools工具\n\n   ```sh\n   yum install rpmdevtools\n   ```\n\n2. 创建文件夹\n\n   ```sh\n   mkdir -pv ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}\n   ```\n\n## 配置文件及源码准备\n\n1. spec脚本文件创建，在SPECS文件夹下创建一个.spec文件 如h5-megvii.spec\n\n   ```sh\n   Name:           h5-megvii\n   License:        copyright\n   Version:        1.0\n   Release:        1%{?dist}\n   Summary:        HTML FaceID Server\n   AutoReqProv:    no\n\n   Group:          Megvii\n   URL:            http://www.megvii.com\n   Source:         %{name}-%{version}.tar.gz\n   BuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root\n\n   %description\n   The rpm version of html-megvii package\n\n   %prep\n   %setup -q\n\n   %build\n   %install\n   rm -rf $RPM_BUILD_ROOT\n   mkdir -p $RPM_BUILD_ROOT\n   cp -a * $RPM_BUILD_ROOT\n\n   %clean\n   rm -rf $RPM_BUILD_ROOT\n\n   %files\n   %defattr(-,root,root,-)\n   /opt/megvii\n   ```\n\n   <!-- more -->\n\n   spec脚本中各个配置项说明\n\n   ```sh\n   Name: 软件包的名称，后面可使用%{name}的方式引用\n   License: 软件授权方式\n   Version: 软件的实际版本号,后面可使用%{version}引用\n   Release: 发布序列号,标明第几次打包，后面可使用%{release}引用\n   Summary: 软件包的内容概要\n   AutoReqProv: 此域用于指示RPM是否自动查找软件所需的共享库与其提供的共享库\n\n   Group: 软件分组\n   URL: 软件的主页\n   Source: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%{source1}、%{source2}引用\n   BuildRoot: 这个是安装或编译时使用的“虚拟目录”,一般定义为:%{_tmppath}/%{name}-%{version}-%{release}-root\n\n   %description 软件的详细说明\n\n   %prep 预处理脚本\n   %setup 把源码包解压并放好,将SOURCES下的tar.gz 文件解压至BUILD文件夹下\n\n   %build 开始构建包\n   %install 开始把软件安装到虚拟的根目录中\n\n   %clean 清理临时文件\n\n   %files 定义那些文件或目录会放入rpm中,files下的文件，必须是tar包解压开存在的文件\n   %defattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755\n   ```\n\n   **注1:**\tSOURCES下的tar.gz包的文件名必须和SPECS下 xxx.specs  文件中的Source 保持一致。\n\n   **注2:**\tSOURCES下的tar.gz包**解压开的文件夹**名称也应为SPECS下 xxx.specs  文件中的Source 对应的名称(无须tar.gz)。\n\n   **注3:**\t%files标签下的文件路径必须存在，如/opt/megvii ,在tar.gz 解压开的文件路径是存在的\n\n2. 添加源码文件\n\n   ```sh\n   tar czvf h5-megvii-1.0.tar.gz h5-megvii-1.0\n   cp h5-megvii-1.0.tar.gz rpmbuild/SOURCES/\n   ```\n\n## 执行打包命令\n\n```sh\nrpmbuild --nodeps -ba rpmbuild/SPECS/h5-megvii.spec\n```\n\n打完包之后的rpm包文件位置在`rpmbuild/RPMS`文件夹中","source":"_posts/Linux下打RPM包.md","raw":"---\ntitle: Linux下打RPM包\ndate: 2017-05-15 14:34:12\ntags: \n- Linux\ncategories:\n- Linux\n---\n\ncentos 6.5下打rpm包，由于不想给客户更多的安装信息，所以将服务打成rpm包，方便客户安装。不是计划给系统使用建议还是不要将服务打成RPM包。以下的打包也是简易的打包流程，仅记录使用。\n\n## 工具准备\n\n1. 安装rpmtools工具\n\n   ```sh\n   yum install rpmdevtools\n   ```\n\n2. 创建文件夹\n\n   ```sh\n   mkdir -pv ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}\n   ```\n\n## 配置文件及源码准备\n\n1. spec脚本文件创建，在SPECS文件夹下创建一个.spec文件 如h5-megvii.spec\n\n   ```sh\n   Name:           h5-megvii\n   License:        copyright\n   Version:        1.0\n   Release:        1%{?dist}\n   Summary:        HTML FaceID Server\n   AutoReqProv:    no\n\n   Group:          Megvii\n   URL:            http://www.megvii.com\n   Source:         %{name}-%{version}.tar.gz\n   BuildRoot:      %{_tmppath}/%{name}-%{version}-%{release}-root\n\n   %description\n   The rpm version of html-megvii package\n\n   %prep\n   %setup -q\n\n   %build\n   %install\n   rm -rf $RPM_BUILD_ROOT\n   mkdir -p $RPM_BUILD_ROOT\n   cp -a * $RPM_BUILD_ROOT\n\n   %clean\n   rm -rf $RPM_BUILD_ROOT\n\n   %files\n   %defattr(-,root,root,-)\n   /opt/megvii\n   ```\n\n   <!-- more -->\n\n   spec脚本中各个配置项说明\n\n   ```sh\n   Name: 软件包的名称，后面可使用%{name}的方式引用\n   License: 软件授权方式\n   Version: 软件的实际版本号,后面可使用%{version}引用\n   Release: 发布序列号,标明第几次打包，后面可使用%{release}引用\n   Summary: 软件包的内容概要\n   AutoReqProv: 此域用于指示RPM是否自动查找软件所需的共享库与其提供的共享库\n\n   Group: 软件分组\n   URL: 软件的主页\n   Source: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%{source1}、%{source2}引用\n   BuildRoot: 这个是安装或编译时使用的“虚拟目录”,一般定义为:%{_tmppath}/%{name}-%{version}-%{release}-root\n\n   %description 软件的详细说明\n\n   %prep 预处理脚本\n   %setup 把源码包解压并放好,将SOURCES下的tar.gz 文件解压至BUILD文件夹下\n\n   %build 开始构建包\n   %install 开始把软件安装到虚拟的根目录中\n\n   %clean 清理临时文件\n\n   %files 定义那些文件或目录会放入rpm中,files下的文件，必须是tar包解压开存在的文件\n   %defattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755\n   ```\n\n   **注1:**\tSOURCES下的tar.gz包的文件名必须和SPECS下 xxx.specs  文件中的Source 保持一致。\n\n   **注2:**\tSOURCES下的tar.gz包**解压开的文件夹**名称也应为SPECS下 xxx.specs  文件中的Source 对应的名称(无须tar.gz)。\n\n   **注3:**\t%files标签下的文件路径必须存在，如/opt/megvii ,在tar.gz 解压开的文件路径是存在的\n\n2. 添加源码文件\n\n   ```sh\n   tar czvf h5-megvii-1.0.tar.gz h5-megvii-1.0\n   cp h5-megvii-1.0.tar.gz rpmbuild/SOURCES/\n   ```\n\n## 执行打包命令\n\n```sh\nrpmbuild --nodeps -ba rpmbuild/SPECS/h5-megvii.spec\n```\n\n打完包之后的rpm包文件位置在`rpmbuild/RPMS`文件夹中","slug":"Linux下打RPM包","published":1,"updated":"2020-03-23T09:53:35.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s010002mdym1raf6iwp","content":"<p>centos 6.5下打rpm包，由于不想给客户更多的安装信息，所以将服务打成rpm包，方便客户安装。不是计划给系统使用建议还是不要将服务打成RPM包。以下的打包也是简易的打包流程，仅记录使用。</p>\n<h2 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h2><ol>\n<li><p>安装rpmtools工具</p>\n<pre><code class=\"hljs sh\">yum install rpmdevtools</code></pre>\n</li>\n<li><p>创建文件夹</p>\n<pre><code class=\"hljs sh\">mkdir -pv ~/rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;</code></pre>\n\n</li>\n</ol>\n<h2 id=\"配置文件及源码准备\"><a href=\"#配置文件及源码准备\" class=\"headerlink\" title=\"配置文件及源码准备\"></a>配置文件及源码准备</h2><ol>\n<li><p>spec脚本文件创建，在SPECS文件夹下创建一个.spec文件 如h5-megvii.spec</p>\n<pre><code class=\"hljs sh\">Name:           h5-megvii\nLicense:        copyright\nVersion:        1.0\nRelease:        1%&#123;?dist&#125;\nSummary:        HTML FaceID Server\nAutoReqProv:    no\n\nGroup:          Megvii\nURL:            http://www.megvii.com\nSource:         %&#123;name&#125;-%&#123;version&#125;.tar.gz\nBuildRoot:      %&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root\n\n%description\nThe rpm version of html-megvii package\n\n%prep\n%setup -q\n\n%build\n%install\nrm -rf <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\nmkdir -p <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\ncp -a * <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\n\n%clean\nrm -rf <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\n\n%files\n%defattr(-,root,root,-)\n/opt/megvii</code></pre>\n\n<a id=\"more\"></a>\n\n<p>spec脚本中各个配置项说明</p>\n<pre><code class=\"hljs sh\">Name: 软件包的名称，后面可使用%&#123;name&#125;的方式引用\nLicense: 软件授权方式\nVersion: 软件的实际版本号,后面可使用%&#123;version&#125;引用\nRelease: 发布序列号,标明第几次打包，后面可使用%&#123;release&#125;引用\nSummary: 软件包的内容概要\nAutoReqProv: 此域用于指示RPM是否自动查找软件所需的共享库与其提供的共享库\n\nGroup: 软件分组\nURL: 软件的主页\nSource: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%&#123;source1&#125;、%&#123;source2&#125;引用\nBuildRoot: 这个是安装或编译时使用的“虚拟目录”,一般定义为:%&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root\n\n%description 软件的详细说明\n\n%prep 预处理脚本\n%setup 把源码包解压并放好,将SOURCES下的tar.gz 文件解压至BUILD文件夹下\n\n%build 开始构建包\n%install 开始把软件安装到虚拟的根目录中\n\n%clean 清理临时文件\n\n%files 定义那些文件或目录会放入rpm中,files下的文件，必须是tar包解压开存在的文件\n%defattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755</code></pre>\n\n<p><strong>注1:</strong>    SOURCES下的tar.gz包的文件名必须和SPECS下 xxx.specs  文件中的Source 保持一致。</p>\n<p><strong>注2:</strong>    SOURCES下的tar.gz包<strong>解压开的文件夹</strong>名称也应为SPECS下 xxx.specs  文件中的Source 对应的名称(无须tar.gz)。</p>\n<p><strong>注3:</strong>    %files标签下的文件路径必须存在，如/opt/megvii ,在tar.gz 解压开的文件路径是存在的</p>\n</li>\n<li><p>添加源码文件</p>\n<pre><code class=\"hljs sh\">tar czvf h5-megvii-1.0.tar.gz h5-megvii-1.0\ncp h5-megvii-1.0.tar.gz rpmbuild/SOURCES/</code></pre>\n\n</li>\n</ol>\n<h2 id=\"执行打包命令\"><a href=\"#执行打包命令\" class=\"headerlink\" title=\"执行打包命令\"></a>执行打包命令</h2><pre><code class=\"hljs sh\">rpmbuild --nodeps -ba rpmbuild/SPECS/h5-megvii.spec</code></pre>\n\n<p>打完包之后的rpm包文件位置在<code>rpmbuild/RPMS</code>文件夹中</p>\n","site":{"data":{}},"excerpt":"<p>centos 6.5下打rpm包，由于不想给客户更多的安装信息，所以将服务打成rpm包，方便客户安装。不是计划给系统使用建议还是不要将服务打成RPM包。以下的打包也是简易的打包流程，仅记录使用。</p>\n<h2 id=\"工具准备\"><a href=\"#工具准备\" class=\"headerlink\" title=\"工具准备\"></a>工具准备</h2><ol>\n<li><p>安装rpmtools工具</p>\n<pre><code class=\"hljs sh\">yum install rpmdevtools</code></pre>\n</li>\n<li><p>创建文件夹</p>\n<pre><code class=\"hljs sh\">mkdir -pv ~/rpmbuild/&#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125;</code></pre>\n\n</li>\n</ol>\n<h2 id=\"配置文件及源码准备\"><a href=\"#配置文件及源码准备\" class=\"headerlink\" title=\"配置文件及源码准备\"></a>配置文件及源码准备</h2><ol>\n<li><p>spec脚本文件创建，在SPECS文件夹下创建一个.spec文件 如h5-megvii.spec</p>\n<pre><code class=\"hljs sh\">Name:           h5-megvii\nLicense:        copyright\nVersion:        1.0\nRelease:        1%&#123;?dist&#125;\nSummary:        HTML FaceID Server\nAutoReqProv:    no\n\nGroup:          Megvii\nURL:            http://www.megvii.com\nSource:         %&#123;name&#125;-%&#123;version&#125;.tar.gz\nBuildRoot:      %&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root\n\n%description\nThe rpm version of html-megvii package\n\n%prep\n%setup -q\n\n%build\n%install\nrm -rf <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\nmkdir -p <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\ncp -a * <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\n\n%clean\nrm -rf <span class=\"hljs-variable\">$RPM_BUILD_ROOT</span>\n\n%files\n%defattr(-,root,root,-)\n/opt/megvii</code></pre>","more":"<p>spec脚本中各个配置项说明</p>\n<pre><code class=\"hljs sh\">Name: 软件包的名称，后面可使用%&#123;name&#125;的方式引用\nLicense: 软件授权方式\nVersion: 软件的实际版本号,后面可使用%&#123;version&#125;引用\nRelease: 发布序列号,标明第几次打包，后面可使用%&#123;release&#125;引用\nSummary: 软件包的内容概要\nAutoReqProv: 此域用于指示RPM是否自动查找软件所需的共享库与其提供的共享库\n\nGroup: 软件分组\nURL: 软件的主页\nSource: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%&#123;source1&#125;、%&#123;source2&#125;引用\nBuildRoot: 这个是安装或编译时使用的“虚拟目录”,一般定义为:%&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root\n\n%description 软件的详细说明\n\n%prep 预处理脚本\n%setup 把源码包解压并放好,将SOURCES下的tar.gz 文件解压至BUILD文件夹下\n\n%build 开始构建包\n%install 开始把软件安装到虚拟的根目录中\n\n%clean 清理临时文件\n\n%files 定义那些文件或目录会放入rpm中,files下的文件，必须是tar包解压开存在的文件\n%defattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755</code></pre>\n\n<p><strong>注1:</strong>    SOURCES下的tar.gz包的文件名必须和SPECS下 xxx.specs  文件中的Source 保持一致。</p>\n<p><strong>注2:</strong>    SOURCES下的tar.gz包<strong>解压开的文件夹</strong>名称也应为SPECS下 xxx.specs  文件中的Source 对应的名称(无须tar.gz)。</p>\n<p><strong>注3:</strong>    %files标签下的文件路径必须存在，如/opt/megvii ,在tar.gz 解压开的文件路径是存在的</p>\n</li>\n<li><p>添加源码文件</p>\n<pre><code class=\"hljs sh\">tar czvf h5-megvii-1.0.tar.gz h5-megvii-1.0\ncp h5-megvii-1.0.tar.gz rpmbuild/SOURCES/</code></pre>\n\n</li>\n</ol>\n<h2 id=\"执行打包命令\"><a href=\"#执行打包命令\" class=\"headerlink\" title=\"执行打包命令\"></a>执行打包命令</h2><pre><code class=\"hljs sh\">rpmbuild --nodeps -ba rpmbuild/SPECS/h5-megvii.spec</code></pre>\n\n<p>打完包之后的rpm包文件位置在<code>rpmbuild/RPMS</code>文件夹中</p>"},{"title":"MySQL系列一之基础使用","date":"2018-08-12T11:47:00.000Z","index_img":["/images/mysql/logo-mysql.png"],"_content":"\nMySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。\n\n### 链接MySQL服务\n\n通过命令行建立链接\n\n```shell\n# -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e\"show databases\" \n# 建立链接的同时，执行提前写好的sql文件\nmysql -uroot -proot < test.sql\n```\n\n### 数据库管理\n\n数据库管理包括，数据库创建，数据库删除，数据库使用等操作\n\n```mysql\n-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;\n```\n\n### 数据表管理\n\n数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改\n\n```mysql\n-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname ='golang',description='开发语言';\nINSERT INTO class (cname,description) VALUES('PHP','开发语言'),('Mysql','数据库');\n-- 数据表删除单条记录\ndelete from class where cname='golang';\n-- 数据表修改单条记录\nupdate class set cname = \"PHP2\" where id=2;\n-- 删除表\ndrop table if exits class;\n```\n\n创建数据模板表，后续可以根据模板表创建新的数据表\n\n```mysql\n-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;\n```\n\n数据表字段名称修改以及字段增删\n\n```mysql\n-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);\n```\n\n数据表相关主键操作，主键的增删\n\n```mysql\n-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);\n```\n\n### 数据类型\n\nMySQL数据类型包括字符串，数值类型，枚举类型\n\n**字符串数据类型**\n\n| 类型       | 大小                | 用途                            |\n| :--------- | :------------------ | :------------------------------ |\n| CHAR       | 0-255字节           | 定长字符串                      |\n| VARCHAR    | 0-65535 字节        | 变长字符串                      |\n| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255字节           | 短文本字符串                    |\n| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535字节        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |\n\nCHAR类型是定长的数据类型，比如定义20长度的`char`类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。\n\nVARCHAR类型是变长数据类型，空间受内容长度影响。\n\n**字符串常用函数**\n\n| 函数名          | 作用                         | 示例                                                  |\n| --------------- | ---------------------------- | ----------------------------------------------------- |\n| UPPER()/LOWER() | 将内容全部改成大写/小写      | select UPPER(cname) from class;                       |\n| CONCAT()        | 字符拼接                     | select concat(cname,description) from class;          |\n| Left()/Right()  | 用于取左或右指定数量的字符   | select left(cname,3) from class;                      |\n| mid             | 从中间取字符串               | select *  from class where mid(cname,2,2) = 'hp';     |\n| substring       | 从指定位置开始向右截取字符串 | select *  from class where SUBSTRING(cname,2) = 'hp'; |\n| char_length     | 获取字符串数量               | select char_length(cname) from class;                 |\n\n正则表达式和like的使用\n\n```mysql\n-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP 'php|mysql';\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE '_h%';\n```\n\n**数值整型类型**\n\n| MySQL数据类型 | 含义（有符号）                       |\n| ------------- | ------------------------------------ |\n| tinyint(m)    | 1个字节 范围(-128~127)               |\n| smallint(m)   | 2个字节 范围(-32768~32767)           |\n| mediumint(m)  | 3个字节 范围(-8388608~8388607)       |\n| int(m)        | 4个字节 范围(-2147483648~2147483647) |\n| bigint(m)     | 8个字节 范围(+-9.22*10的18次方)      |\n\n取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。\n\n**数值浮点型**\n\n| 类型    | 大小                               | 范围（有符号）                                               | 范围（无符号）                                               |\n| :------ | :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| FLOAT   | 4 字节                             | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  |\n| DOUBLE  | 8 字节                             | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |\n| DECIMAL | DECIMAL(M,D) ，m<65 是总个数，d<30 | 依赖于M和D的值                                               | 依赖于M和D的值                                               |\n\n**ENUM/SET**\n\nENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。\n\nSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。\n\n### 日期时间\n\n| 日期时间类型 | 占用空间 | 日期格式            | 最小值              | 最大值              | 零值表示            |\n| ------------ | -------- | ------------------- | ------------------- | ------------------- | ------------------- |\n| DATETIME     | 8 bytes  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 | 0000-00-00 00:00:00 |\n| TIMESTAMP    | 4 bytes  | YYYY-MM-DD HH:MM:SS | 1970-01-01 08:00:01 | 2038-01-19 03:14:07 | 00000000000000      |\n| DATE         | 4 bytes  | YYYY-MM-DD          | 1000-01-01          | 9999-12-31          | 0000-00-00          |\n| TIME         | 3 bytes  | HH:MM:SS            | -838:59:59          | 838:59:59           | 00:00:00            |\n| YEAR         | 1 bytes  | YYYY                | 1901                | 2155                | 0000                |\n\nMysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,\n\n创建字段\n\n```sql\nALTER TABLE class ADD create_at datetime default null;\n```\n\n对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档\n\n| 参数 | 描述                               |\n| ---- | ---------------------------------- |\n| %Y   | 年，4 位                           |\n| %y   | 年，2位                            |\n| %M   | 月名                               |\n| %m   | 月，数值(00-12)                    |\n| %H   | 小时 (00-23)                       |\n| %h   | 小时 (01-12)                       |\n| %i   | 分钟，数值(00-59)                  |\n| %s   | 秒(00-59)                          |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM） |\n\n使用示例\n\n```mysql\nselect cname,DATE_FORMAT(create_at,'%Y年%m月%d %H时%i分%s秒') as create_at from class;\nselect cname,TIME_FORMAT(create_at,'%r') as create_at from class;\n```\n\n**添加数据时自动更新时间**\n\n```mysql\nalter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n```\n\n只要该条记录有任何一个字段被修改，则自动更新update_at字段的值\n\n**常用函数**\n\n| 函数                    | 说明                                                 |\n| ----------------------- | ---------------------------------------------------- |\n| HOUR                    | 小时                                                 |\n| MINUTE                  | 分                                                   |\n| SECOND                  | 秒                                                   |\n| YEAR                    | 年                                                   |\n| MONTH                   | 月                                                   |\n| DAY                     | 日                                                   |\n| TIME                    | 获取时间                                             |\n| WEEK                    | 周                                                   |\n| QUARTER                 | 季                                                   |\n| CURRENT_DATE（CURDATE） | 当前日期                                             |\n| CURRENT_TIME            | 当前时间                                             |\n| NOW                     | 当前时间                                             |\n| DAYOFYEAR               | 一年中的日数                                         |\n| DAYOFMONTH              | 月份中日数                                           |\n| DAYOFWEEK               | 星期天（1）到星期六（7）                             |\n| WEEKDAY                 | 星期一（0）到星期天（6）                             |\n| TO_DAYS                 | 从元年到现在的天数（忽略时间部分）                   |\n| FROM_DAYS               | 根据天数得到日期（忽略时间部分）                     |\n| TIME_TO_SEC             | 时间转为秒数（忽略日期部分）                         |\n| SEC_TO_TIME             | 根据秒数转为时间（忽略日期部分）                     |\n| UNIX_TIMESTAMP          | 根据日期返回秒数（包括日期与时间）                   |\n| FROM_UNIXTIME           | 根据秒数返回日期与时间（包括日期与时间）             |\n| DATEDIFF                | 两个日期相差的天数（忽略时间部分）                   |\n| TIMEDIFF                | 计算两个时间的间隔（忽略日期部分）                   |\n| TIMESTAMPDIFF           | 根据指定单位计算两个日期时间的间隔（包括日期与时间） |\n| LAST_DAY                | 该月的最后一天                                       |\n\n使用示例\n\n```mysql\n-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());\n```\n\n**时间计算 常用函数 **\n\n| 函数      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| ADDTIME   | 添加时间（负数为减少），只对时间有效                         |\n| TIMESTAMP | 添加时间（负数为减少），只对时间有效                         |\n| DATE_ADD  | 根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB) |\n| DATE_SUB  | DATE_ADD的反函数                                             |\n| LAST_DAY  | 指定月最后一天日期                                           |\n\n使用示例\n\n```mysql\n-- 获取七小时之前的时间\nselect ADDTIME(now(),'-7:00:00')\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);\n```\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))\n\n","source":"_posts/MySQL系列一.md","raw":"---\ntitle: MySQL系列一之基础使用\ndate: 2018-08-12 19:47:00\nindex_img:\n- /images/mysql/logo-mysql.png\ntags: \n- mysql\ncategories:\n- DB\n---\n\nMySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。\n\n### 链接MySQL服务\n\n通过命令行建立链接\n\n```shell\n# -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e\"show databases\" \n# 建立链接的同时，执行提前写好的sql文件\nmysql -uroot -proot < test.sql\n```\n\n### 数据库管理\n\n数据库管理包括，数据库创建，数据库删除，数据库使用等操作\n\n```mysql\n-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;\n```\n\n### 数据表管理\n\n数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改\n\n```mysql\n-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname ='golang',description='开发语言';\nINSERT INTO class (cname,description) VALUES('PHP','开发语言'),('Mysql','数据库');\n-- 数据表删除单条记录\ndelete from class where cname='golang';\n-- 数据表修改单条记录\nupdate class set cname = \"PHP2\" where id=2;\n-- 删除表\ndrop table if exits class;\n```\n\n创建数据模板表，后续可以根据模板表创建新的数据表\n\n```mysql\n-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;\n```\n\n数据表字段名称修改以及字段增删\n\n```mysql\n-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);\n```\n\n数据表相关主键操作，主键的增删\n\n```mysql\n-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);\n```\n\n### 数据类型\n\nMySQL数据类型包括字符串，数值类型，枚举类型\n\n**字符串数据类型**\n\n| 类型       | 大小                | 用途                            |\n| :--------- | :------------------ | :------------------------------ |\n| CHAR       | 0-255字节           | 定长字符串                      |\n| VARCHAR    | 0-65535 字节        | 变长字符串                      |\n| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255字节           | 短文本字符串                    |\n| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535字节        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |\n\nCHAR类型是定长的数据类型，比如定义20长度的`char`类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。\n\nVARCHAR类型是变长数据类型，空间受内容长度影响。\n\n**字符串常用函数**\n\n| 函数名          | 作用                         | 示例                                                  |\n| --------------- | ---------------------------- | ----------------------------------------------------- |\n| UPPER()/LOWER() | 将内容全部改成大写/小写      | select UPPER(cname) from class;                       |\n| CONCAT()        | 字符拼接                     | select concat(cname,description) from class;          |\n| Left()/Right()  | 用于取左或右指定数量的字符   | select left(cname,3) from class;                      |\n| mid             | 从中间取字符串               | select *  from class where mid(cname,2,2) = 'hp';     |\n| substring       | 从指定位置开始向右截取字符串 | select *  from class where SUBSTRING(cname,2) = 'hp'; |\n| char_length     | 获取字符串数量               | select char_length(cname) from class;                 |\n\n正则表达式和like的使用\n\n```mysql\n-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP 'php|mysql';\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE '_h%';\n```\n\n**数值整型类型**\n\n| MySQL数据类型 | 含义（有符号）                       |\n| ------------- | ------------------------------------ |\n| tinyint(m)    | 1个字节 范围(-128~127)               |\n| smallint(m)   | 2个字节 范围(-32768~32767)           |\n| mediumint(m)  | 3个字节 范围(-8388608~8388607)       |\n| int(m)        | 4个字节 范围(-2147483648~2147483647) |\n| bigint(m)     | 8个字节 范围(+-9.22*10的18次方)      |\n\n取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。\n\n**数值浮点型**\n\n| 类型    | 大小                               | 范围（有符号）                                               | 范围（无符号）                                               |\n| :------ | :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| FLOAT   | 4 字节                             | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  |\n| DOUBLE  | 8 字节                             | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |\n| DECIMAL | DECIMAL(M,D) ，m<65 是总个数，d<30 | 依赖于M和D的值                                               | 依赖于M和D的值                                               |\n\n**ENUM/SET**\n\nENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。\n\nSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。\n\n### 日期时间\n\n| 日期时间类型 | 占用空间 | 日期格式            | 最小值              | 最大值              | 零值表示            |\n| ------------ | -------- | ------------------- | ------------------- | ------------------- | ------------------- |\n| DATETIME     | 8 bytes  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 | 0000-00-00 00:00:00 |\n| TIMESTAMP    | 4 bytes  | YYYY-MM-DD HH:MM:SS | 1970-01-01 08:00:01 | 2038-01-19 03:14:07 | 00000000000000      |\n| DATE         | 4 bytes  | YYYY-MM-DD          | 1000-01-01          | 9999-12-31          | 0000-00-00          |\n| TIME         | 3 bytes  | HH:MM:SS            | -838:59:59          | 838:59:59           | 00:00:00            |\n| YEAR         | 1 bytes  | YYYY                | 1901                | 2155                | 0000                |\n\nMysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,\n\n创建字段\n\n```sql\nALTER TABLE class ADD create_at datetime default null;\n```\n\n对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档\n\n| 参数 | 描述                               |\n| ---- | ---------------------------------- |\n| %Y   | 年，4 位                           |\n| %y   | 年，2位                            |\n| %M   | 月名                               |\n| %m   | 月，数值(00-12)                    |\n| %H   | 小时 (00-23)                       |\n| %h   | 小时 (01-12)                       |\n| %i   | 分钟，数值(00-59)                  |\n| %s   | 秒(00-59)                          |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM） |\n\n使用示例\n\n```mysql\nselect cname,DATE_FORMAT(create_at,'%Y年%m月%d %H时%i分%s秒') as create_at from class;\nselect cname,TIME_FORMAT(create_at,'%r') as create_at from class;\n```\n\n**添加数据时自动更新时间**\n\n```mysql\nalter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n```\n\n只要该条记录有任何一个字段被修改，则自动更新update_at字段的值\n\n**常用函数**\n\n| 函数                    | 说明                                                 |\n| ----------------------- | ---------------------------------------------------- |\n| HOUR                    | 小时                                                 |\n| MINUTE                  | 分                                                   |\n| SECOND                  | 秒                                                   |\n| YEAR                    | 年                                                   |\n| MONTH                   | 月                                                   |\n| DAY                     | 日                                                   |\n| TIME                    | 获取时间                                             |\n| WEEK                    | 周                                                   |\n| QUARTER                 | 季                                                   |\n| CURRENT_DATE（CURDATE） | 当前日期                                             |\n| CURRENT_TIME            | 当前时间                                             |\n| NOW                     | 当前时间                                             |\n| DAYOFYEAR               | 一年中的日数                                         |\n| DAYOFMONTH              | 月份中日数                                           |\n| DAYOFWEEK               | 星期天（1）到星期六（7）                             |\n| WEEKDAY                 | 星期一（0）到星期天（6）                             |\n| TO_DAYS                 | 从元年到现在的天数（忽略时间部分）                   |\n| FROM_DAYS               | 根据天数得到日期（忽略时间部分）                     |\n| TIME_TO_SEC             | 时间转为秒数（忽略日期部分）                         |\n| SEC_TO_TIME             | 根据秒数转为时间（忽略日期部分）                     |\n| UNIX_TIMESTAMP          | 根据日期返回秒数（包括日期与时间）                   |\n| FROM_UNIXTIME           | 根据秒数返回日期与时间（包括日期与时间）             |\n| DATEDIFF                | 两个日期相差的天数（忽略时间部分）                   |\n| TIMEDIFF                | 计算两个时间的间隔（忽略日期部分）                   |\n| TIMESTAMPDIFF           | 根据指定单位计算两个日期时间的间隔（包括日期与时间） |\n| LAST_DAY                | 该月的最后一天                                       |\n\n使用示例\n\n```mysql\n-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());\n```\n\n**时间计算 常用函数 **\n\n| 函数      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| ADDTIME   | 添加时间（负数为减少），只对时间有效                         |\n| TIMESTAMP | 添加时间（负数为减少），只对时间有效                         |\n| DATE_ADD  | 根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB) |\n| DATE_SUB  | DATE_ADD的反函数                                             |\n| LAST_DAY  | 指定月最后一天日期                                           |\n\n使用示例\n\n```mysql\n-- 获取七小时之前的时间\nselect ADDTIME(now(),'-7:00:00')\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);\n```\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))\n\n","slug":"MySQL系列一","published":1,"updated":"2020-03-24T08:10:07.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s050005mdymg6smfo0z","content":"<p>MySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。</p>\n<h3 id=\"链接MySQL服务\"><a href=\"#链接MySQL服务\" class=\"headerlink\" title=\"链接MySQL服务\"></a>链接MySQL服务</h3><p>通过命令行建立链接</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作</span>\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e&quot;show databases&quot; \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 建立链接的同时，执行提前写好的sql文件</span>\nmysql -uroot -proot &lt; test.sql</code></pre>\n\n<h3 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h3><p>数据库管理包括，数据库创建，数据库删除，数据库使用等操作</p>\n<pre><code class=\"hljs mysql\">-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;</code></pre>\n\n<h3 id=\"数据表管理\"><a href=\"#数据表管理\" class=\"headerlink\" title=\"数据表管理\"></a>数据表管理</h3><p>数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改</p>\n<pre><code class=\"hljs mysql\">-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname &#x3D;&#39;golang&#39;,description&#x3D;&#39;开发语言&#39;;\nINSERT INTO class (cname,description) VALUES(&#39;PHP&#39;,&#39;开发语言&#39;),(&#39;Mysql&#39;,&#39;数据库&#39;);\n-- 数据表删除单条记录\ndelete from class where cname&#x3D;&#39;golang&#39;;\n-- 数据表修改单条记录\nupdate class set cname &#x3D; &quot;PHP2&quot; where id&#x3D;2;\n-- 删除表\ndrop table if exits class;</code></pre>\n\n<p>创建数据模板表，后续可以根据模板表创建新的数据表</p>\n<pre><code class=\"hljs mysql\">-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;</code></pre>\n\n<p>数据表字段名称修改以及字段增删</p>\n<pre><code class=\"hljs mysql\">-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);</code></pre>\n\n<p>数据表相关主键操作，主键的增删</p>\n<pre><code class=\"hljs mysql\">-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</code></pre>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>MySQL数据类型包括字符串，数值类型，枚举类型</p>\n<p><strong>字符串数据类型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CHAR</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">定长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">VARCHAR</td>\n<td align=\"left\">0-65535 字节</td>\n<td align=\"left\">变长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYBLOB</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">不超过 255 个字符的二进制字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYTEXT</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">短文本字符串</td>\n</tr>\n<tr>\n<td align=\"left\">BLOB</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">TEXT</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMBLOB</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">二进制形式的中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMTEXT</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGBLOB</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">二进制形式的极大文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGTEXT</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">极大文本数据</td>\n</tr>\n</tbody></table>\n<p>CHAR类型是定长的数据类型，比如定义20长度的<code>char</code>类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。</p>\n<p>VARCHAR类型是变长数据类型，空间受内容长度影响。</p>\n<p><strong>字符串常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UPPER()/LOWER()</td>\n<td>将内容全部改成大写/小写</td>\n<td>select UPPER(cname) from class;</td>\n</tr>\n<tr>\n<td>CONCAT()</td>\n<td>字符拼接</td>\n<td>select concat(cname,description) from class;</td>\n</tr>\n<tr>\n<td>Left()/Right()</td>\n<td>用于取左或右指定数量的字符</td>\n<td>select left(cname,3) from class;</td>\n</tr>\n<tr>\n<td>mid</td>\n<td>从中间取字符串</td>\n<td>select *  from class where mid(cname,2,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>substring</td>\n<td>从指定位置开始向右截取字符串</td>\n<td>select *  from class where SUBSTRING(cname,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>char_length</td>\n<td>获取字符串数量</td>\n<td>select char_length(cname) from class;</td>\n</tr>\n</tbody></table>\n<p>正则表达式和like的使用</p>\n<pre><code class=\"hljs mysql\">-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP &#39;php|mysql&#39;;\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE &#39;_h%&#39;;</code></pre>\n\n<p><strong>数值整型类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>MySQL数据类型</th>\n<th>含义（有符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tinyint(m)</td>\n<td>1个字节 范围(-128~127)</td>\n</tr>\n<tr>\n<td>smallint(m)</td>\n<td>2个字节 范围(-32768~32767)</td>\n</tr>\n<tr>\n<td>mediumint(m)</td>\n<td>3个字节 范围(-8388608~8388607)</td>\n</tr>\n<tr>\n<td>int(m)</td>\n<td>4个字节 范围(-2147483648~2147483647)</td>\n</tr>\n<tr>\n<td>bigint(m)</td>\n<td>8个字节 范围(+-9.22*10的18次方)</td>\n</tr>\n</tbody></table>\n<p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。</p>\n<p><strong>数值浮点型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">范围（有符号）</th>\n<th align=\"left\">范围（无符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">FLOAT</td>\n<td align=\"left\">4 字节</td>\n<td align=\"left\">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>\n<td align=\"left\">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>\n</tr>\n<tr>\n<td align=\"left\">DOUBLE</td>\n<td align=\"left\">8 字节</td>\n<td align=\"left\">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n<td align=\"left\">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n</tr>\n<tr>\n<td align=\"left\">DECIMAL</td>\n<td align=\"left\">DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td>\n<td align=\"left\">依赖于M和D的值</td>\n<td align=\"left\">依赖于M和D的值</td>\n</tr>\n</tbody></table>\n<p><strong>ENUM/SET</strong></p>\n<p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。</p>\n<p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。</p>\n<h3 id=\"日期时间\"><a href=\"#日期时间\" class=\"headerlink\" title=\"日期时间\"></a>日期时间</h3><table>\n<thead>\n<tr>\n<th>日期时间类型</th>\n<th>占用空间</th>\n<th>日期格式</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>零值表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATETIME</td>\n<td>8 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1000-01-01 00:00:00</td>\n<td>9999-12-31 23:59:59</td>\n<td>0000-00-00 00:00:00</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1970-01-01 08:00:01</td>\n<td>2038-01-19 03:14:07</td>\n<td>00000000000000</td>\n</tr>\n<tr>\n<td>DATE</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD</td>\n<td>1000-01-01</td>\n<td>9999-12-31</td>\n<td>0000-00-00</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>3 bytes</td>\n<td>HH:MM:SS</td>\n<td>-838:59:59</td>\n<td>838:59:59</td>\n<td>00:00:00</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>1 bytes</td>\n<td>YYYY</td>\n<td>1901</td>\n<td>2155</td>\n<td>0000</td>\n</tr>\n</tbody></table>\n<p>Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,</p>\n<p>创建字段</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">ADD</span> create_at datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-literal\">null</span>;</code></pre>\n\n<p>对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%Y</td>\n<td>年，4 位</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年，2位</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>月名</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月，数值(00-12)</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>小时 (00-23)</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>小时 (01-12)</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>分钟，数值(00-59)</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>秒(00-59)</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>时间，12-小时（hh:mm:ss AM 或 PM）</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">select cname,DATE_FORMAT(create_at,&#39;%Y年%m月%d %H时%i分%s秒&#39;) as create_at from class;\nselect cname,TIME_FORMAT(create_at,&#39;%r&#39;) as create_at from class;</code></pre>\n\n<p><strong>添加数据时自动更新时间</strong></p>\n<pre><code class=\"hljs mysql\">alter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;</code></pre>\n\n<p>只要该条记录有任何一个字段被修改，则自动更新update_at字段的值</p>\n<p><strong>常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HOUR</td>\n<td>小时</td>\n</tr>\n<tr>\n<td>MINUTE</td>\n<td>分</td>\n</tr>\n<tr>\n<td>SECOND</td>\n<td>秒</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>年</td>\n</tr>\n<tr>\n<td>MONTH</td>\n<td>月</td>\n</tr>\n<tr>\n<td>DAY</td>\n<td>日</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>获取时间</td>\n</tr>\n<tr>\n<td>WEEK</td>\n<td>周</td>\n</tr>\n<tr>\n<td>QUARTER</td>\n<td>季</td>\n</tr>\n<tr>\n<td>CURRENT_DATE（CURDATE）</td>\n<td>当前日期</td>\n</tr>\n<tr>\n<td>CURRENT_TIME</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>NOW</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>DAYOFYEAR</td>\n<td>一年中的日数</td>\n</tr>\n<tr>\n<td>DAYOFMONTH</td>\n<td>月份中日数</td>\n</tr>\n<tr>\n<td>DAYOFWEEK</td>\n<td>星期天（1）到星期六（7）</td>\n</tr>\n<tr>\n<td>WEEKDAY</td>\n<td>星期一（0）到星期天（6）</td>\n</tr>\n<tr>\n<td>TO_DAYS</td>\n<td>从元年到现在的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>FROM_DAYS</td>\n<td>根据天数得到日期（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIME_TO_SEC</td>\n<td>时间转为秒数（忽略日期部分）</td>\n</tr>\n<tr>\n<td>SEC_TO_TIME</td>\n<td>根据秒数转为时间（忽略日期部分）</td>\n</tr>\n<tr>\n<td>UNIX_TIMESTAMP</td>\n<td>根据日期返回秒数（包括日期与时间）</td>\n</tr>\n<tr>\n<td>FROM_UNIXTIME</td>\n<td>根据秒数返回日期与时间（包括日期与时间）</td>\n</tr>\n<tr>\n<td>DATEDIFF</td>\n<td>两个日期相差的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIMEDIFF</td>\n<td>计算两个时间的间隔（忽略日期部分）</td>\n</tr>\n<tr>\n<td>TIMESTAMPDIFF</td>\n<td>根据指定单位计算两个日期时间的间隔（包括日期与时间）</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>该月的最后一天</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());</code></pre>\n\n<p>**时间计算 常用函数 **</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADDTIME</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>DATE_ADD</td>\n<td>根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB)</td>\n</tr>\n<tr>\n<td>DATE_SUB</td>\n<td>DATE_ADD的反函数</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>指定月最后一天日期</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 获取七小时之前的时间\nselect ADDTIME(now(),&#39;-7:00:00&#39;)\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);</code></pre>\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。</p>\n<h3 id=\"链接MySQL服务\"><a href=\"#链接MySQL服务\" class=\"headerlink\" title=\"链接MySQL服务\"></a>链接MySQL服务</h3><p>通过命令行建立链接</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作</span>\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e&quot;show databases&quot; \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 建立链接的同时，执行提前写好的sql文件</span>\nmysql -uroot -proot &lt; test.sql</code></pre>\n\n<h3 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h3><p>数据库管理包括，数据库创建，数据库删除，数据库使用等操作</p>\n<pre><code class=\"hljs mysql\">-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;</code></pre>\n\n<h3 id=\"数据表管理\"><a href=\"#数据表管理\" class=\"headerlink\" title=\"数据表管理\"></a>数据表管理</h3><p>数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改</p>\n<pre><code class=\"hljs mysql\">-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname &#x3D;&#39;golang&#39;,description&#x3D;&#39;开发语言&#39;;\nINSERT INTO class (cname,description) VALUES(&#39;PHP&#39;,&#39;开发语言&#39;),(&#39;Mysql&#39;,&#39;数据库&#39;);\n-- 数据表删除单条记录\ndelete from class where cname&#x3D;&#39;golang&#39;;\n-- 数据表修改单条记录\nupdate class set cname &#x3D; &quot;PHP2&quot; where id&#x3D;2;\n-- 删除表\ndrop table if exits class;</code></pre>\n\n<p>创建数据模板表，后续可以根据模板表创建新的数据表</p>\n<pre><code class=\"hljs mysql\">-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;</code></pre>\n\n<p>数据表字段名称修改以及字段增删</p>\n<pre><code class=\"hljs mysql\">-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);</code></pre>\n\n<p>数据表相关主键操作，主键的增删</p>\n<pre><code class=\"hljs mysql\">-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</code></pre>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>MySQL数据类型包括字符串，数值类型，枚举类型</p>\n<p><strong>字符串数据类型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CHAR</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">定长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">VARCHAR</td>\n<td align=\"left\">0-65535 字节</td>\n<td align=\"left\">变长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYBLOB</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">不超过 255 个字符的二进制字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYTEXT</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">短文本字符串</td>\n</tr>\n<tr>\n<td align=\"left\">BLOB</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">TEXT</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMBLOB</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">二进制形式的中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMTEXT</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGBLOB</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">二进制形式的极大文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGTEXT</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">极大文本数据</td>\n</tr>\n</tbody></table>\n<p>CHAR类型是定长的数据类型，比如定义20长度的<code>char</code>类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。</p>\n<p>VARCHAR类型是变长数据类型，空间受内容长度影响。</p>\n<p><strong>字符串常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UPPER()/LOWER()</td>\n<td>将内容全部改成大写/小写</td>\n<td>select UPPER(cname) from class;</td>\n</tr>\n<tr>\n<td>CONCAT()</td>\n<td>字符拼接</td>\n<td>select concat(cname,description) from class;</td>\n</tr>\n<tr>\n<td>Left()/Right()</td>\n<td>用于取左或右指定数量的字符</td>\n<td>select left(cname,3) from class;</td>\n</tr>\n<tr>\n<td>mid</td>\n<td>从中间取字符串</td>\n<td>select *  from class where mid(cname,2,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>substring</td>\n<td>从指定位置开始向右截取字符串</td>\n<td>select *  from class where SUBSTRING(cname,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>char_length</td>\n<td>获取字符串数量</td>\n<td>select char_length(cname) from class;</td>\n</tr>\n</tbody></table>\n<p>正则表达式和like的使用</p>\n<pre><code class=\"hljs mysql\">-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP &#39;php|mysql&#39;;\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE &#39;_h%&#39;;</code></pre>\n\n<p><strong>数值整型类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>MySQL数据类型</th>\n<th>含义（有符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tinyint(m)</td>\n<td>1个字节 范围(-128~127)</td>\n</tr>\n<tr>\n<td>smallint(m)</td>\n<td>2个字节 范围(-32768~32767)</td>\n</tr>\n<tr>\n<td>mediumint(m)</td>\n<td>3个字节 范围(-8388608~8388607)</td>\n</tr>\n<tr>\n<td>int(m)</td>\n<td>4个字节 范围(-2147483648~2147483647)</td>\n</tr>\n<tr>\n<td>bigint(m)</td>\n<td>8个字节 范围(+-9.22*10的18次方)</td>\n</tr>\n</tbody></table>\n<p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。</p>\n<p><strong>数值浮点型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">范围（有符号）</th>\n<th align=\"left\">范围（无符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">FLOAT</td>\n<td align=\"left\">4 字节</td>\n<td align=\"left\">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>\n<td align=\"left\">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>\n</tr>\n<tr>\n<td align=\"left\">DOUBLE</td>\n<td align=\"left\">8 字节</td>\n<td align=\"left\">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n<td align=\"left\">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n</tr>\n<tr>\n<td align=\"left\">DECIMAL</td>\n<td align=\"left\">DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td>\n<td align=\"left\">依赖于M和D的值</td>\n<td align=\"left\">依赖于M和D的值</td>\n</tr>\n</tbody></table>\n<p><strong>ENUM/SET</strong></p>\n<p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。</p>\n<p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。</p>\n<h3 id=\"日期时间\"><a href=\"#日期时间\" class=\"headerlink\" title=\"日期时间\"></a>日期时间</h3><table>\n<thead>\n<tr>\n<th>日期时间类型</th>\n<th>占用空间</th>\n<th>日期格式</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>零值表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATETIME</td>\n<td>8 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1000-01-01 00:00:00</td>\n<td>9999-12-31 23:59:59</td>\n<td>0000-00-00 00:00:00</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1970-01-01 08:00:01</td>\n<td>2038-01-19 03:14:07</td>\n<td>00000000000000</td>\n</tr>\n<tr>\n<td>DATE</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD</td>\n<td>1000-01-01</td>\n<td>9999-12-31</td>\n<td>0000-00-00</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>3 bytes</td>\n<td>HH:MM:SS</td>\n<td>-838:59:59</td>\n<td>838:59:59</td>\n<td>00:00:00</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>1 bytes</td>\n<td>YYYY</td>\n<td>1901</td>\n<td>2155</td>\n<td>0000</td>\n</tr>\n</tbody></table>\n<p>Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,</p>\n<p>创建字段</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">ADD</span> create_at datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-literal\">null</span>;</code></pre>\n\n<p>对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%Y</td>\n<td>年，4 位</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年，2位</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>月名</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月，数值(00-12)</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>小时 (00-23)</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>小时 (01-12)</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>分钟，数值(00-59)</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>秒(00-59)</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>时间，12-小时（hh:mm:ss AM 或 PM）</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">select cname,DATE_FORMAT(create_at,&#39;%Y年%m月%d %H时%i分%s秒&#39;) as create_at from class;\nselect cname,TIME_FORMAT(create_at,&#39;%r&#39;) as create_at from class;</code></pre>\n\n<p><strong>添加数据时自动更新时间</strong></p>\n<pre><code class=\"hljs mysql\">alter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;</code></pre>\n\n<p>只要该条记录有任何一个字段被修改，则自动更新update_at字段的值</p>\n<p><strong>常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HOUR</td>\n<td>小时</td>\n</tr>\n<tr>\n<td>MINUTE</td>\n<td>分</td>\n</tr>\n<tr>\n<td>SECOND</td>\n<td>秒</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>年</td>\n</tr>\n<tr>\n<td>MONTH</td>\n<td>月</td>\n</tr>\n<tr>\n<td>DAY</td>\n<td>日</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>获取时间</td>\n</tr>\n<tr>\n<td>WEEK</td>\n<td>周</td>\n</tr>\n<tr>\n<td>QUARTER</td>\n<td>季</td>\n</tr>\n<tr>\n<td>CURRENT_DATE（CURDATE）</td>\n<td>当前日期</td>\n</tr>\n<tr>\n<td>CURRENT_TIME</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>NOW</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>DAYOFYEAR</td>\n<td>一年中的日数</td>\n</tr>\n<tr>\n<td>DAYOFMONTH</td>\n<td>月份中日数</td>\n</tr>\n<tr>\n<td>DAYOFWEEK</td>\n<td>星期天（1）到星期六（7）</td>\n</tr>\n<tr>\n<td>WEEKDAY</td>\n<td>星期一（0）到星期天（6）</td>\n</tr>\n<tr>\n<td>TO_DAYS</td>\n<td>从元年到现在的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>FROM_DAYS</td>\n<td>根据天数得到日期（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIME_TO_SEC</td>\n<td>时间转为秒数（忽略日期部分）</td>\n</tr>\n<tr>\n<td>SEC_TO_TIME</td>\n<td>根据秒数转为时间（忽略日期部分）</td>\n</tr>\n<tr>\n<td>UNIX_TIMESTAMP</td>\n<td>根据日期返回秒数（包括日期与时间）</td>\n</tr>\n<tr>\n<td>FROM_UNIXTIME</td>\n<td>根据秒数返回日期与时间（包括日期与时间）</td>\n</tr>\n<tr>\n<td>DATEDIFF</td>\n<td>两个日期相差的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIMEDIFF</td>\n<td>计算两个时间的间隔（忽略日期部分）</td>\n</tr>\n<tr>\n<td>TIMESTAMPDIFF</td>\n<td>根据指定单位计算两个日期时间的间隔（包括日期与时间）</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>该月的最后一天</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());</code></pre>\n\n<p>**时间计算 常用函数 **</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADDTIME</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>DATE_ADD</td>\n<td>根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB)</td>\n</tr>\n<tr>\n<td>DATE_SUB</td>\n<td>DATE_ADD的反函数</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>指定月最后一天日期</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 获取七小时之前的时间\nselect ADDTIME(now(),&#39;-7:00:00&#39;)\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);</code></pre>\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n"},{"title":"MySQL系列二之基础使用","date":"2018-08-15T12:37:01.000Z","index_img":["/images/mysql/join.jpg"],"_content":"\n这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。\n\n### 摘要和排序\n\n**order by**\n\nmysql 排序的关键字为**order by**，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。\n\n```mysql\n-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id >=2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;\n```\n\n上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。\n\n```mysql\n-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),'何','赵');\n```\n\n**count函数**\n\ncount(字段) 函数不会统计null值，使用count(*)时会将null统计进去。\n\n```mysql\n-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;\n```\n\n**min/max 函数**\n\n计算最小值或最大值\n\n```mysql\n-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;\n```\n\n**SUM/AVG**函数\n\n统计和，统计平局值\n\n```mysql\n-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;\n```\n\n**distinct 函数**\n\ndistinct用于去除结果集中的重复记录\n\n```mysql\n-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;\n```\n\n**group by**\n\n在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同**sql mode**模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！\n\n```mysql\n-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';\n```\n\n不同的sql_mode\n\n| sql_mode                   | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| ONLY_FULL_GROUP_BY         | 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 |\n| STRICT_TRANS_TABLES        | 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 |\n| NO_ZERO_IN_DATE            | 在严格模式下，不允许日期和月份为零                           |\n| NO_ZERO_DATE               | 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 |\n| ERROR_FOR_DIVISION_BY_ZERO | 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL |\n| NO_ENGINE_SUBSTITUTION     | 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 |\n| NO_AUTO_VALUE_ON_ZERO      | 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 |\n\n```mysql\n-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;\n```\n\n使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组\n\n```mysql\nSELECT class_id FROM stu GROUP BY class_id HAVING count(*)>2;\n```\n\n### 多表操作\n\n在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。\n\n先看下图，一下所有的inner可以通过该图来理解。\n\n![](/images/mysql/join.jpg)\n\n**INNER**\n\n所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用**inner join** 后面跟着ON，ON后面跟的是条件\n\n```mysql\n-- 获取用户信息\nselect * from stu as s,user_info as i where s.id = i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id = i.stu_id;\n```\n\n**OUTER JOIN**\n\n外链接包括`LEFT JOIN` 与 `RIGHT JOIN` ，可以简单理解为 `LEFT JOIN`会包含左侧所有表记录，`RIGHT JOIN` 会包含右侧表全部记录。\n\n左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。\n\n```mysql\n-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id = i.stu_id\nWHERE i.qq is null;\n```\n\n同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。\n\n```mysql\n-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id = c.id\nWHERE s.id IS NULL;\n```\n\n**SELF JOIN**\n\n`SELF JOIN`为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是**子查询操作的是两次性能会比自连接消耗性能**。\n\n```mysql\n-- 使用子查询操作\nSELECT * FROM stu WHERE class_id = \n(SELECT class_id FROM stu WHERE sname = '后盾人')\nAND stu.sname !='后盾人';\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id = s2.class_id\nWHERE s1.sname = '后盾人' AND s2.sname !='后盾人';\n```\n\n**UNION**\n\n`UNION` 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。\n\n- UNION会过滤重复的结果\n- UNION ALL 不过滤重复结果\n- 列表字段由是第一个查询的字段\n\n```mysql\n-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;\n```\n\n\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))","source":"_posts/MySQL系列二.md","raw":"---\ntitle: MySQL系列二之基础使用\ndate: 2018-08-15 20:37:01\nindex_img:\n- /images/mysql/join.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\n这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。\n\n### 摘要和排序\n\n**order by**\n\nmysql 排序的关键字为**order by**，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。\n\n```mysql\n-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id >=2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;\n```\n\n上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。\n\n```mysql\n-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),'何','赵');\n```\n\n**count函数**\n\ncount(字段) 函数不会统计null值，使用count(*)时会将null统计进去。\n\n```mysql\n-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;\n```\n\n**min/max 函数**\n\n计算最小值或最大值\n\n```mysql\n-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;\n```\n\n**SUM/AVG**函数\n\n统计和，统计平局值\n\n```mysql\n-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;\n```\n\n**distinct 函数**\n\ndistinct用于去除结果集中的重复记录\n\n```mysql\n-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;\n```\n\n**group by**\n\n在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同**sql mode**模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！\n\n```mysql\n-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';\n```\n\n不同的sql_mode\n\n| sql_mode                   | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| ONLY_FULL_GROUP_BY         | 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 |\n| STRICT_TRANS_TABLES        | 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 |\n| NO_ZERO_IN_DATE            | 在严格模式下，不允许日期和月份为零                           |\n| NO_ZERO_DATE               | 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 |\n| ERROR_FOR_DIVISION_BY_ZERO | 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL |\n| NO_ENGINE_SUBSTITUTION     | 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 |\n| NO_AUTO_VALUE_ON_ZERO      | 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 |\n\n```mysql\n-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;\n```\n\n使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组\n\n```mysql\nSELECT class_id FROM stu GROUP BY class_id HAVING count(*)>2;\n```\n\n### 多表操作\n\n在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。\n\n先看下图，一下所有的inner可以通过该图来理解。\n\n![](/images/mysql/join.jpg)\n\n**INNER**\n\n所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用**inner join** 后面跟着ON，ON后面跟的是条件\n\n```mysql\n-- 获取用户信息\nselect * from stu as s,user_info as i where s.id = i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id = i.stu_id;\n```\n\n**OUTER JOIN**\n\n外链接包括`LEFT JOIN` 与 `RIGHT JOIN` ，可以简单理解为 `LEFT JOIN`会包含左侧所有表记录，`RIGHT JOIN` 会包含右侧表全部记录。\n\n左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。\n\n```mysql\n-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id = i.stu_id\nWHERE i.qq is null;\n```\n\n同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。\n\n```mysql\n-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id = c.id\nWHERE s.id IS NULL;\n```\n\n**SELF JOIN**\n\n`SELF JOIN`为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是**子查询操作的是两次性能会比自连接消耗性能**。\n\n```mysql\n-- 使用子查询操作\nSELECT * FROM stu WHERE class_id = \n(SELECT class_id FROM stu WHERE sname = '后盾人')\nAND stu.sname !='后盾人';\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id = s2.class_id\nWHERE s1.sname = '后盾人' AND s2.sname !='后盾人';\n```\n\n**UNION**\n\n`UNION` 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。\n\n- UNION会过滤重复的结果\n- UNION ALL 不过滤重复结果\n- 列表字段由是第一个查询的字段\n\n```mysql\n-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;\n```\n\n\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))","slug":"MySQL系列二","published":1,"updated":"2020-03-24T08:01:54.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s050006mdymfwvm63vj","content":"<p>这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。</p>\n<h3 id=\"摘要和排序\"><a href=\"#摘要和排序\" class=\"headerlink\" title=\"摘要和排序\"></a>摘要和排序</h3><p><strong>order by</strong></p>\n<p>mysql 排序的关键字为<strong>order by</strong>，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。</p>\n<pre><code class=\"hljs mysql\">-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id &gt;&#x3D;2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;</code></pre>\n\n<p>上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。</p>\n<pre><code class=\"hljs mysql\">-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),&#39;何&#39;,&#39;赵&#39;);</code></pre>\n\n<p><strong>count函数</strong></p>\n<p>count(字段) 函数不会统计null值，使用count(*)时会将null统计进去。</p>\n<pre><code class=\"hljs mysql\">-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;</code></pre>\n\n<p><strong>min/max 函数</strong></p>\n<p>计算最小值或最大值</p>\n<pre><code class=\"hljs mysql\">-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;</code></pre>\n\n<p><strong>SUM/AVG</strong>函数</p>\n<p>统计和，统计平局值</p>\n<pre><code class=\"hljs mysql\">-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;</code></pre>\n\n<p><strong>distinct 函数</strong></p>\n<p>distinct用于去除结果集中的重复记录</p>\n<pre><code class=\"hljs mysql\">-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;</code></pre>\n\n<p><strong>group by</strong></p>\n<p>在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同<strong>sql mode</strong>模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！</p>\n<pre><code class=\"hljs mysql\">-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode &#x3D; &#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre>\n\n<p>不同的sql_mode</p>\n<table>\n<thead>\n<tr>\n<th>sql_mode</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ONLY_FULL_GROUP_BY</td>\n<td>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</td>\n</tr>\n<tr>\n<td>STRICT_TRANS_TABLES</td>\n<td>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</td>\n</tr>\n<tr>\n<td>NO_ZERO_IN_DATE</td>\n<td>在严格模式下，不允许日期和月份为零</td>\n</tr>\n<tr>\n<td>NO_ZERO_DATE</td>\n<td>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</td>\n</tr>\n<tr>\n<td>ERROR_FOR_DIVISION_BY_ZERO</td>\n<td>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</td>\n</tr>\n<tr>\n<td>NO_ENGINE_SUBSTITUTION</td>\n<td>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</td>\n</tr>\n<tr>\n<td>NO_AUTO_VALUE_ON_ZERO</td>\n<td>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs mysql\">-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode&#x3D;(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;</code></pre>\n\n<p>使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组</p>\n<pre><code class=\"hljs mysql\">SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2;</code></pre>\n\n<h3 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h3><p>在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。</p>\n<p>先看下图，一下所有的inner可以通过该图来理解。</p>\n<p><img src=\"/images/mysql/join.jpg\"></p>\n<p><strong>INNER</strong></p>\n<p>所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用<strong>inner join</strong> 后面跟着ON，ON后面跟的是条件</p>\n<pre><code class=\"hljs mysql\">-- 获取用户信息\nselect * from stu as s,user_info as i where s.id &#x3D; i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id &#x3D; i.stu_id;</code></pre>\n\n<p><strong>OUTER JOIN</strong></p>\n<p>外链接包括<code>LEFT JOIN</code> 与 <code>RIGHT JOIN</code> ，可以简单理解为 <code>LEFT JOIN</code>会包含左侧所有表记录，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p>\n<p>左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。</p>\n<pre><code class=\"hljs mysql\">-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id &#x3D; i.stu_id\nWHERE i.qq is null;</code></pre>\n\n<p>同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。</p>\n<pre><code class=\"hljs mysql\">-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id &#x3D; c.id\nWHERE s.id IS NULL;</code></pre>\n\n<p><strong>SELF JOIN</strong></p>\n<p><code>SELF JOIN</code>为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是<strong>子查询操作的是两次性能会比自连接消耗性能</strong>。</p>\n<pre><code class=\"hljs mysql\">-- 使用子查询操作\nSELECT * FROM stu WHERE class_id &#x3D; \n(SELECT class_id FROM stu WHERE sname &#x3D; &#39;后盾人&#39;)\nAND stu.sname !&#x3D;&#39;后盾人&#39;;\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id &#x3D; s2.class_id\nWHERE s1.sname &#x3D; &#39;后盾人&#39; AND s2.sname !&#x3D;&#39;后盾人&#39;;</code></pre>\n\n<p><strong>UNION</strong></p>\n<p><code>UNION</code> 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。</p>\n<ul>\n<li>UNION会过滤重复的结果</li>\n<li>UNION ALL 不过滤重复结果</li>\n<li>列表字段由是第一个查询的字段</li>\n</ul>\n<pre><code class=\"hljs mysql\">-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;</code></pre>\n\n\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。</p>\n<h3 id=\"摘要和排序\"><a href=\"#摘要和排序\" class=\"headerlink\" title=\"摘要和排序\"></a>摘要和排序</h3><p><strong>order by</strong></p>\n<p>mysql 排序的关键字为<strong>order by</strong>，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。</p>\n<pre><code class=\"hljs mysql\">-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id &gt;&#x3D;2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;</code></pre>\n\n<p>上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。</p>\n<pre><code class=\"hljs mysql\">-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),&#39;何&#39;,&#39;赵&#39;);</code></pre>\n\n<p><strong>count函数</strong></p>\n<p>count(字段) 函数不会统计null值，使用count(*)时会将null统计进去。</p>\n<pre><code class=\"hljs mysql\">-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;</code></pre>\n\n<p><strong>min/max 函数</strong></p>\n<p>计算最小值或最大值</p>\n<pre><code class=\"hljs mysql\">-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;</code></pre>\n\n<p><strong>SUM/AVG</strong>函数</p>\n<p>统计和，统计平局值</p>\n<pre><code class=\"hljs mysql\">-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;</code></pre>\n\n<p><strong>distinct 函数</strong></p>\n<p>distinct用于去除结果集中的重复记录</p>\n<pre><code class=\"hljs mysql\">-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;</code></pre>\n\n<p><strong>group by</strong></p>\n<p>在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同<strong>sql mode</strong>模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！</p>\n<pre><code class=\"hljs mysql\">-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode &#x3D; &#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre>\n\n<p>不同的sql_mode</p>\n<table>\n<thead>\n<tr>\n<th>sql_mode</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ONLY_FULL_GROUP_BY</td>\n<td>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</td>\n</tr>\n<tr>\n<td>STRICT_TRANS_TABLES</td>\n<td>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</td>\n</tr>\n<tr>\n<td>NO_ZERO_IN_DATE</td>\n<td>在严格模式下，不允许日期和月份为零</td>\n</tr>\n<tr>\n<td>NO_ZERO_DATE</td>\n<td>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</td>\n</tr>\n<tr>\n<td>ERROR_FOR_DIVISION_BY_ZERO</td>\n<td>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</td>\n</tr>\n<tr>\n<td>NO_ENGINE_SUBSTITUTION</td>\n<td>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</td>\n</tr>\n<tr>\n<td>NO_AUTO_VALUE_ON_ZERO</td>\n<td>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs mysql\">-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode&#x3D;(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;</code></pre>\n\n<p>使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组</p>\n<pre><code class=\"hljs mysql\">SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2;</code></pre>\n\n<h3 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h3><p>在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。</p>\n<p>先看下图，一下所有的inner可以通过该图来理解。</p>\n<p><img src=\"/images/mysql/join.jpg\"></p>\n<p><strong>INNER</strong></p>\n<p>所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用<strong>inner join</strong> 后面跟着ON，ON后面跟的是条件</p>\n<pre><code class=\"hljs mysql\">-- 获取用户信息\nselect * from stu as s,user_info as i where s.id &#x3D; i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id &#x3D; i.stu_id;</code></pre>\n\n<p><strong>OUTER JOIN</strong></p>\n<p>外链接包括<code>LEFT JOIN</code> 与 <code>RIGHT JOIN</code> ，可以简单理解为 <code>LEFT JOIN</code>会包含左侧所有表记录，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p>\n<p>左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。</p>\n<pre><code class=\"hljs mysql\">-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id &#x3D; i.stu_id\nWHERE i.qq is null;</code></pre>\n\n<p>同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。</p>\n<pre><code class=\"hljs mysql\">-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id &#x3D; c.id\nWHERE s.id IS NULL;</code></pre>\n\n<p><strong>SELF JOIN</strong></p>\n<p><code>SELF JOIN</code>为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是<strong>子查询操作的是两次性能会比自连接消耗性能</strong>。</p>\n<pre><code class=\"hljs mysql\">-- 使用子查询操作\nSELECT * FROM stu WHERE class_id &#x3D; \n(SELECT class_id FROM stu WHERE sname &#x3D; &#39;后盾人&#39;)\nAND stu.sname !&#x3D;&#39;后盾人&#39;;\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id &#x3D; s2.class_id\nWHERE s1.sname &#x3D; &#39;后盾人&#39; AND s2.sname !&#x3D;&#39;后盾人&#39;;</code></pre>\n\n<p><strong>UNION</strong></p>\n<p><code>UNION</code> 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。</p>\n<ul>\n<li>UNION会过滤重复的结果</li>\n<li>UNION ALL 不过滤重复结果</li>\n<li>列表字段由是第一个查询的字段</li>\n</ul>\n<pre><code class=\"hljs mysql\">-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;</code></pre>\n\n\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n"},{"title":"MySQL系列三之事务和锁","date":"2018-08-18T15:17:01.000Z","index_img":["/images/mysql/logo-mysql.png"],"_content":"\n本篇来讲讲MySQL的事务以及锁\n\n### 事务\n\n事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。\n\n至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。\n\n```mysql\nshow engins;\n```\n\n#### 事务的特性\n\n事务具有以下的特性\n\n- 原子性\n\n  事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。\n\n- 一致性\n\n  数据库总是从一个一致性的状态转换到另一个一致性的状态。\n\n- 隔离性\n\n  一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。\n\n- 持久性\n\n  一旦事务提交，其所做的修改便会永久保存在数据库中。\n\nMysql的提交默认是自动提交，即发送一条sql执行一条。\n\n#### 事务的提交\n\n执行 `START TRANSACTION` 或 `BEGIN` 语句后，表示要开启一项事务处理。\n\n- COMMIT 提交事务\n- ROLLBACK 回滚事务\n\n```mysql\nSTART TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,'张帝','女');\nCOMMIT; -- rollback 回滚事务\n```\n\n#### 事务隔离\n\n在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？\n\n当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：\n\n1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。\n3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n> 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\n\nMySQL拥有不同的事务隔离级别\n\n| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 说明                                                         |\n| ---------------------------- | ---- | ---------- | ---- | ------------------------------------------------------------ |\n| 读未提交（read-uncommitted） | 是   | 是         | 是   | 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 |\n| 不可重复读（read-committed） | 否   | 是         | 是   | 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 |\n| 可重复读（repeatable-read）  | 否   | 否         | 是   | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 |\n| 串行化（serializable）       | 否   | 否         | 否   | 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。 |\n\n#### 查询/设置MySQL的事务隔离级别\n\nInoDB默认的事务隔离级别是repeatable-read\n\n```mysql\n-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n### 锁机制\n\n因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种\n\n- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。\n\n- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n`InnoDB` 是主流储存引擎并支持行级锁的，有更高的并发处理性能。\n\n- 行锁开销大，锁表慢\n- 行锁高并发下可并行处理，性能更高\n- 行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁\n- 在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放\n\n#### 行锁\n\n- 使用**索引字段**为筛选条件，来复现行锁。\n\n  事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。\n\n  ```mysql\n  -- 事务A\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE id=1;\n  ```\n\n  事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。\n\n  ```mysql\n  -- 事务B 阻塞\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=1;\n  commit\n  -- 事务B id=2 操作成功\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=2;\n  commit\n  ```\n\n  当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行\n\n  ```mysql\n  -- 事务A\n  commit\n  ```\n\n- 使用**非索引字段**为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。\n\n  事务A执行以下代码，因为`sname`字段没有添加索引，造成锁定整个表\n\n  ```mysql\n  -- 事务A 没有commit，同时sname 字段没有添加索引\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE sname ='haha1';\n  ```\n\n  现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态\n\n  ```mysql\n  -- 事务B 阻塞，因为stu 表锁\n  BEGIN;\n  update stu set sname = '小明' where id=1\n  commit\n  ```\n\n- 简单查看MySQL行锁的争用情况\n\n  过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\n\n  ```mysql\n  show status like 'innodb_row_lock%';\n  ```\n\n  如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。\n\n#### 区间锁（页面锁）\n\n- 使用索引字段作为筛选条件\n\n  事务A筛选时使用了范围区间\n\n  ```mysql\n  -- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\n  BEGIN;\n  UPDATE goods SET num=200 WHERE id>1 AND id<4; \n  ```\n\n  事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录\n\n  ```mysql\n  -- 事务B id=2 无法操作，区间锁\n  BEGIN;\n  update goods set num =1 where id=2;\n  commit;\n  -- 事务B id =4 正常操作\n  BEGIN;\n  update goods set num =1 where id=4;\n  commit;\n  ```\n\n#### 表锁\n\nMySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。\n\n##### 读锁\n\n为表设置读锁后，当前会话和其他会话都不可以修改数据。\n\n会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表\n\n```mysql\nLOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num=300 WHERE id=1;\nSELECT * FROM stu;\n```\n\n因为会话A对表`goods`设置了读锁，所以会话B也不能修改\n\n```mysql\nupdate goods set num=200 where id=1;-- 阻塞住\n```\n\n会话A解锁表后，其他会话又可以继续操作表了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 写锁\n\n为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。\n\n会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表\n\n```mysql\nLOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES('后盾人教程',300);\n```\n\n会话B读取/写入/写入表数据都将阻塞\n\n```mysql\nselect * from goods;-- 阻塞\n```\n\n会话A解锁表数据后，其他会话都可以正常操作了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 悲观锁\n\n悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。\n\n事务A执行悲观锁操作后，其他事务执行将被阻塞\n\n```mysql\n-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\nUPDATE goods SET num=num-2 WHERE id=1; \n```\n\n事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务\n\n```mysql\n-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\ncommit；\n```\n\n##### 乐观锁\n\n在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。\n\n事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务B同时查询，也获取了版本号为0的记录\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务A更改库存，并增加版本号\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n[超详细的锁介绍](https://blog.csdn.net/Jack__Frost/article/details/73347688)\n\n在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。\n\n1. 优化sql语句\n2. 降低MySQL数据的事务隔离级别\n\n\n\n参考链接：https://www.cnblogs.com/qq1148932219/p/11694064.html","source":"_posts/MySQL系列三.md","raw":"---\ntitle: MySQL系列三之事务和锁\ndate: 2018-08-18 23:17:01\nindex_img:\n- /images/mysql/logo-mysql.png\ntags: \n- mysql\ncategories:\n- DB\n---\n\n本篇来讲讲MySQL的事务以及锁\n\n### 事务\n\n事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。\n\n至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。\n\n```mysql\nshow engins;\n```\n\n#### 事务的特性\n\n事务具有以下的特性\n\n- 原子性\n\n  事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。\n\n- 一致性\n\n  数据库总是从一个一致性的状态转换到另一个一致性的状态。\n\n- 隔离性\n\n  一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。\n\n- 持久性\n\n  一旦事务提交，其所做的修改便会永久保存在数据库中。\n\nMysql的提交默认是自动提交，即发送一条sql执行一条。\n\n#### 事务的提交\n\n执行 `START TRANSACTION` 或 `BEGIN` 语句后，表示要开启一项事务处理。\n\n- COMMIT 提交事务\n- ROLLBACK 回滚事务\n\n```mysql\nSTART TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,'张帝','女');\nCOMMIT; -- rollback 回滚事务\n```\n\n#### 事务隔离\n\n在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？\n\n当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：\n\n1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。\n3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n> 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\n\nMySQL拥有不同的事务隔离级别\n\n| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 说明                                                         |\n| ---------------------------- | ---- | ---------- | ---- | ------------------------------------------------------------ |\n| 读未提交（read-uncommitted） | 是   | 是         | 是   | 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 |\n| 不可重复读（read-committed） | 否   | 是         | 是   | 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 |\n| 可重复读（repeatable-read）  | 否   | 否         | 是   | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 |\n| 串行化（serializable）       | 否   | 否         | 否   | 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。 |\n\n#### 查询/设置MySQL的事务隔离级别\n\nInoDB默认的事务隔离级别是repeatable-read\n\n```mysql\n-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n### 锁机制\n\n因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种\n\n- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。\n\n- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n`InnoDB` 是主流储存引擎并支持行级锁的，有更高的并发处理性能。\n\n- 行锁开销大，锁表慢\n- 行锁高并发下可并行处理，性能更高\n- 行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁\n- 在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放\n\n#### 行锁\n\n- 使用**索引字段**为筛选条件，来复现行锁。\n\n  事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。\n\n  ```mysql\n  -- 事务A\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE id=1;\n  ```\n\n  事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。\n\n  ```mysql\n  -- 事务B 阻塞\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=1;\n  commit\n  -- 事务B id=2 操作成功\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=2;\n  commit\n  ```\n\n  当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行\n\n  ```mysql\n  -- 事务A\n  commit\n  ```\n\n- 使用**非索引字段**为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。\n\n  事务A执行以下代码，因为`sname`字段没有添加索引，造成锁定整个表\n\n  ```mysql\n  -- 事务A 没有commit，同时sname 字段没有添加索引\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE sname ='haha1';\n  ```\n\n  现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态\n\n  ```mysql\n  -- 事务B 阻塞，因为stu 表锁\n  BEGIN;\n  update stu set sname = '小明' where id=1\n  commit\n  ```\n\n- 简单查看MySQL行锁的争用情况\n\n  过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\n\n  ```mysql\n  show status like 'innodb_row_lock%';\n  ```\n\n  如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。\n\n#### 区间锁（页面锁）\n\n- 使用索引字段作为筛选条件\n\n  事务A筛选时使用了范围区间\n\n  ```mysql\n  -- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\n  BEGIN;\n  UPDATE goods SET num=200 WHERE id>1 AND id<4; \n  ```\n\n  事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录\n\n  ```mysql\n  -- 事务B id=2 无法操作，区间锁\n  BEGIN;\n  update goods set num =1 where id=2;\n  commit;\n  -- 事务B id =4 正常操作\n  BEGIN;\n  update goods set num =1 where id=4;\n  commit;\n  ```\n\n#### 表锁\n\nMySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。\n\n##### 读锁\n\n为表设置读锁后，当前会话和其他会话都不可以修改数据。\n\n会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表\n\n```mysql\nLOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num=300 WHERE id=1;\nSELECT * FROM stu;\n```\n\n因为会话A对表`goods`设置了读锁，所以会话B也不能修改\n\n```mysql\nupdate goods set num=200 where id=1;-- 阻塞住\n```\n\n会话A解锁表后，其他会话又可以继续操作表了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 写锁\n\n为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。\n\n会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表\n\n```mysql\nLOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES('后盾人教程',300);\n```\n\n会话B读取/写入/写入表数据都将阻塞\n\n```mysql\nselect * from goods;-- 阻塞\n```\n\n会话A解锁表数据后，其他会话都可以正常操作了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 悲观锁\n\n悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。\n\n事务A执行悲观锁操作后，其他事务执行将被阻塞\n\n```mysql\n-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\nUPDATE goods SET num=num-2 WHERE id=1; \n```\n\n事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务\n\n```mysql\n-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\ncommit；\n```\n\n##### 乐观锁\n\n在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。\n\n事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务B同时查询，也获取了版本号为0的记录\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务A更改库存，并增加版本号\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n[超详细的锁介绍](https://blog.csdn.net/Jack__Frost/article/details/73347688)\n\n在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。\n\n1. 优化sql语句\n2. 降低MySQL数据的事务隔离级别\n\n\n\n参考链接：https://www.cnblogs.com/qq1148932219/p/11694064.html","slug":"MySQL系列三","published":1,"updated":"2020-03-24T08:10:18.130Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s060007mdym174a6s7g","content":"<p>本篇来讲讲MySQL的事务以及锁</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。</p>\n<p>至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。</p>\n<pre><code class=\"hljs mysql\">show engins;</code></pre>\n\n<h4 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h4><p>事务具有以下的特性</p>\n<ul>\n<li><p>原子性</p>\n<p>事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。</p>\n</li>\n<li><p>一致性</p>\n<p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>\n</li>\n<li><p>隔离性</p>\n<p>一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。</p>\n</li>\n<li><p>持久性</p>\n<p>一旦事务提交，其所做的修改便会永久保存在数据库中。</p>\n</li>\n</ul>\n<p>Mysql的提交默认是自动提交，即发送一条sql执行一条。</p>\n<h4 id=\"事务的提交\"><a href=\"#事务的提交\" class=\"headerlink\" title=\"事务的提交\"></a>事务的提交</h4><p>执行 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句后，表示要开启一项事务处理。</p>\n<ul>\n<li>COMMIT 提交事务</li>\n<li>ROLLBACK 回滚事务</li>\n</ul>\n<pre><code class=\"hljs mysql\">START TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,&#39;张帝&#39;,&#39;女&#39;);\nCOMMIT; -- rollback 回滚事务</code></pre>\n\n<h4 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h4><p>在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？</p>\n<p>当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：</p>\n<ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<blockquote>\n<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n</blockquote>\n<p>MySQL拥有不同的事务隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读未提交（read-uncommitted）</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td>\n</tr>\n</tbody></table>\n<h4 id=\"查询-设置MySQL的事务隔离级别\"><a href=\"#查询-设置MySQL的事务隔离级别\" class=\"headerlink\" title=\"查询/设置MySQL的事务隔离级别\"></a>查询/设置MySQL的事务隔离级别</h4><p>InoDB默认的事务隔离级别是repeatable-read</p>\n<pre><code class=\"hljs mysql\">-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre>\n\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h3><p>因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种</p>\n<ul>\n<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p>\n</li>\n<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n</li>\n<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n</li>\n</ul>\n<p><code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能。</p>\n<ul>\n<li>行锁开销大，锁表慢</li>\n<li>行锁高并发下可并行处理，性能更高</li>\n<li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li>\n<li>在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放</li>\n</ul>\n<h4 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h4><ul>\n<li><p>使用<strong>索引字段</strong>为筛选条件，来复现行锁。</p>\n<p>事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。</p>\n<pre><code class=\"hljs mysql\">-- 事务A\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE id&#x3D;1;</code></pre>\n\n<p>事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;1;\ncommit\n-- 事务B id&#x3D;2 操作成功\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;2;\ncommit</code></pre>\n\n<p>当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行</p>\n<pre><code class=\"hljs mysql\">-- 事务A\ncommit</code></pre>\n</li>\n<li><p>使用<strong>非索引字段</strong>为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。</p>\n<p>事务A执行以下代码，因为<code>sname</code>字段没有添加索引，造成锁定整个表</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，同时sname 字段没有添加索引\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE sname &#x3D;&#39;haha1&#39;;</code></pre>\n\n<p>现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞，因为stu 表锁\nBEGIN;\nupdate stu set sname &#x3D; &#39;小明&#39; where id&#x3D;1\ncommit</code></pre>\n</li>\n<li><p>简单查看MySQL行锁的争用情况</p>\n<p>过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>\n<pre><code class=\"hljs mysql\">show status like &#39;innodb_row_lock%&#39;;</code></pre>\n\n<p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>\n</li>\n</ul>\n<h4 id=\"区间锁（页面锁）\"><a href=\"#区间锁（页面锁）\" class=\"headerlink\" title=\"区间锁（页面锁）\"></a>区间锁（页面锁）</h4><ul>\n<li><p>使用索引字段作为筛选条件</p>\n<p>事务A筛选时使用了范围区间</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\nBEGIN;\nUPDATE goods SET num&#x3D;200 WHERE id&gt;1 AND id&lt;4;</code></pre>\n\n<p>事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录</p>\n<pre><code class=\"hljs mysql\">-- 事务B id&#x3D;2 无法操作，区间锁\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;2;\ncommit;\n-- 事务B id &#x3D;4 正常操作\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;4;\ncommit;</code></pre>\n\n</li>\n</ul>\n<h4 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h4><p>MySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。</p>\n<h5 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h5><p>为表设置读锁后，当前会话和其他会话都不可以修改数据。</p>\n<p>会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num&#x3D;300 WHERE id&#x3D;1;\nSELECT * FROM stu;</code></pre>\n\n<p>因为会话A对表<code>goods</code>设置了读锁，所以会话B也不能修改</p>\n<pre><code class=\"hljs mysql\">update goods set num&#x3D;200 where id&#x3D;1;-- 阻塞住</code></pre>\n\n<p>会话A解锁表后，其他会话又可以继续操作表了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h5><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。</p>\n<p>会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES(&#39;后盾人教程&#39;,300);</code></pre>\n\n<p>会话B读取/写入/写入表数据都将阻塞</p>\n<pre><code class=\"hljs mysql\">select * from goods;-- 阻塞</code></pre>\n\n<p>会话A解锁表数据后，其他会话都可以正常操作了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h5><p>悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。</p>\n<p>事务A执行悲观锁操作后，其他事务执行将被阻塞</p>\n<pre><code class=\"hljs mysql\">-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\nUPDATE goods SET num&#x3D;num-2 WHERE id&#x3D;1;</code></pre>\n\n<p>事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务</p>\n<pre><code class=\"hljs mysql\">-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\ncommit；</code></pre>\n\n<h5 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h5><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p>\n<p>事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务B同时查询，也获取了版本号为0的记录</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务A更改库存，并增加版本号</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p>事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/Jack__Frost/article/details/73347688\">超详细的锁介绍</a></p>\n<p>在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。</p>\n<ol>\n<li>优化sql语句</li>\n<li>降低MySQL数据的事务隔离级别</li>\n</ol>\n<p>参考链接：<a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇来讲讲MySQL的事务以及锁</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。</p>\n<p>至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。</p>\n<pre><code class=\"hljs mysql\">show engins;</code></pre>\n\n<h4 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h4><p>事务具有以下的特性</p>\n<ul>\n<li><p>原子性</p>\n<p>事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。</p>\n</li>\n<li><p>一致性</p>\n<p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>\n</li>\n<li><p>隔离性</p>\n<p>一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。</p>\n</li>\n<li><p>持久性</p>\n<p>一旦事务提交，其所做的修改便会永久保存在数据库中。</p>\n</li>\n</ul>\n<p>Mysql的提交默认是自动提交，即发送一条sql执行一条。</p>\n<h4 id=\"事务的提交\"><a href=\"#事务的提交\" class=\"headerlink\" title=\"事务的提交\"></a>事务的提交</h4><p>执行 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句后，表示要开启一项事务处理。</p>\n<ul>\n<li>COMMIT 提交事务</li>\n<li>ROLLBACK 回滚事务</li>\n</ul>\n<pre><code class=\"hljs mysql\">START TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,&#39;张帝&#39;,&#39;女&#39;);\nCOMMIT; -- rollback 回滚事务</code></pre>\n\n<h4 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h4><p>在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？</p>\n<p>当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：</p>\n<ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<blockquote>\n<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n</blockquote>\n<p>MySQL拥有不同的事务隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读未提交（read-uncommitted）</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td>\n</tr>\n</tbody></table>\n<h4 id=\"查询-设置MySQL的事务隔离级别\"><a href=\"#查询-设置MySQL的事务隔离级别\" class=\"headerlink\" title=\"查询/设置MySQL的事务隔离级别\"></a>查询/设置MySQL的事务隔离级别</h4><p>InoDB默认的事务隔离级别是repeatable-read</p>\n<pre><code class=\"hljs mysql\">-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre>\n\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h3><p>因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种</p>\n<ul>\n<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p>\n</li>\n<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n</li>\n<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n</li>\n</ul>\n<p><code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能。</p>\n<ul>\n<li>行锁开销大，锁表慢</li>\n<li>行锁高并发下可并行处理，性能更高</li>\n<li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li>\n<li>在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放</li>\n</ul>\n<h4 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h4><ul>\n<li><p>使用<strong>索引字段</strong>为筛选条件，来复现行锁。</p>\n<p>事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。</p>\n<pre><code class=\"hljs mysql\">-- 事务A\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE id&#x3D;1;</code></pre>\n\n<p>事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;1;\ncommit\n-- 事务B id&#x3D;2 操作成功\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;2;\ncommit</code></pre>\n\n<p>当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行</p>\n<pre><code class=\"hljs mysql\">-- 事务A\ncommit</code></pre>\n</li>\n<li><p>使用<strong>非索引字段</strong>为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。</p>\n<p>事务A执行以下代码，因为<code>sname</code>字段没有添加索引，造成锁定整个表</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，同时sname 字段没有添加索引\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE sname &#x3D;&#39;haha1&#39;;</code></pre>\n\n<p>现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞，因为stu 表锁\nBEGIN;\nupdate stu set sname &#x3D; &#39;小明&#39; where id&#x3D;1\ncommit</code></pre>\n</li>\n<li><p>简单查看MySQL行锁的争用情况</p>\n<p>过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>\n<pre><code class=\"hljs mysql\">show status like &#39;innodb_row_lock%&#39;;</code></pre>\n\n<p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>\n</li>\n</ul>\n<h4 id=\"区间锁（页面锁）\"><a href=\"#区间锁（页面锁）\" class=\"headerlink\" title=\"区间锁（页面锁）\"></a>区间锁（页面锁）</h4><ul>\n<li><p>使用索引字段作为筛选条件</p>\n<p>事务A筛选时使用了范围区间</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\nBEGIN;\nUPDATE goods SET num&#x3D;200 WHERE id&gt;1 AND id&lt;4;</code></pre>\n\n<p>事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录</p>\n<pre><code class=\"hljs mysql\">-- 事务B id&#x3D;2 无法操作，区间锁\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;2;\ncommit;\n-- 事务B id &#x3D;4 正常操作\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;4;\ncommit;</code></pre>\n\n</li>\n</ul>\n<h4 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h4><p>MySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。</p>\n<h5 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h5><p>为表设置读锁后，当前会话和其他会话都不可以修改数据。</p>\n<p>会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num&#x3D;300 WHERE id&#x3D;1;\nSELECT * FROM stu;</code></pre>\n\n<p>因为会话A对表<code>goods</code>设置了读锁，所以会话B也不能修改</p>\n<pre><code class=\"hljs mysql\">update goods set num&#x3D;200 where id&#x3D;1;-- 阻塞住</code></pre>\n\n<p>会话A解锁表后，其他会话又可以继续操作表了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h5><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。</p>\n<p>会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES(&#39;后盾人教程&#39;,300);</code></pre>\n\n<p>会话B读取/写入/写入表数据都将阻塞</p>\n<pre><code class=\"hljs mysql\">select * from goods;-- 阻塞</code></pre>\n\n<p>会话A解锁表数据后，其他会话都可以正常操作了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h5><p>悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。</p>\n<p>事务A执行悲观锁操作后，其他事务执行将被阻塞</p>\n<pre><code class=\"hljs mysql\">-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\nUPDATE goods SET num&#x3D;num-2 WHERE id&#x3D;1;</code></pre>\n\n<p>事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务</p>\n<pre><code class=\"hljs mysql\">-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\ncommit；</code></pre>\n\n<h5 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h5><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p>\n<p>事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务B同时查询，也获取了版本号为0的记录</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务A更改库存，并增加版本号</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p>事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/Jack__Frost/article/details/73347688\">超详细的锁介绍</a></p>\n<p>在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。</p>\n<ol>\n<li>优化sql语句</li>\n<li>降低MySQL数据的事务隔离级别</li>\n</ol>\n<p>参考链接：<a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n"},{"title":"MySQL系列五之原理及性能","date":"2018-08-25T13:17:22.000Z","index_img":["/images/mysql/logo-mysql.png"],"_content":"\n### 索引原理分析\n\nMySQL的索引是由**存储引擎**来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。\n\n聚簇索引和非聚簇索引：https://www.cnblogs.com/rjzheng/p/9915754.html\n\nB+tree\n\n#### 索引分类\n\n1. 主键索引：即主索引，根据主键pk_clolum（length）建立索引，**不允许重复，不允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；\n   ```\n\n2. 唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；\n   ```\n\n3. 普通索引：用表中的普通列构建的索引，没有任何限制\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col')；\n   ```\n\n4. 全文索引：用大文本对象的列构建的索引\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')；\n   ```\n\n5. 组合索引：用多个列组合构建的索引，这多个列中的值**不允许有空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；\n   ```\n\n   - 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引***\\*相当于建立了col1,col1col2,col1col2col3三个索引\\****，而col2或者col3是不能使用索引的。\n   - 在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引\n\n#### 索引的使用\n\n##### 什么时候使用索引\n\n- 主键自动建立唯一索引\n\n- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引\n\n- 作为排序的列要建立索引\n\n- 查询中与其他表关联的字段，外键关系建立索引\n\n- 高并发条件下倾向组合索引\n\n- 用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引\n\n  \n\n##### 什么时候不要使用索引\n\n- 经常增删改的列不要建立索引\n- 有大量重复的列不建立索引\n- 表记录太少不要建立索引\n\n##### 如何使用索引\n\n1. 查看表中的索引\n\n   ```mysql\n   SHOW INDEX FROM tablename\n   ```\n\n2. 查看查询语句使用索引的情况，查询语句加**explain**\n\n   ```mysql\n   explain SELECT * FROM table_name WHERE column_1='123';\n   ```\n\n3. 创建索引\n\n   ```mysql\n   -- 创建表时添加所有，index\n   CREATE TABLE mytable(  \n       ID INT NOT NULL,   \n       username VARCHAR(16) NOT NULL,  \n       INDEX [indexName] (username(length))  \n   );\n   -- 创建表之后添加索引\n   ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n   -- 或者\n   CREATE INDEX index_name ON my_table(column_name);\n   ```\n\n4. 删除索引\n\n   ```mysql\n   DROP INDEX my_index ON tablename;\n   ALTER TABLE table_name DROP INDEX index_name;\n   ```\n\n5. 根据索引查询，以下为使用的一部分\n\n   ```mysql\n   SELECT * FROM table_name WHERE column_1=column_2;-- (为column_1建立了索引)\n   SELECT * FROM table_name WHERE column_1 LIKE '三%'\n   SELECT * FROM table_name WHERE column_1 LIKE '_好_'\n   ```\n\n##### 索引失效原因\n\n- 在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。\n- 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。\n- LIKE操作中，'%aaa%'不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。\n- 在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)<2007\n- 在查询条件中使用不等于，包括<符号、>符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用<符号或者>符号不会使索引失效。（不等于，包括&lt;符号、>符号和！，如果占总记录的比例很小的话，也不会失效）\n- 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。\n- 字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。\n- 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来\n- 如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。\n- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引\n\n\n\n### 执行计划\n\n简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。\n\n基本语法是：SQL语句前面添加关键字 explain\n\n```sql\nexplain select * from stu where id >=2 order by name\n```\n\nmysql 执行计划主要包含以下信息\n\n| id   | select_type | table | partitions | type | possible_keys | key  | key_length | ref  | rows | extra |\n| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ---------- | ---- | ---- | ----- |\n|      |             |       |            |      |               |      |            |      |      |       |\n\n- **id** 表示各个子查询执行的顺序\n\n  - id 相同执行顺序由上至下\n  - id 不同，id 值越大越先被执行\n\n- **select_type** 查询数据的操作类型\n\n  | select_type  | 说明                                   |\n  | ------------ | -------------------------------------- |\n  | SIMPLE       | 不包含任何子查询或union等查询          |\n  | PRIMARY      | 包含子查询最外层查询就显示为 `PRIMARY` |\n  | SUBQUERY     | 在`select`或 `where`字句中包含的查询   |\n  | DERIVED      | `from`字句中包含的查询                 |\n  | UNION        | 出现在`union`后的查询语句中            |\n  | UNION RESULT | 从UNION中获取结果集                    |\n\n- **table** 输出的行所引用的表\n\n- **partitions** 如果查询是基于分区表的话，显示查询将访问的分区。\n\n- **type** 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。\n\n  | type            | 说明                                                       |\n  | --------------- | ---------------------------------------------------------- |\n  | system const    | 连接类型的特例，查询的表为系统表                           |\n  | const           | 使用主键或者唯一索引，且匹配的结果只有一条记录             |\n  | eq_ref          | 在`join`查询中使用`PRIMARY KEY`or`UNIQUE NOT NULL`索引关联 |\n  | ref             | 使用非唯一索引查找数据                                     |\n  | fulltext        | 使用全文索引                                               |\n  | ref_or_null     | 对`Null`进行索引的优化的 ref                               |\n  | unique_subquery | 在子查询中使用 eq_ref                                      |\n  | index_subquery  | 在子查询中使用 ref                                         |\n  | range           | 索引范围查找                                               |\n  | index           | 遍历索引                                                   |\n  | ALL             | 扫描全表数据                                               |\n\n- **possible_keys** 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。\n\n- **key** 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL\n\n- **key_length** 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度\n\n- **ref** 显示该表的索引字段关联了哪张表的哪个字段\n\n- **rows** 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\n\n- **extra** 包含不适合在其他列中显示但十分重要的额外信息\n\n  | extra           | 说明                                                         |\n  | --------------- | ------------------------------------------------------------ |\n  | Using filesort  | 表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。 |\n  | using temporary | 查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。 |\n  | using index     | 使用覆盖索引，避免了访问表的数据行。效率不错                 |\n  | Using where     | sql使用了where过滤,效率较高                                  |\n\n\n\n### 性能分析思路\n\n#### 问题定位\n\n1. 通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。\n\n   ```shell\n   # 显示状态信息,show status like ‘XXX’\n   show status;\n   #显示系统变量,show variables like ‘XXX’\n   show variables;\n   #显示InnoDB存储引擎的状态\n   show engine innodb status;\n   #查看当前SQL执行，包括执行状态、是否锁表等\n   show processlist;\n   ```\n\n   以下为退出MySQL登录之后执行\n\n   ```shell\n   # 显示状态信息\n   mysqladmin extended-status -u username -p password\n   #显示系统变量\n   mysqladmin variables -u root -p password\n   ```\n\n   常用的主要是show status和show processlist\n\n2. 慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下\n\n   ```sql\n   -- 检查是否开启\n   show variables like '%slow%';\n   -- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数\n   set global slow_query_log=ON;\n   -- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒\n   set long_query_time = 0.1;\n   ```\n\n   日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。\n\n3. explain分析查询。具体使用参考**执行计划**部分内容。\n\n4. profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。\n\n   ```sql\n   -- 查看是否开启profiling\n   select @@profiling;\n   -- 开profiling。注意测试完关闭该特性，否则耗费资源\n   set profiling=1;\n   -- 查看所有记录profile的SQL\n   show profiles;\n   -- 查看指定ID的SQL的详情\n   show profile for query 1;\n   -- 测试完，关闭该特性\n   set profiling=0;\n   ```\n\n#### 解决问题\n\n当MySQL发现性能问题。以下是一些优化思路。\n\n1. 优化SQL语句。以下是一些SQL使用建议\n   - 当结果集只有一行数据时使用LIMIT 1\n   - 多用like、不用null和where\n   - 在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销\n   - 避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。\n   - 使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。\n   - 用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度\n   - 尽可能的使用NOT NULL\n   - 拆分大的DELETE 或INSERT 语句\n   - 查询的列越小越快\n2. 建立索引。索引建立参考上面部分。索引使用建议\n   - 索引字段上不用mysql函数\n   - 在= 、group by 和 order by字段上面加上索引\n   - 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n   - 在使用in的时候可以尝试使用exists试试\n   - 在join的时候减少extra字段中临时表的数量\n   - 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。\n   - 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。\n\n\n\n参考：https://blog.csdn.net/tongdanping/article/details/79878302\n\n​\t\t\thttps://juejin.im/post/5a52386d51882573443c852a\n​\t\t\thttps://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie","source":"_posts/MySQL系列五.md","raw":"---\ntitle: MySQL系列五之原理及性能\ndate: 2018-08-25 21:17:22\nindex_img:\n- /images/mysql/logo-mysql.png\ntags: \n- mysql\ncategories:\n- DB\n---\n\n### 索引原理分析\n\nMySQL的索引是由**存储引擎**来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。\n\n聚簇索引和非聚簇索引：https://www.cnblogs.com/rjzheng/p/9915754.html\n\nB+tree\n\n#### 索引分类\n\n1. 主键索引：即主索引，根据主键pk_clolum（length）建立索引，**不允许重复，不允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；\n   ```\n\n2. 唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；\n   ```\n\n3. 普通索引：用表中的普通列构建的索引，没有任何限制\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col')；\n   ```\n\n4. 全文索引：用大文本对象的列构建的索引\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')；\n   ```\n\n5. 组合索引：用多个列组合构建的索引，这多个列中的值**不允许有空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；\n   ```\n\n   - 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引***\\*相当于建立了col1,col1col2,col1col2col3三个索引\\****，而col2或者col3是不能使用索引的。\n   - 在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引\n\n#### 索引的使用\n\n##### 什么时候使用索引\n\n- 主键自动建立唯一索引\n\n- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引\n\n- 作为排序的列要建立索引\n\n- 查询中与其他表关联的字段，外键关系建立索引\n\n- 高并发条件下倾向组合索引\n\n- 用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引\n\n  \n\n##### 什么时候不要使用索引\n\n- 经常增删改的列不要建立索引\n- 有大量重复的列不建立索引\n- 表记录太少不要建立索引\n\n##### 如何使用索引\n\n1. 查看表中的索引\n\n   ```mysql\n   SHOW INDEX FROM tablename\n   ```\n\n2. 查看查询语句使用索引的情况，查询语句加**explain**\n\n   ```mysql\n   explain SELECT * FROM table_name WHERE column_1='123';\n   ```\n\n3. 创建索引\n\n   ```mysql\n   -- 创建表时添加所有，index\n   CREATE TABLE mytable(  \n       ID INT NOT NULL,   \n       username VARCHAR(16) NOT NULL,  \n       INDEX [indexName] (username(length))  \n   );\n   -- 创建表之后添加索引\n   ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n   -- 或者\n   CREATE INDEX index_name ON my_table(column_name);\n   ```\n\n4. 删除索引\n\n   ```mysql\n   DROP INDEX my_index ON tablename;\n   ALTER TABLE table_name DROP INDEX index_name;\n   ```\n\n5. 根据索引查询，以下为使用的一部分\n\n   ```mysql\n   SELECT * FROM table_name WHERE column_1=column_2;-- (为column_1建立了索引)\n   SELECT * FROM table_name WHERE column_1 LIKE '三%'\n   SELECT * FROM table_name WHERE column_1 LIKE '_好_'\n   ```\n\n##### 索引失效原因\n\n- 在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。\n- 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。\n- LIKE操作中，'%aaa%'不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。\n- 在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)<2007\n- 在查询条件中使用不等于，包括<符号、>符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用<符号或者>符号不会使索引失效。（不等于，包括&lt;符号、>符号和！，如果占总记录的比例很小的话，也不会失效）\n- 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。\n- 字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。\n- 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来\n- 如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。\n- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引\n\n\n\n### 执行计划\n\n简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。\n\n基本语法是：SQL语句前面添加关键字 explain\n\n```sql\nexplain select * from stu where id >=2 order by name\n```\n\nmysql 执行计划主要包含以下信息\n\n| id   | select_type | table | partitions | type | possible_keys | key  | key_length | ref  | rows | extra |\n| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ---------- | ---- | ---- | ----- |\n|      |             |       |            |      |               |      |            |      |      |       |\n\n- **id** 表示各个子查询执行的顺序\n\n  - id 相同执行顺序由上至下\n  - id 不同，id 值越大越先被执行\n\n- **select_type** 查询数据的操作类型\n\n  | select_type  | 说明                                   |\n  | ------------ | -------------------------------------- |\n  | SIMPLE       | 不包含任何子查询或union等查询          |\n  | PRIMARY      | 包含子查询最外层查询就显示为 `PRIMARY` |\n  | SUBQUERY     | 在`select`或 `where`字句中包含的查询   |\n  | DERIVED      | `from`字句中包含的查询                 |\n  | UNION        | 出现在`union`后的查询语句中            |\n  | UNION RESULT | 从UNION中获取结果集                    |\n\n- **table** 输出的行所引用的表\n\n- **partitions** 如果查询是基于分区表的话，显示查询将访问的分区。\n\n- **type** 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。\n\n  | type            | 说明                                                       |\n  | --------------- | ---------------------------------------------------------- |\n  | system const    | 连接类型的特例，查询的表为系统表                           |\n  | const           | 使用主键或者唯一索引，且匹配的结果只有一条记录             |\n  | eq_ref          | 在`join`查询中使用`PRIMARY KEY`or`UNIQUE NOT NULL`索引关联 |\n  | ref             | 使用非唯一索引查找数据                                     |\n  | fulltext        | 使用全文索引                                               |\n  | ref_or_null     | 对`Null`进行索引的优化的 ref                               |\n  | unique_subquery | 在子查询中使用 eq_ref                                      |\n  | index_subquery  | 在子查询中使用 ref                                         |\n  | range           | 索引范围查找                                               |\n  | index           | 遍历索引                                                   |\n  | ALL             | 扫描全表数据                                               |\n\n- **possible_keys** 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。\n\n- **key** 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL\n\n- **key_length** 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度\n\n- **ref** 显示该表的索引字段关联了哪张表的哪个字段\n\n- **rows** 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\n\n- **extra** 包含不适合在其他列中显示但十分重要的额外信息\n\n  | extra           | 说明                                                         |\n  | --------------- | ------------------------------------------------------------ |\n  | Using filesort  | 表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。 |\n  | using temporary | 查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。 |\n  | using index     | 使用覆盖索引，避免了访问表的数据行。效率不错                 |\n  | Using where     | sql使用了where过滤,效率较高                                  |\n\n\n\n### 性能分析思路\n\n#### 问题定位\n\n1. 通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。\n\n   ```shell\n   # 显示状态信息,show status like ‘XXX’\n   show status;\n   #显示系统变量,show variables like ‘XXX’\n   show variables;\n   #显示InnoDB存储引擎的状态\n   show engine innodb status;\n   #查看当前SQL执行，包括执行状态、是否锁表等\n   show processlist;\n   ```\n\n   以下为退出MySQL登录之后执行\n\n   ```shell\n   # 显示状态信息\n   mysqladmin extended-status -u username -p password\n   #显示系统变量\n   mysqladmin variables -u root -p password\n   ```\n\n   常用的主要是show status和show processlist\n\n2. 慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下\n\n   ```sql\n   -- 检查是否开启\n   show variables like '%slow%';\n   -- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数\n   set global slow_query_log=ON;\n   -- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒\n   set long_query_time = 0.1;\n   ```\n\n   日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。\n\n3. explain分析查询。具体使用参考**执行计划**部分内容。\n\n4. profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。\n\n   ```sql\n   -- 查看是否开启profiling\n   select @@profiling;\n   -- 开profiling。注意测试完关闭该特性，否则耗费资源\n   set profiling=1;\n   -- 查看所有记录profile的SQL\n   show profiles;\n   -- 查看指定ID的SQL的详情\n   show profile for query 1;\n   -- 测试完，关闭该特性\n   set profiling=0;\n   ```\n\n#### 解决问题\n\n当MySQL发现性能问题。以下是一些优化思路。\n\n1. 优化SQL语句。以下是一些SQL使用建议\n   - 当结果集只有一行数据时使用LIMIT 1\n   - 多用like、不用null和where\n   - 在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销\n   - 避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。\n   - 使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。\n   - 用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度\n   - 尽可能的使用NOT NULL\n   - 拆分大的DELETE 或INSERT 语句\n   - 查询的列越小越快\n2. 建立索引。索引建立参考上面部分。索引使用建议\n   - 索引字段上不用mysql函数\n   - 在= 、group by 和 order by字段上面加上索引\n   - 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n   - 在使用in的时候可以尝试使用exists试试\n   - 在join的时候减少extra字段中临时表的数量\n   - 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。\n   - 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。\n\n\n\n参考：https://blog.csdn.net/tongdanping/article/details/79878302\n\n​\t\t\thttps://juejin.im/post/5a52386d51882573443c852a\n​\t\t\thttps://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie","slug":"MySQL系列五","published":1,"updated":"2020-03-24T08:10:26.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s07000bmdym9yrbdgdb","content":"<h3 id=\"索引原理分析\"><a href=\"#索引原理分析\" class=\"headerlink\" title=\"索引原理分析\"></a>索引原理分析</h3><p>MySQL的索引是由<strong>存储引擎</strong>来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。</p>\n<p>聚簇索引和非聚簇索引：<a href=\"https://www.cnblogs.com/rjzheng/p/9915754.html\">https://www.cnblogs.com/rjzheng/p/9915754.html</a></p>\n<p>B+tree</p>\n<h4 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h4><ol>\n<li><p>主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>普通索引：用表中的普通列构建的索引，没有任何限制</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>全文索引：用大文本对象的列构建的索引</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>组合索引：用多个列组合构建的索引，这多个列中的值<strong>不允许有空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</code></pre>\n\n<ul>\n<li>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引*<strong>*相当于建立了col1,col1col2,col1col2col3三个索引**</strong>，而col2或者col3是不能使用索引的。</li>\n<li>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h4><h5 id=\"什么时候使用索引\"><a href=\"#什么时候使用索引\" class=\"headerlink\" title=\"什么时候使用索引\"></a>什么时候使用索引</h5><ul>\n<li><p>主键自动建立唯一索引</p>\n</li>\n<li><p>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引</p>\n</li>\n<li><p>作为排序的列要建立索引</p>\n</li>\n<li><p>查询中与其他表关联的字段，外键关系建立索引</p>\n</li>\n<li><p>高并发条件下倾向组合索引</p>\n</li>\n<li><p>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</p>\n</li>\n</ul>\n<h5 id=\"什么时候不要使用索引\"><a href=\"#什么时候不要使用索引\" class=\"headerlink\" title=\"什么时候不要使用索引\"></a>什么时候不要使用索引</h5><ul>\n<li>经常增删改的列不要建立索引</li>\n<li>有大量重复的列不建立索引</li>\n<li>表记录太少不要建立索引</li>\n</ul>\n<h5 id=\"如何使用索引\"><a href=\"#如何使用索引\" class=\"headerlink\" title=\"如何使用索引\"></a>如何使用索引</h5><ol>\n<li><p>查看表中的索引</p>\n<pre><code class=\"hljs mysql\">SHOW INDEX FROM tablename</code></pre>\n</li>\n<li><p>查看查询语句使用索引的情况，查询语句加<strong>explain</strong></p>\n<pre><code class=\"hljs mysql\">explain SELECT * FROM table_name WHERE column_1&#x3D;&#39;123&#39;;</code></pre>\n</li>\n<li><p>创建索引</p>\n<pre><code class=\"hljs mysql\">-- 创建表时添加所有，index\nCREATE TABLE mytable(  \n    ID INT NOT NULL,   \n    username VARCHAR(16) NOT NULL,  \n    INDEX [indexName] (username(length))  \n);\n-- 创建表之后添加索引\nALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n-- 或者\nCREATE INDEX index_name ON my_table(column_name);</code></pre>\n</li>\n<li><p>删除索引</p>\n<pre><code class=\"hljs mysql\">DROP INDEX my_index ON tablename;\nALTER TABLE table_name DROP INDEX index_name;</code></pre>\n</li>\n<li><p>根据索引查询，以下为使用的一部分</p>\n<pre><code class=\"hljs mysql\">SELECT * FROM table_name WHERE column_1&#x3D;column_2;-- (为column_1建立了索引)\nSELECT * FROM table_name WHERE column_1 LIKE &#39;三%&#39;\nSELECT * FROM table_name WHERE column_1 LIKE &#39;_好_&#39;</code></pre>\n\n</li>\n</ol>\n<h5 id=\"索引失效原因\"><a href=\"#索引失效原因\" class=\"headerlink\" title=\"索引失效原因\"></a>索引失效原因</h5><ul>\n<li>在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</li>\n<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</li>\n<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。</li>\n<li>在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)&lt;2007</li>\n<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效）</li>\n<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。</li>\n<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。</li>\n<li>在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来</li>\n<li>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</li>\n<li>尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引</li>\n</ul>\n<h3 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h3><p>简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。</p>\n<p>基本语法是：SQL语句前面添加关键字 explain</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">explain</span> <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> stu <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span> &gt;=<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">name</span></code></pre>\n\n<p>mysql 执行计划主要包含以下信息</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>partitions</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_length</th>\n<th>ref</th>\n<th>rows</th>\n<th>extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><strong>id</strong> 表示各个子查询执行的顺序</p>\n<ul>\n<li>id 相同执行顺序由上至下</li>\n<li>id 不同，id 值越大越先被执行</li>\n</ul>\n</li>\n<li><p><strong>select_type</strong> 查询数据的操作类型</p>\n<table>\n<thead>\n<tr>\n<th>select_type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>不包含任何子查询或union等查询</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>包含子查询最外层查询就显示为 <code>PRIMARY</code></td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>在<code>select</code>或 <code>where</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td><code>from</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>出现在<code>union</code>后的查询语句中</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>从UNION中获取结果集</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>table</strong> 输出的行所引用的表</p>\n</li>\n<li><p><strong>partitions</strong> 如果查询是基于分区表的话，显示查询将访问的分区。</p>\n</li>\n<li><p><strong>type</strong> 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。</p>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>system const</td>\n<td>连接类型的特例，查询的表为系统表</td>\n</tr>\n<tr>\n<td>const</td>\n<td>使用主键或者唯一索引，且匹配的结果只有一条记录</td>\n</tr>\n<tr>\n<td>eq_ref</td>\n<td>在<code>join</code>查询中使用<code>PRIMARY KEY</code>or<code>UNIQUE NOT NULL</code>索引关联</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>使用非唯一索引查找数据</td>\n</tr>\n<tr>\n<td>fulltext</td>\n<td>使用全文索引</td>\n</tr>\n<tr>\n<td>ref_or_null</td>\n<td>对<code>Null</code>进行索引的优化的 ref</td>\n</tr>\n<tr>\n<td>unique_subquery</td>\n<td>在子查询中使用 eq_ref</td>\n</tr>\n<tr>\n<td>index_subquery</td>\n<td>在子查询中使用 ref</td>\n</tr>\n<tr>\n<td>range</td>\n<td>索引范围查找</td>\n</tr>\n<tr>\n<td>index</td>\n<td>遍历索引</td>\n</tr>\n<tr>\n<td>ALL</td>\n<td>扫描全表数据</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>possible_keys</strong> 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。</p>\n</li>\n<li><p><strong>key</strong> 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL</p>\n</li>\n<li><p><strong>key_length</strong> 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度</p>\n</li>\n<li><p><strong>ref</strong> 显示该表的索引字段关联了哪张表的哪个字段</p>\n</li>\n<li><p><strong>rows</strong> 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n</li>\n<li><p><strong>extra</strong> 包含不适合在其他列中显示但十分重要的额外信息</p>\n<table>\n<thead>\n<tr>\n<th>extra</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Using filesort</td>\n<td>表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。</td>\n</tr>\n<tr>\n<td>using temporary</td>\n<td>查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。</td>\n</tr>\n<tr>\n<td>using index</td>\n<td>使用覆盖索引，避免了访问表的数据行。效率不错</td>\n</tr>\n<tr>\n<td>Using where</td>\n<td>sql使用了where过滤,效率较高</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"性能分析思路\"><a href=\"#性能分析思路\" class=\"headerlink\" title=\"性能分析思路\"></a>性能分析思路</h3><h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><ol>\n<li><p>通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息,show status like ‘XXX’</span>\nshow status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量,show variables like ‘XXX’</span>\nshow variables;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示InnoDB存储引擎的状态</span>\nshow engine innodb status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">查看当前SQL执行，包括执行状态、是否锁表等</span>\nshow processlist;</code></pre>\n\n<p>以下为退出MySQL登录之后执行</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息</span>\nmysqladmin extended-status -u username -p password\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量</span>\nmysqladmin variables -u root -p password</code></pre>\n\n<p>常用的主要是show status和show processlist</p>\n</li>\n<li><p>慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 检查是否开启</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">variables</span> <span class=\"hljs-keyword\">like</span> <span class=\"hljs-string\">&#x27;%slow%&#x27;</span>;\n<span class=\"hljs-comment\">-- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">global</span> slow_query_log=<span class=\"hljs-keyword\">ON</span>;\n<span class=\"hljs-comment\">-- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒</span>\n<span class=\"hljs-keyword\">set</span> long_query_time = <span class=\"hljs-number\">0.1</span>;</code></pre>\n\n<p>日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。</p>\n</li>\n<li><p>explain分析查询。具体使用参考<strong>执行计划</strong>部分内容。</p>\n</li>\n<li><p>profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 查看是否开启profiling</span>\n<span class=\"hljs-keyword\">select</span> @@profiling;\n<span class=\"hljs-comment\">-- 开profiling。注意测试完关闭该特性，否则耗费资源</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 查看所有记录profile的SQL</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">profiles</span>;\n<span class=\"hljs-comment\">-- 查看指定ID的SQL的详情</span>\n<span class=\"hljs-keyword\">show</span> profile <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">query</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 测试完，关闭该特性</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">0</span>;</code></pre>\n\n</li>\n</ol>\n<h4 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h4><p>当MySQL发现性能问题。以下是一些优化思路。</p>\n<ol>\n<li>优化SQL语句。以下是一些SQL使用建议<ul>\n<li>当结果集只有一行数据时使用LIMIT 1</li>\n<li>多用like、不用null和where</li>\n<li>在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销</li>\n<li>避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。</li>\n<li>使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li>\n<li>用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度</li>\n<li>尽可能的使用NOT NULL</li>\n<li>拆分大的DELETE 或INSERT 语句</li>\n<li>查询的列越小越快</li>\n</ul>\n</li>\n<li>建立索引。索引建立参考上面部分。索引使用建议<ul>\n<li>索引字段上不用mysql函数</li>\n<li>在= 、group by 和 order by字段上面加上索引</li>\n<li>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>\n<li>在使用in的时候可以尝试使用exists试试</li>\n<li>在join的时候减少extra字段中临时表的数量</li>\n<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>\n<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>\n</ul>\n</li>\n</ol>\n<p>参考：<a href=\"https://blog.csdn.net/tongdanping/article/details/79878302\">https://blog.csdn.net/tongdanping/article/details/79878302</a></p>\n<p>​            <a href=\"https://juejin.im/post/5a52386d51882573443c852a\">https://juejin.im/post/5a52386d51882573443c852a</a><br>​            <a href=\"https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie\">https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"索引原理分析\"><a href=\"#索引原理分析\" class=\"headerlink\" title=\"索引原理分析\"></a>索引原理分析</h3><p>MySQL的索引是由<strong>存储引擎</strong>来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。</p>\n<p>聚簇索引和非聚簇索引：<a href=\"https://www.cnblogs.com/rjzheng/p/9915754.html\">https://www.cnblogs.com/rjzheng/p/9915754.html</a></p>\n<p>B+tree</p>\n<h4 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h4><ol>\n<li><p>主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>普通索引：用表中的普通列构建的索引，没有任何限制</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>全文索引：用大文本对象的列构建的索引</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>组合索引：用多个列组合构建的索引，这多个列中的值<strong>不允许有空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</code></pre>\n\n<ul>\n<li>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引*<strong>*相当于建立了col1,col1col2,col1col2col3三个索引**</strong>，而col2或者col3是不能使用索引的。</li>\n<li>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h4><h5 id=\"什么时候使用索引\"><a href=\"#什么时候使用索引\" class=\"headerlink\" title=\"什么时候使用索引\"></a>什么时候使用索引</h5><ul>\n<li><p>主键自动建立唯一索引</p>\n</li>\n<li><p>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引</p>\n</li>\n<li><p>作为排序的列要建立索引</p>\n</li>\n<li><p>查询中与其他表关联的字段，外键关系建立索引</p>\n</li>\n<li><p>高并发条件下倾向组合索引</p>\n</li>\n<li><p>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</p>\n</li>\n</ul>\n<h5 id=\"什么时候不要使用索引\"><a href=\"#什么时候不要使用索引\" class=\"headerlink\" title=\"什么时候不要使用索引\"></a>什么时候不要使用索引</h5><ul>\n<li>经常增删改的列不要建立索引</li>\n<li>有大量重复的列不建立索引</li>\n<li>表记录太少不要建立索引</li>\n</ul>\n<h5 id=\"如何使用索引\"><a href=\"#如何使用索引\" class=\"headerlink\" title=\"如何使用索引\"></a>如何使用索引</h5><ol>\n<li><p>查看表中的索引</p>\n<pre><code class=\"hljs mysql\">SHOW INDEX FROM tablename</code></pre>\n</li>\n<li><p>查看查询语句使用索引的情况，查询语句加<strong>explain</strong></p>\n<pre><code class=\"hljs mysql\">explain SELECT * FROM table_name WHERE column_1&#x3D;&#39;123&#39;;</code></pre>\n</li>\n<li><p>创建索引</p>\n<pre><code class=\"hljs mysql\">-- 创建表时添加所有，index\nCREATE TABLE mytable(  \n    ID INT NOT NULL,   \n    username VARCHAR(16) NOT NULL,  \n    INDEX [indexName] (username(length))  \n);\n-- 创建表之后添加索引\nALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n-- 或者\nCREATE INDEX index_name ON my_table(column_name);</code></pre>\n</li>\n<li><p>删除索引</p>\n<pre><code class=\"hljs mysql\">DROP INDEX my_index ON tablename;\nALTER TABLE table_name DROP INDEX index_name;</code></pre>\n</li>\n<li><p>根据索引查询，以下为使用的一部分</p>\n<pre><code class=\"hljs mysql\">SELECT * FROM table_name WHERE column_1&#x3D;column_2;-- (为column_1建立了索引)\nSELECT * FROM table_name WHERE column_1 LIKE &#39;三%&#39;\nSELECT * FROM table_name WHERE column_1 LIKE &#39;_好_&#39;</code></pre>\n\n</li>\n</ol>\n<h5 id=\"索引失效原因\"><a href=\"#索引失效原因\" class=\"headerlink\" title=\"索引失效原因\"></a>索引失效原因</h5><ul>\n<li>在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</li>\n<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</li>\n<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。</li>\n<li>在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)&lt;2007</li>\n<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效）</li>\n<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。</li>\n<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。</li>\n<li>在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来</li>\n<li>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</li>\n<li>尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引</li>\n</ul>\n<h3 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h3><p>简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。</p>\n<p>基本语法是：SQL语句前面添加关键字 explain</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">explain</span> <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> stu <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span> &gt;=<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">name</span></code></pre>\n\n<p>mysql 执行计划主要包含以下信息</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>partitions</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_length</th>\n<th>ref</th>\n<th>rows</th>\n<th>extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><strong>id</strong> 表示各个子查询执行的顺序</p>\n<ul>\n<li>id 相同执行顺序由上至下</li>\n<li>id 不同，id 值越大越先被执行</li>\n</ul>\n</li>\n<li><p><strong>select_type</strong> 查询数据的操作类型</p>\n<table>\n<thead>\n<tr>\n<th>select_type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>不包含任何子查询或union等查询</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>包含子查询最外层查询就显示为 <code>PRIMARY</code></td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>在<code>select</code>或 <code>where</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td><code>from</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>出现在<code>union</code>后的查询语句中</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>从UNION中获取结果集</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>table</strong> 输出的行所引用的表</p>\n</li>\n<li><p><strong>partitions</strong> 如果查询是基于分区表的话，显示查询将访问的分区。</p>\n</li>\n<li><p><strong>type</strong> 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。</p>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>system const</td>\n<td>连接类型的特例，查询的表为系统表</td>\n</tr>\n<tr>\n<td>const</td>\n<td>使用主键或者唯一索引，且匹配的结果只有一条记录</td>\n</tr>\n<tr>\n<td>eq_ref</td>\n<td>在<code>join</code>查询中使用<code>PRIMARY KEY</code>or<code>UNIQUE NOT NULL</code>索引关联</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>使用非唯一索引查找数据</td>\n</tr>\n<tr>\n<td>fulltext</td>\n<td>使用全文索引</td>\n</tr>\n<tr>\n<td>ref_or_null</td>\n<td>对<code>Null</code>进行索引的优化的 ref</td>\n</tr>\n<tr>\n<td>unique_subquery</td>\n<td>在子查询中使用 eq_ref</td>\n</tr>\n<tr>\n<td>index_subquery</td>\n<td>在子查询中使用 ref</td>\n</tr>\n<tr>\n<td>range</td>\n<td>索引范围查找</td>\n</tr>\n<tr>\n<td>index</td>\n<td>遍历索引</td>\n</tr>\n<tr>\n<td>ALL</td>\n<td>扫描全表数据</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>possible_keys</strong> 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。</p>\n</li>\n<li><p><strong>key</strong> 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL</p>\n</li>\n<li><p><strong>key_length</strong> 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度</p>\n</li>\n<li><p><strong>ref</strong> 显示该表的索引字段关联了哪张表的哪个字段</p>\n</li>\n<li><p><strong>rows</strong> 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n</li>\n<li><p><strong>extra</strong> 包含不适合在其他列中显示但十分重要的额外信息</p>\n<table>\n<thead>\n<tr>\n<th>extra</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Using filesort</td>\n<td>表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。</td>\n</tr>\n<tr>\n<td>using temporary</td>\n<td>查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。</td>\n</tr>\n<tr>\n<td>using index</td>\n<td>使用覆盖索引，避免了访问表的数据行。效率不错</td>\n</tr>\n<tr>\n<td>Using where</td>\n<td>sql使用了where过滤,效率较高</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"性能分析思路\"><a href=\"#性能分析思路\" class=\"headerlink\" title=\"性能分析思路\"></a>性能分析思路</h3><h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><ol>\n<li><p>通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息,show status like ‘XXX’</span>\nshow status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量,show variables like ‘XXX’</span>\nshow variables;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示InnoDB存储引擎的状态</span>\nshow engine innodb status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">查看当前SQL执行，包括执行状态、是否锁表等</span>\nshow processlist;</code></pre>\n\n<p>以下为退出MySQL登录之后执行</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息</span>\nmysqladmin extended-status -u username -p password\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量</span>\nmysqladmin variables -u root -p password</code></pre>\n\n<p>常用的主要是show status和show processlist</p>\n</li>\n<li><p>慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 检查是否开启</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">variables</span> <span class=\"hljs-keyword\">like</span> <span class=\"hljs-string\">&#x27;%slow%&#x27;</span>;\n<span class=\"hljs-comment\">-- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">global</span> slow_query_log=<span class=\"hljs-keyword\">ON</span>;\n<span class=\"hljs-comment\">-- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒</span>\n<span class=\"hljs-keyword\">set</span> long_query_time = <span class=\"hljs-number\">0.1</span>;</code></pre>\n\n<p>日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。</p>\n</li>\n<li><p>explain分析查询。具体使用参考<strong>执行计划</strong>部分内容。</p>\n</li>\n<li><p>profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 查看是否开启profiling</span>\n<span class=\"hljs-keyword\">select</span> @@profiling;\n<span class=\"hljs-comment\">-- 开profiling。注意测试完关闭该特性，否则耗费资源</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 查看所有记录profile的SQL</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">profiles</span>;\n<span class=\"hljs-comment\">-- 查看指定ID的SQL的详情</span>\n<span class=\"hljs-keyword\">show</span> profile <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">query</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 测试完，关闭该特性</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">0</span>;</code></pre>\n\n</li>\n</ol>\n<h4 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h4><p>当MySQL发现性能问题。以下是一些优化思路。</p>\n<ol>\n<li>优化SQL语句。以下是一些SQL使用建议<ul>\n<li>当结果集只有一行数据时使用LIMIT 1</li>\n<li>多用like、不用null和where</li>\n<li>在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销</li>\n<li>避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。</li>\n<li>使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li>\n<li>用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度</li>\n<li>尽可能的使用NOT NULL</li>\n<li>拆分大的DELETE 或INSERT 语句</li>\n<li>查询的列越小越快</li>\n</ul>\n</li>\n<li>建立索引。索引建立参考上面部分。索引使用建议<ul>\n<li>索引字段上不用mysql函数</li>\n<li>在= 、group by 和 order by字段上面加上索引</li>\n<li>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>\n<li>在使用in的时候可以尝试使用exists试试</li>\n<li>在join的时候减少extra字段中临时表的数量</li>\n<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>\n<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>\n</ul>\n</li>\n</ol>\n<p>参考：<a href=\"https://blog.csdn.net/tongdanping/article/details/79878302\">https://blog.csdn.net/tongdanping/article/details/79878302</a></p>\n<p>​            <a href=\"https://juejin.im/post/5a52386d51882573443c852a\">https://juejin.im/post/5a52386d51882573443c852a</a><br>​            <a href=\"https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie\">https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie</a></p>\n"},{"title":"RN 中使用mobx来进行状态管理","date":"2017-06-13T03:25:12.000Z","_content":"\n在使用RN开发app过程中需要状态管理，也就是state 这个概念，由此衍生出来的两个状态管理的框架，一个是redux，另一个就是mobx了。这两个我都用过，今天就先来介绍下mobx 在开发RN中的使用。实际上不使用状态管理的框架，你也是能够进行开发的，但是随着项目的开发以及项目的壮大，会发现没有状态管理，这个工程越来越难维护。当然redux和mobx也都是可以使用在react的web项目中。\n\nmobx核心的理念是**动作**改变**状态**，而状态的改变会更新所有受影响的**视图**，通俗来讲，一个应用可以拥有一个大的state，而每一个页面都和这个这个state相关连，通过改变这个state来更新页面。当然一个应用可以拥有多个state不一定是一个，这个开每个开发者对项目的规划。举个例子：用户的state,在用户未登录时，页面的显示时登录界面，当用户点击登录时，通过更新这个state，来更新这个view。更多的mobx概念请移步[mobx中文文档](http://cn.mobx.js.org/)\n\n接下来就是在实际开发中使用mobx了\n\n<!-- more -->\n\n- 在package.json 引入\n\n  ```js\n  \"dependencies\": {\n      \"mobx\": \"^2.6.1\",\n      \"mobx-react\": \"^3.5.8\",\n      //其他库\n  }\n  //不加这个装饰器使用不了，如@action   \n  \"devDependencies\": {\n    \"babel-plugin-transform-decorators-legacy\": \"^1.3.4\"\n  }\n  ```\n\n- .babelrc 中添加\n\n  ```js\n  {\n    \"presets\": [\"react-native\"],\n    \"plugins\": [\"transform-decorators-legacy\"] //在babel转义的时候能够将装饰器转义\n  }\n  ```\n\n\n### 创建一个简易的计数器\n\n- 创建一个一个store\n\n  ```js\n  import {observable, action, computed, toJS} from 'mobx'\n\n  class mobxStore {\n      @observable count = 0\n\n      @action addCount() {\n          this.count = this.count + 1;\n      }\n\n      @action reduceCount() {\n          this.count = this.count - 1;\n      }\n  }\n\n  const store = new mobxStore()\n  export default store\n  ```\n\n- 在界面中和store 关联\n\n  ```javascript\n  import React, {Component} from 'react';\n  import {\n      Text,\n      StyleSheet,\n      TouchableHighlight,\n      View\n  } from 'react-native';\n  import {observer} from 'mobx-react/custom'\n  import store from './mobxStore'\n\n  @observer\n  class Root extends Component {\n\n      render() {\n          return (\n              <View style={styles.container}>\n                  <Text style={styles.welcome}>\n                      Mobx 的简易使用demo\n                  </Text>\n                  <Text style={styles.instructions}>\n                      store中的计数器：{store.count}\n                  </Text>\n                  <TouchableHighlight style={{marginTop: 8}} onPress={() => store.addCount()}>\n                      <Text style={styles.instructions}>\n                          点击计数+1\n                      </Text>\n                  </TouchableHighlight>\n                  <TouchableHighlight style={{marginTop: 8}} onPress={() => store.reduceCount()}>\n                      <Text style={styles.instructions}>\n                          点击计数-1\n                      </Text>\n                  </TouchableHighlight>\n              </View>\n          );\n      }\n  }\n\n  const styles = StyleSheet.create({\n      container: {\n          flex: 1,\n          justifyContent: 'center',\n          alignItems: 'center',\n          backgroundColor: '#F5FCFF',\n      },\n      welcome: {\n          fontSize: 20,\n          textAlign: 'center',\n          margin: 10,\n      },\n      instructions: {\n          textAlign: 'center',\n          color: 'red',\n          marginBottom: 5,\n      },\n  });\n\n  export default Root\n  ```\n\n导入`import {observer} from 'mobx-react/custom'` 和刚才创建的store，`import store from './mobxStore'`\n\ndemo 的源码已经放到github上 [mobxDemo](https://github.com/Cocoon-break/mobxDemo)，如有疑问请在该仓库中提issue\n\n\n","source":"_posts/RN中使用mobx来进行状态管理.md","raw":"---\ntitle: RN 中使用mobx来进行状态管理\ndate: 2017-06-13 11:25:12\ntags: \n- react-native\ncategories:\n- 前端\n---\n\n在使用RN开发app过程中需要状态管理，也就是state 这个概念，由此衍生出来的两个状态管理的框架，一个是redux，另一个就是mobx了。这两个我都用过，今天就先来介绍下mobx 在开发RN中的使用。实际上不使用状态管理的框架，你也是能够进行开发的，但是随着项目的开发以及项目的壮大，会发现没有状态管理，这个工程越来越难维护。当然redux和mobx也都是可以使用在react的web项目中。\n\nmobx核心的理念是**动作**改变**状态**，而状态的改变会更新所有受影响的**视图**，通俗来讲，一个应用可以拥有一个大的state，而每一个页面都和这个这个state相关连，通过改变这个state来更新页面。当然一个应用可以拥有多个state不一定是一个，这个开每个开发者对项目的规划。举个例子：用户的state,在用户未登录时，页面的显示时登录界面，当用户点击登录时，通过更新这个state，来更新这个view。更多的mobx概念请移步[mobx中文文档](http://cn.mobx.js.org/)\n\n接下来就是在实际开发中使用mobx了\n\n<!-- more -->\n\n- 在package.json 引入\n\n  ```js\n  \"dependencies\": {\n      \"mobx\": \"^2.6.1\",\n      \"mobx-react\": \"^3.5.8\",\n      //其他库\n  }\n  //不加这个装饰器使用不了，如@action   \n  \"devDependencies\": {\n    \"babel-plugin-transform-decorators-legacy\": \"^1.3.4\"\n  }\n  ```\n\n- .babelrc 中添加\n\n  ```js\n  {\n    \"presets\": [\"react-native\"],\n    \"plugins\": [\"transform-decorators-legacy\"] //在babel转义的时候能够将装饰器转义\n  }\n  ```\n\n\n### 创建一个简易的计数器\n\n- 创建一个一个store\n\n  ```js\n  import {observable, action, computed, toJS} from 'mobx'\n\n  class mobxStore {\n      @observable count = 0\n\n      @action addCount() {\n          this.count = this.count + 1;\n      }\n\n      @action reduceCount() {\n          this.count = this.count - 1;\n      }\n  }\n\n  const store = new mobxStore()\n  export default store\n  ```\n\n- 在界面中和store 关联\n\n  ```javascript\n  import React, {Component} from 'react';\n  import {\n      Text,\n      StyleSheet,\n      TouchableHighlight,\n      View\n  } from 'react-native';\n  import {observer} from 'mobx-react/custom'\n  import store from './mobxStore'\n\n  @observer\n  class Root extends Component {\n\n      render() {\n          return (\n              <View style={styles.container}>\n                  <Text style={styles.welcome}>\n                      Mobx 的简易使用demo\n                  </Text>\n                  <Text style={styles.instructions}>\n                      store中的计数器：{store.count}\n                  </Text>\n                  <TouchableHighlight style={{marginTop: 8}} onPress={() => store.addCount()}>\n                      <Text style={styles.instructions}>\n                          点击计数+1\n                      </Text>\n                  </TouchableHighlight>\n                  <TouchableHighlight style={{marginTop: 8}} onPress={() => store.reduceCount()}>\n                      <Text style={styles.instructions}>\n                          点击计数-1\n                      </Text>\n                  </TouchableHighlight>\n              </View>\n          );\n      }\n  }\n\n  const styles = StyleSheet.create({\n      container: {\n          flex: 1,\n          justifyContent: 'center',\n          alignItems: 'center',\n          backgroundColor: '#F5FCFF',\n      },\n      welcome: {\n          fontSize: 20,\n          textAlign: 'center',\n          margin: 10,\n      },\n      instructions: {\n          textAlign: 'center',\n          color: 'red',\n          marginBottom: 5,\n      },\n  });\n\n  export default Root\n  ```\n\n导入`import {observer} from 'mobx-react/custom'` 和刚才创建的store，`import store from './mobxStore'`\n\ndemo 的源码已经放到github上 [mobxDemo](https://github.com/Cocoon-break/mobxDemo)，如有疑问请在该仓库中提issue\n\n\n","slug":"RN中使用mobx来进行状态管理","published":1,"updated":"2020-02-27T03:48:45.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s08000cmdym23lja312","content":"<p>在使用RN开发app过程中需要状态管理，也就是state 这个概念，由此衍生出来的两个状态管理的框架，一个是redux，另一个就是mobx了。这两个我都用过，今天就先来介绍下mobx 在开发RN中的使用。实际上不使用状态管理的框架，你也是能够进行开发的，但是随着项目的开发以及项目的壮大，会发现没有状态管理，这个工程越来越难维护。当然redux和mobx也都是可以使用在react的web项目中。</p>\n<p>mobx核心的理念是<strong>动作</strong>改变<strong>状态</strong>，而状态的改变会更新所有受影响的<strong>视图</strong>，通俗来讲，一个应用可以拥有一个大的state，而每一个页面都和这个这个state相关连，通过改变这个state来更新页面。当然一个应用可以拥有多个state不一定是一个，这个开每个开发者对项目的规划。举个例子：用户的state,在用户未登录时，页面的显示时登录界面，当用户点击登录时，通过更新这个state，来更新这个view。更多的mobx概念请移步<a href=\"http://cn.mobx.js.org/\">mobx中文文档</a></p>\n<p>接下来就是在实际开发中使用mobx了</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>在package.json 引入</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;dependencies&quot;</span>: &#123;\n    <span class=\"hljs-string\">&quot;mobx&quot;</span>: <span class=\"hljs-string\">&quot;^2.6.1&quot;</span>,\n    <span class=\"hljs-string\">&quot;mobx-react&quot;</span>: <span class=\"hljs-string\">&quot;^3.5.8&quot;</span>,\n    <span class=\"hljs-comment\">//其他库</span>\n&#125;\n<span class=\"hljs-comment\">//不加这个装饰器使用不了，如@action   </span>\n<span class=\"hljs-string\">&quot;devDependencies&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;babel-plugin-transform-decorators-legacy&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.4&quot;</span>\n&#125;</code></pre>\n</li>\n<li><p>.babelrc 中添加</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-string\">&quot;presets&quot;</span>: [<span class=\"hljs-string\">&quot;react-native&quot;</span>],\n  <span class=\"hljs-string\">&quot;plugins&quot;</span>: [<span class=\"hljs-string\">&quot;transform-decorators-legacy&quot;</span>] <span class=\"hljs-comment\">//在babel转义的时候能够将装饰器转义</span>\n&#125;</code></pre>\n\n\n</li>\n</ul>\n<h3 id=\"创建一个简易的计数器\"><a href=\"#创建一个简易的计数器\" class=\"headerlink\" title=\"创建一个简易的计数器\"></a>创建一个简易的计数器</h3><ul>\n<li><p>创建一个一个store</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123;observable, action, computed, toJS&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;mobx&#x27;</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mobxStore</span> </span>&#123;\n    @observable count = <span class=\"hljs-number\">0</span>\n\n    @action <span class=\"hljs-function\"><span class=\"hljs-title\">addCount</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-built_in\">this</span>.count = <span class=\"hljs-built_in\">this</span>.count + <span class=\"hljs-number\">1</span>;\n    &#125;\n\n    @action <span class=\"hljs-function\"><span class=\"hljs-title\">reduceCount</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-built_in\">this</span>.count = <span class=\"hljs-built_in\">this</span>.count - <span class=\"hljs-number\">1</span>;\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> store = <span class=\"hljs-keyword\">new</span> mobxStore()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> store</code></pre>\n</li>\n<li><p>在界面中和store 关联</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123;Component&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123;\n    Text,\n    StyleSheet,\n    TouchableHighlight,\n    View\n&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-native&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123;observer&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;mobx-react/custom&#x27;</span>\n<span class=\"hljs-keyword\">import</span> store <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./mobxStore&#x27;</span>\n\n@observer\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Root</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-keyword\">return</span> (\n            &lt;View style=&#123;styles.container&#125;&gt;\n                &lt;Text style=&#123;styles.welcome&#125;&gt;\n                    Mobx 的简易使用demo\n                &lt;/Text&gt;\n                &lt;Text style=&#123;styles.instructions&#125;&gt;\n                    store中的计数器：&#123;store.count&#125;\n                &lt;/Text&gt;\n                &lt;TouchableHighlight style=&#123;&#123;<span class=\"hljs-attr\">marginTop</span>: <span class=\"hljs-number\">8</span>&#125;&#125; onPress=&#123;<span class=\"hljs-function\">() =&gt;</span> store.addCount()&#125;&gt;\n                    &lt;Text style=&#123;styles.instructions&#125;&gt;\n                        点击计数+<span class=\"hljs-number\">1</span>\n                    &lt;/Text&gt;\n                &lt;/TouchableHighlight&gt;\n                &lt;TouchableHighlight style=&#123;&#123;<span class=\"hljs-attr\">marginTop</span>: <span class=\"hljs-number\">8</span>&#125;&#125; onPress=&#123;<span class=\"hljs-function\">() =&gt;</span> store.reduceCount()&#125;&gt;\n                    &lt;Text style=&#123;styles.instructions&#125;&gt;\n                        点击计数-<span class=\"hljs-number\">1</span>\n                    &lt;/Text&gt;\n                &lt;/TouchableHighlight&gt;\n            &lt;/View&gt;\n        );\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> styles = StyleSheet.create(&#123;\n    container: &#123;\n        flex: <span class=\"hljs-number\">1</span>,\n        justifyContent: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        alignItems: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        backgroundColor: <span class=\"hljs-string\">&#x27;#F5FCFF&#x27;</span>,\n    &#125;,\n    welcome: &#123;\n        fontSize: <span class=\"hljs-number\">20</span>,\n        textAlign: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        margin: <span class=\"hljs-number\">10</span>,\n    &#125;,\n    instructions: &#123;\n        textAlign: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        color: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n        marginBottom: <span class=\"hljs-number\">5</span>,\n    &#125;,\n&#125;);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Root</code></pre>\n\n</li>\n</ul>\n<p>导入<code>import &#123;observer&#125; from &#39;mobx-react/custom&#39;</code> 和刚才创建的store，<code>import store from &#39;./mobxStore&#39;</code></p>\n<p>demo 的源码已经放到github上 <a href=\"https://github.com/Cocoon-break/mobxDemo\">mobxDemo</a>，如有疑问请在该仓库中提issue</p>\n","site":{"data":{}},"excerpt":"<p>在使用RN开发app过程中需要状态管理，也就是state 这个概念，由此衍生出来的两个状态管理的框架，一个是redux，另一个就是mobx了。这两个我都用过，今天就先来介绍下mobx 在开发RN中的使用。实际上不使用状态管理的框架，你也是能够进行开发的，但是随着项目的开发以及项目的壮大，会发现没有状态管理，这个工程越来越难维护。当然redux和mobx也都是可以使用在react的web项目中。</p>\n<p>mobx核心的理念是<strong>动作</strong>改变<strong>状态</strong>，而状态的改变会更新所有受影响的<strong>视图</strong>，通俗来讲，一个应用可以拥有一个大的state，而每一个页面都和这个这个state相关连，通过改变这个state来更新页面。当然一个应用可以拥有多个state不一定是一个，这个开每个开发者对项目的规划。举个例子：用户的state,在用户未登录时，页面的显示时登录界面，当用户点击登录时，通过更新这个state，来更新这个view。更多的mobx概念请移步<a href=\"http://cn.mobx.js.org/\">mobx中文文档</a></p>\n<p>接下来就是在实际开发中使用mobx了</p>","more":"<ul>\n<li><p>在package.json 引入</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-string\">&quot;dependencies&quot;</span>: &#123;\n    <span class=\"hljs-string\">&quot;mobx&quot;</span>: <span class=\"hljs-string\">&quot;^2.6.1&quot;</span>,\n    <span class=\"hljs-string\">&quot;mobx-react&quot;</span>: <span class=\"hljs-string\">&quot;^3.5.8&quot;</span>,\n    <span class=\"hljs-comment\">//其他库</span>\n&#125;\n<span class=\"hljs-comment\">//不加这个装饰器使用不了，如@action   </span>\n<span class=\"hljs-string\">&quot;devDependencies&quot;</span>: &#123;\n  <span class=\"hljs-string\">&quot;babel-plugin-transform-decorators-legacy&quot;</span>: <span class=\"hljs-string\">&quot;^1.3.4&quot;</span>\n&#125;</code></pre>\n</li>\n<li><p>.babelrc 中添加</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-string\">&quot;presets&quot;</span>: [<span class=\"hljs-string\">&quot;react-native&quot;</span>],\n  <span class=\"hljs-string\">&quot;plugins&quot;</span>: [<span class=\"hljs-string\">&quot;transform-decorators-legacy&quot;</span>] <span class=\"hljs-comment\">//在babel转义的时候能够将装饰器转义</span>\n&#125;</code></pre>\n\n\n</li>\n</ul>\n<h3 id=\"创建一个简易的计数器\"><a href=\"#创建一个简易的计数器\" class=\"headerlink\" title=\"创建一个简易的计数器\"></a>创建一个简易的计数器</h3><ul>\n<li><p>创建一个一个store</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123;observable, action, computed, toJS&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;mobx&#x27;</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mobxStore</span> </span>&#123;\n    @observable count = <span class=\"hljs-number\">0</span>\n\n    @action <span class=\"hljs-function\"><span class=\"hljs-title\">addCount</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-built_in\">this</span>.count = <span class=\"hljs-built_in\">this</span>.count + <span class=\"hljs-number\">1</span>;\n    &#125;\n\n    @action <span class=\"hljs-function\"><span class=\"hljs-title\">reduceCount</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-built_in\">this</span>.count = <span class=\"hljs-built_in\">this</span>.count - <span class=\"hljs-number\">1</span>;\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> store = <span class=\"hljs-keyword\">new</span> mobxStore()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> store</code></pre>\n</li>\n<li><p>在界面中和store 关联</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> React, &#123;Component&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123;\n    Text,\n    StyleSheet,\n    TouchableHighlight,\n    View\n&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-native&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> &#123;observer&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;mobx-react/custom&#x27;</span>\n<span class=\"hljs-keyword\">import</span> store <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./mobxStore&#x27;</span>\n\n@observer\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Root</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-keyword\">return</span> (\n            &lt;View style=&#123;styles.container&#125;&gt;\n                &lt;Text style=&#123;styles.welcome&#125;&gt;\n                    Mobx 的简易使用demo\n                &lt;/Text&gt;\n                &lt;Text style=&#123;styles.instructions&#125;&gt;\n                    store中的计数器：&#123;store.count&#125;\n                &lt;/Text&gt;\n                &lt;TouchableHighlight style=&#123;&#123;<span class=\"hljs-attr\">marginTop</span>: <span class=\"hljs-number\">8</span>&#125;&#125; onPress=&#123;<span class=\"hljs-function\">() =&gt;</span> store.addCount()&#125;&gt;\n                    &lt;Text style=&#123;styles.instructions&#125;&gt;\n                        点击计数+<span class=\"hljs-number\">1</span>\n                    &lt;/Text&gt;\n                &lt;/TouchableHighlight&gt;\n                &lt;TouchableHighlight style=&#123;&#123;<span class=\"hljs-attr\">marginTop</span>: <span class=\"hljs-number\">8</span>&#125;&#125; onPress=&#123;<span class=\"hljs-function\">() =&gt;</span> store.reduceCount()&#125;&gt;\n                    &lt;Text style=&#123;styles.instructions&#125;&gt;\n                        点击计数-<span class=\"hljs-number\">1</span>\n                    &lt;/Text&gt;\n                &lt;/TouchableHighlight&gt;\n            &lt;/View&gt;\n        );\n    &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> styles = StyleSheet.create(&#123;\n    container: &#123;\n        flex: <span class=\"hljs-number\">1</span>,\n        justifyContent: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        alignItems: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        backgroundColor: <span class=\"hljs-string\">&#x27;#F5FCFF&#x27;</span>,\n    &#125;,\n    welcome: &#123;\n        fontSize: <span class=\"hljs-number\">20</span>,\n        textAlign: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        margin: <span class=\"hljs-number\">10</span>,\n    &#125;,\n    instructions: &#123;\n        textAlign: <span class=\"hljs-string\">&#x27;center&#x27;</span>,\n        color: <span class=\"hljs-string\">&#x27;red&#x27;</span>,\n        marginBottom: <span class=\"hljs-number\">5</span>,\n    &#125;,\n&#125;);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Root</code></pre>\n\n</li>\n</ul>\n<p>导入<code>import &#123;observer&#125; from &#39;mobx-react/custom&#39;</code> 和刚才创建的store，<code>import store from &#39;./mobxStore&#39;</code></p>\n<p>demo 的源码已经放到github上 <a href=\"https://github.com/Cocoon-break/mobxDemo\">mobxDemo</a>，如有疑问请在该仓库中提issue</p>"},{"title":"MySQL系列四之执行流程及架构","date":"2018-08-22T14:37:01.000Z","index_img":["/images/mysql/MySQL_Architecture.jpg"],"_content":"\n前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。\n\n### 执行流程\n\n我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？\n\n1. MySQL客户端通过协议将SQL语句发送给MySQL服务器。\n\n2. MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。\n\n3. MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）\n\n4. MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。\n\n5. 将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。\n\n\n知道执行流程之后，我们看下MySQL的架构图。\n\n![](/images/mysql/MySQL_Architecture.jpg)\n\nmysql 逻辑架构主要分为三层\n\n1. 应用层\n   - 这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。\n2. 核心服务层\n   - 该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等\n3. 存储引擎层\n   - 可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。\n\n### 架构服务\n\n#### 应用层的服务\n\n##### 链接处理\n\nMySQL首先是一个网络程序，其在TCP之上定义了自己的[应用层协议](https://dev.mysql.com/doc/internals/en/client-server-protocol.html)。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。\n\n#####身份验证\n\n每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。\n\n##### 安全\n\n客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。\n\n#### 核心服务层的服务\n\n##### MySQL服务和实用程序\n\nMySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。\n\n- 备份和恢复\n- 安全\n- 复制\n- 簇\n- 分区\n- 工作台\n\n##### SQL接口\n\nSQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。\n\n##### 解析器\n\nMySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：\n\n- 在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。\n- 语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 \n\n##### 优化器\n\n语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，**与具体的存储引擎实现无关**。\n\n##### 缓存\n\nMySQL缓存（查询缓存）存储**SELECT** 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。\n\n#### 存储引擎层的服务\n\n存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。\n\n```mysql\n-- 查看MySQL支持的存储引擎\nSHOW ENGINES;\n```\n\n**MySQL5.5以后默认使用InnoDB存储引擎**，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。\n\n##### InnoDB\n\nInnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：\n\n1. 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。\n2. 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。\n3. 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。\n4. 外键约束。MySQL支持外键的存储引擎只有InnoDB。\n5. 支持自动增加列AUTO_INCREMENT属性。\n\n##### MyISAM\n\n在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。\n\nMyISAM存储引擎特别适合在以下几种情况下使用：\n\n1. 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。\n2. 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。\n\n\n\n[更多引擎介绍](https://zhuanlan.zhihu.com/p/53619907)\n\n本文参考：https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\n\n​\t\t\t\t\thttps://zhuanlan.zhihu.com/p/53619907\n\n​\t\t\t\t\thttps://www.cnblogs.com/qq1148932219/p/11694064.html\n\n   ","source":"_posts/MySQL系列四.md","raw":"---\ntitle: MySQL系列四之执行流程及架构\ndate: 2018-08-22 22:37:01\nindex_img:\n- /images/mysql/MySQL_Architecture.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\n前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。\n\n### 执行流程\n\n我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？\n\n1. MySQL客户端通过协议将SQL语句发送给MySQL服务器。\n\n2. MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。\n\n3. MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）\n\n4. MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。\n\n5. 将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。\n\n\n知道执行流程之后，我们看下MySQL的架构图。\n\n![](/images/mysql/MySQL_Architecture.jpg)\n\nmysql 逻辑架构主要分为三层\n\n1. 应用层\n   - 这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。\n2. 核心服务层\n   - 该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等\n3. 存储引擎层\n   - 可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。\n\n### 架构服务\n\n#### 应用层的服务\n\n##### 链接处理\n\nMySQL首先是一个网络程序，其在TCP之上定义了自己的[应用层协议](https://dev.mysql.com/doc/internals/en/client-server-protocol.html)。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。\n\n#####身份验证\n\n每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。\n\n##### 安全\n\n客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。\n\n#### 核心服务层的服务\n\n##### MySQL服务和实用程序\n\nMySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。\n\n- 备份和恢复\n- 安全\n- 复制\n- 簇\n- 分区\n- 工作台\n\n##### SQL接口\n\nSQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。\n\n##### 解析器\n\nMySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：\n\n- 在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。\n- 语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 \n\n##### 优化器\n\n语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，**与具体的存储引擎实现无关**。\n\n##### 缓存\n\nMySQL缓存（查询缓存）存储**SELECT** 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。\n\n#### 存储引擎层的服务\n\n存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。\n\n```mysql\n-- 查看MySQL支持的存储引擎\nSHOW ENGINES;\n```\n\n**MySQL5.5以后默认使用InnoDB存储引擎**，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。\n\n##### InnoDB\n\nInnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：\n\n1. 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。\n2. 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。\n3. 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。\n4. 外键约束。MySQL支持外键的存储引擎只有InnoDB。\n5. 支持自动增加列AUTO_INCREMENT属性。\n\n##### MyISAM\n\n在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。\n\nMyISAM存储引擎特别适合在以下几种情况下使用：\n\n1. 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。\n2. 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。\n\n\n\n[更多引擎介绍](https://zhuanlan.zhihu.com/p/53619907)\n\n本文参考：https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\n\n​\t\t\t\t\thttps://zhuanlan.zhihu.com/p/53619907\n\n​\t\t\t\t\thttps://www.cnblogs.com/qq1148932219/p/11694064.html\n\n   ","slug":"MySQL系列四","published":1,"updated":"2020-03-24T08:01:38.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s09000gmdym74x2a376","content":"<p>前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？</p>\n<ol>\n<li><p>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</p>\n</li>\n<li><p>MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p>\n</li>\n<li><p>MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）</p>\n</li>\n<li><p>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</p>\n</li>\n<li><p>将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。</p>\n</li>\n</ol>\n<p>知道执行流程之后，我们看下MySQL的架构图。</p>\n<p><img src=\"/images/mysql/MySQL_Architecture.jpg\"></p>\n<p>mysql 逻辑架构主要分为三层</p>\n<ol>\n<li>应用层<ul>\n<li>这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。</li>\n</ul>\n</li>\n<li>核心服务层<ul>\n<li>该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等</li>\n</ul>\n</li>\n<li>存储引擎层<ul>\n<li>可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"架构服务\"><a href=\"#架构服务\" class=\"headerlink\" title=\"架构服务\"></a>架构服务</h3><h4 id=\"应用层的服务\"><a href=\"#应用层的服务\" class=\"headerlink\" title=\"应用层的服务\"></a>应用层的服务</h4><h5 id=\"链接处理\"><a href=\"#链接处理\" class=\"headerlink\" title=\"链接处理\"></a>链接处理</h5><p>MySQL首先是一个网络程序，其在TCP之上定义了自己的<a href=\"https://dev.mysql.com/doc/internals/en/client-server-protocol.html\">应用层协议</a>。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。</p>\n<p>#####身份验证</p>\n<p>每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。</p>\n<h5 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h5><p>客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。</p>\n<h4 id=\"核心服务层的服务\"><a href=\"#核心服务层的服务\" class=\"headerlink\" title=\"核心服务层的服务\"></a>核心服务层的服务</h4><h5 id=\"MySQL服务和实用程序\"><a href=\"#MySQL服务和实用程序\" class=\"headerlink\" title=\"MySQL服务和实用程序\"></a>MySQL服务和实用程序</h5><p>MySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。</p>\n<ul>\n<li>备份和恢复</li>\n<li>安全</li>\n<li>复制</li>\n<li>簇</li>\n<li>分区</li>\n<li>工作台</li>\n</ul>\n<h5 id=\"SQL接口\"><a href=\"#SQL接口\" class=\"headerlink\" title=\"SQL接口\"></a>SQL接口</h5><p>SQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</p>\n<h5 id=\"解析器\"><a href=\"#解析器\" class=\"headerlink\" title=\"解析器\"></a>解析器</h5><p>MySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：</p>\n<ul>\n<li>在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。</li>\n<li>语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 </li>\n</ul>\n<h5 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h5><p>语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，<strong>与具体的存储引擎实现无关</strong>。</p>\n<h5 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h5><p>MySQL缓存（查询缓存）存储<strong>SELECT</strong> 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。</p>\n<h4 id=\"存储引擎层的服务\"><a href=\"#存储引擎层的服务\" class=\"headerlink\" title=\"存储引擎层的服务\"></a>存储引擎层的服务</h4><p>存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。</p>\n<pre><code class=\"hljs mysql\">-- 查看MySQL支持的存储引擎\nSHOW ENGINES;</code></pre>\n\n<p><strong>MySQL5.5以后默认使用InnoDB存储引擎</strong>，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。</p>\n<h5 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h5><p>InnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>\n<ol>\n<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>\n<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>\n<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>\n<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>\n<li>支持自动增加列AUTO_INCREMENT属性。</li>\n</ol>\n<h5 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h5><p>在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。</p>\n<p>MyISAM存储引擎特别适合在以下几种情况下使用：</p>\n<ol>\n<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>\n<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/53619907\">更多引擎介绍</a></p>\n<p>本文参考：<a href=\"https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\">https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html</a></p>\n<p>​                    <a href=\"https://zhuanlan.zhihu.com/p/53619907\">https://zhuanlan.zhihu.com/p/53619907</a></p>\n<p>​                    <a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？</p>\n<ol>\n<li><p>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</p>\n</li>\n<li><p>MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p>\n</li>\n<li><p>MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）</p>\n</li>\n<li><p>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</p>\n</li>\n<li><p>将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。</p>\n</li>\n</ol>\n<p>知道执行流程之后，我们看下MySQL的架构图。</p>\n<p><img src=\"/images/mysql/MySQL_Architecture.jpg\"></p>\n<p>mysql 逻辑架构主要分为三层</p>\n<ol>\n<li>应用层<ul>\n<li>这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。</li>\n</ul>\n</li>\n<li>核心服务层<ul>\n<li>该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等</li>\n</ul>\n</li>\n<li>存储引擎层<ul>\n<li>可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"架构服务\"><a href=\"#架构服务\" class=\"headerlink\" title=\"架构服务\"></a>架构服务</h3><h4 id=\"应用层的服务\"><a href=\"#应用层的服务\" class=\"headerlink\" title=\"应用层的服务\"></a>应用层的服务</h4><h5 id=\"链接处理\"><a href=\"#链接处理\" class=\"headerlink\" title=\"链接处理\"></a>链接处理</h5><p>MySQL首先是一个网络程序，其在TCP之上定义了自己的<a href=\"https://dev.mysql.com/doc/internals/en/client-server-protocol.html\">应用层协议</a>。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。</p>\n<p>#####身份验证</p>\n<p>每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。</p>\n<h5 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h5><p>客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。</p>\n<h4 id=\"核心服务层的服务\"><a href=\"#核心服务层的服务\" class=\"headerlink\" title=\"核心服务层的服务\"></a>核心服务层的服务</h4><h5 id=\"MySQL服务和实用程序\"><a href=\"#MySQL服务和实用程序\" class=\"headerlink\" title=\"MySQL服务和实用程序\"></a>MySQL服务和实用程序</h5><p>MySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。</p>\n<ul>\n<li>备份和恢复</li>\n<li>安全</li>\n<li>复制</li>\n<li>簇</li>\n<li>分区</li>\n<li>工作台</li>\n</ul>\n<h5 id=\"SQL接口\"><a href=\"#SQL接口\" class=\"headerlink\" title=\"SQL接口\"></a>SQL接口</h5><p>SQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</p>\n<h5 id=\"解析器\"><a href=\"#解析器\" class=\"headerlink\" title=\"解析器\"></a>解析器</h5><p>MySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：</p>\n<ul>\n<li>在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。</li>\n<li>语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 </li>\n</ul>\n<h5 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h5><p>语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，<strong>与具体的存储引擎实现无关</strong>。</p>\n<h5 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h5><p>MySQL缓存（查询缓存）存储<strong>SELECT</strong> 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。</p>\n<h4 id=\"存储引擎层的服务\"><a href=\"#存储引擎层的服务\" class=\"headerlink\" title=\"存储引擎层的服务\"></a>存储引擎层的服务</h4><p>存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。</p>\n<pre><code class=\"hljs mysql\">-- 查看MySQL支持的存储引擎\nSHOW ENGINES;</code></pre>\n\n<p><strong>MySQL5.5以后默认使用InnoDB存储引擎</strong>，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。</p>\n<h5 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h5><p>InnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>\n<ol>\n<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>\n<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>\n<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>\n<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>\n<li>支持自动增加列AUTO_INCREMENT属性。</li>\n</ol>\n<h5 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h5><p>在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。</p>\n<p>MyISAM存储引擎特别适合在以下几种情况下使用：</p>\n<ol>\n<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>\n<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/53619907\">更多引擎介绍</a></p>\n<p>本文参考：<a href=\"https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\">https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html</a></p>\n<p>​                    <a href=\"https://zhuanlan.zhihu.com/p/53619907\">https://zhuanlan.zhihu.com/p/53619907</a></p>\n<p>​                    <a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n"},{"title":"caddy的简易使用","date":"2017-06-30T07:47:20.000Z","_content":"\n​\tcaddy是一个开源的，使用golang 编写，支持HTTPS的web服务器，同时也可以作为负载均衡器使用，caddy的使用非常简单，只要一个二进制包就可以执行，不用像nginx 配置起来那么麻烦。\n\n​\t [caddy下载](https://caddyserver.com/download)\n\n​\tcaddy可以使用命令行参数的方式去执行，也可以指定配置文件去执行。使用命令行去执行，具体的参数名称参考 [caddy 接收参数](https://caddyserver.com/docs/cli)\n\n​        caddy在某个文件夹下直接执行，通过访问http://localhost:2015访问文件下的所有内容。使用起来非常简单。 \n\n### 使用\n\n 通过配置文件来使用caddy，执行是`caddy -conf caddyfile`,  给caddy 配置不同的caddyfile如下\n\n- 使用caddy 负载均衡，配置caddyfile\n\n  ```sh\n  :1234\n  proxy / ip1:port1,ip2:port2,ip3:port3{\n    policy random\n    health_check /version\n    health_check_interval 30s\n    health_check_timeout 30s\n  }\n  log ／ /var/log/caddy.log {\n  \trotate_size    100\n  \trotate_age      7\n  \trotate_keep     5\n  }\n  ```\n\n  注：caddy监听本机`1234`端口，分别将请求转发给`ip1:port1,ip2:port2,ip3:port3` 三台机器，policy为负载均衡的策略，random表示从三台机器上随机选择负载，也有其他选项least_conn, round_robin, first, ip_hash, or uri_hash。`health_check`是对三台机器提供的服务进行健康检查，/version 为进行健康检查的接口。每30秒进行一次健康检查，每次检查超过30秒表示失败。如果发现这个接口不能正常返回，则回被caddy标识为不健康的服务，则后续的负载不会到不健康的服务上。配置log记录caddy日志信息\n\n<!-- more -->\n\n- 使用caddy作为静态资源服务器，配置caddyfile\n\n  ```sh\n  :1234\n  root /opt/test\n  browse\n  ext .pdf .html .htm \n  ```\n\n   注：caddy监听本机的`1234`端口，指定了访问的根目录为/opt/test,如果/opt/test 目录下没有index.html,那么访问`http://ip:1234` 会将/opt/test目录结构展现到页面中。ext 表示可以忽略文件的后缀\n\n  \n\n更多的配置可以访问 [caddy配置文件](https://caddyserver.com/docs/http-caddyfile)","source":"_posts/caddy的简易使用.md","raw":"---\ntitle: caddy的简易使用\ndate: 2017-06-30 15:47:20\ntags: \n- Linux\ncategories:\n- 开源工具\n---\n\n​\tcaddy是一个开源的，使用golang 编写，支持HTTPS的web服务器，同时也可以作为负载均衡器使用，caddy的使用非常简单，只要一个二进制包就可以执行，不用像nginx 配置起来那么麻烦。\n\n​\t [caddy下载](https://caddyserver.com/download)\n\n​\tcaddy可以使用命令行参数的方式去执行，也可以指定配置文件去执行。使用命令行去执行，具体的参数名称参考 [caddy 接收参数](https://caddyserver.com/docs/cli)\n\n​        caddy在某个文件夹下直接执行，通过访问http://localhost:2015访问文件下的所有内容。使用起来非常简单。 \n\n### 使用\n\n 通过配置文件来使用caddy，执行是`caddy -conf caddyfile`,  给caddy 配置不同的caddyfile如下\n\n- 使用caddy 负载均衡，配置caddyfile\n\n  ```sh\n  :1234\n  proxy / ip1:port1,ip2:port2,ip3:port3{\n    policy random\n    health_check /version\n    health_check_interval 30s\n    health_check_timeout 30s\n  }\n  log ／ /var/log/caddy.log {\n  \trotate_size    100\n  \trotate_age      7\n  \trotate_keep     5\n  }\n  ```\n\n  注：caddy监听本机`1234`端口，分别将请求转发给`ip1:port1,ip2:port2,ip3:port3` 三台机器，policy为负载均衡的策略，random表示从三台机器上随机选择负载，也有其他选项least_conn, round_robin, first, ip_hash, or uri_hash。`health_check`是对三台机器提供的服务进行健康检查，/version 为进行健康检查的接口。每30秒进行一次健康检查，每次检查超过30秒表示失败。如果发现这个接口不能正常返回，则回被caddy标识为不健康的服务，则后续的负载不会到不健康的服务上。配置log记录caddy日志信息\n\n<!-- more -->\n\n- 使用caddy作为静态资源服务器，配置caddyfile\n\n  ```sh\n  :1234\n  root /opt/test\n  browse\n  ext .pdf .html .htm \n  ```\n\n   注：caddy监听本机的`1234`端口，指定了访问的根目录为/opt/test,如果/opt/test 目录下没有index.html,那么访问`http://ip:1234` 会将/opt/test目录结构展现到页面中。ext 表示可以忽略文件的后缀\n\n  \n\n更多的配置可以访问 [caddy配置文件](https://caddyserver.com/docs/http-caddyfile)","slug":"caddy的简易使用","published":1,"updated":"2020-02-27T03:51:50.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0a000imdymhwz0hykc","content":"<p>​    caddy是一个开源的，使用golang 编写，支持HTTPS的web服务器，同时也可以作为负载均衡器使用，caddy的使用非常简单，只要一个二进制包就可以执行，不用像nginx 配置起来那么麻烦。</p>\n<p>​     <a href=\"https://caddyserver.com/download\">caddy下载</a></p>\n<p>​    caddy可以使用命令行参数的方式去执行，也可以指定配置文件去执行。使用命令行去执行，具体的参数名称参考 <a href=\"https://caddyserver.com/docs/cli\">caddy 接收参数</a></p>\n<p>​        caddy在某个文件夹下直接执行，通过访问<a href=\"http://localhost:2015访问文件下的所有内容。使用起来非常简单。\">http://localhost:2015访问文件下的所有内容。使用起来非常简单。</a> </p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p> 通过配置文件来使用caddy，执行是<code>caddy -conf caddyfile</code>,  给caddy 配置不同的caddyfile如下</p>\n<ul>\n<li><p>使用caddy 负载均衡，配置caddyfile</p>\n<pre><code class=\"hljs sh\">:1234\nproxy / ip1:port1,ip2:port2,ip3:port3&#123;\n  policy random\n  health_check /version\n  health_check_interval 30s\n  health_check_timeout 30s\n&#125;\n<span class=\"hljs-built_in\">log</span> ／ /var/<span class=\"hljs-built_in\">log</span>/caddy.log &#123;\n\trotate_size    100\n\trotate_age      7\n\trotate_keep     5\n&#125;</code></pre>\n\n<p>注：caddy监听本机<code>1234</code>端口，分别将请求转发给<code>ip1:port1,ip2:port2,ip3:port3</code> 三台机器，policy为负载均衡的策略，random表示从三台机器上随机选择负载，也有其他选项least_conn, round_robin, first, ip_hash, or uri_hash。<code>health_check</code>是对三台机器提供的服务进行健康检查，/version 为进行健康检查的接口。每30秒进行一次健康检查，每次检查超过30秒表示失败。如果发现这个接口不能正常返回，则回被caddy标识为不健康的服务，则后续的负载不会到不健康的服务上。配置log记录caddy日志信息</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>使用caddy作为静态资源服务器，配置caddyfile</p>\n<pre><code class=\"hljs sh\">:1234\nroot /opt/<span class=\"hljs-built_in\">test</span>\nbrowse\next .pdf .html .htm</code></pre>\n\n<p> 注：caddy监听本机的<code>1234</code>端口，指定了访问的根目录为/opt/test,如果/opt/test 目录下没有index.html,那么访问<code>http://ip:1234</code> 会将/opt/test目录结构展现到页面中。ext 表示可以忽略文件的后缀</p>\n</li>\n</ul>\n<p>更多的配置可以访问 <a href=\"https://caddyserver.com/docs/http-caddyfile\">caddy配置文件</a></p>\n","site":{"data":{}},"excerpt":"<p>​    caddy是一个开源的，使用golang 编写，支持HTTPS的web服务器，同时也可以作为负载均衡器使用，caddy的使用非常简单，只要一个二进制包就可以执行，不用像nginx 配置起来那么麻烦。</p>\n<p>​     <a href=\"https://caddyserver.com/download\">caddy下载</a></p>\n<p>​    caddy可以使用命令行参数的方式去执行，也可以指定配置文件去执行。使用命令行去执行，具体的参数名称参考 <a href=\"https://caddyserver.com/docs/cli\">caddy 接收参数</a></p>\n<p>​        caddy在某个文件夹下直接执行，通过访问<a href=\"http://localhost:2015访问文件下的所有内容。使用起来非常简单。\">http://localhost:2015访问文件下的所有内容。使用起来非常简单。</a> </p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p> 通过配置文件来使用caddy，执行是<code>caddy -conf caddyfile</code>,  给caddy 配置不同的caddyfile如下</p>\n<ul>\n<li><p>使用caddy 负载均衡，配置caddyfile</p>\n<pre><code class=\"hljs sh\">:1234\nproxy / ip1:port1,ip2:port2,ip3:port3&#123;\n  policy random\n  health_check /version\n  health_check_interval 30s\n  health_check_timeout 30s\n&#125;\n<span class=\"hljs-built_in\">log</span> ／ /var/<span class=\"hljs-built_in\">log</span>/caddy.log &#123;\n\trotate_size    100\n\trotate_age      7\n\trotate_keep     5\n&#125;</code></pre>\n\n<p>注：caddy监听本机<code>1234</code>端口，分别将请求转发给<code>ip1:port1,ip2:port2,ip3:port3</code> 三台机器，policy为负载均衡的策略，random表示从三台机器上随机选择负载，也有其他选项least_conn, round_robin, first, ip_hash, or uri_hash。<code>health_check</code>是对三台机器提供的服务进行健康检查，/version 为进行健康检查的接口。每30秒进行一次健康检查，每次检查超过30秒表示失败。如果发现这个接口不能正常返回，则回被caddy标识为不健康的服务，则后续的负载不会到不健康的服务上。配置log记录caddy日志信息</p>\n</li>\n</ul>","more":"<ul>\n<li><p>使用caddy作为静态资源服务器，配置caddyfile</p>\n<pre><code class=\"hljs sh\">:1234\nroot /opt/<span class=\"hljs-built_in\">test</span>\nbrowse\next .pdf .html .htm</code></pre>\n\n<p> 注：caddy监听本机的<code>1234</code>端口，指定了访问的根目录为/opt/test,如果/opt/test 目录下没有index.html,那么访问<code>http://ip:1234</code> 会将/opt/test目录结构展现到页面中。ext 表示可以忽略文件的后缀</p>\n</li>\n</ul>\n<p>更多的配置可以访问 <a href=\"https://caddyserver.com/docs/http-caddyfile\">caddy配置文件</a></p>"},{"title":"ffmpeg简易介绍","date":"2017-05-22T06:34:12.000Z","_content":"\n## 媒体文件结构\n\n一个媒体文件并不像许多人想象的那样，是将媒体内容编码起来直接作为文件的。实际上，它通常是由多个不同种类的媒体流（ Stream ）组成，再以特定的封装格式封装起来的。\n\n比较常见的媒体流就是视频流跟音频流了，顾名思义，视频流存储的就是视频信息，音频流存储的就是音频信息。一个视频流或者音频流的内容，就是以特定的编码格式所存储的视频或音频信息。\n\n**一个文件的里面的媒体流所采用的编码格式跟这个文件的后缀名并没有完全的必然联系。** **文件的后缀名通常就代表这个文件的封装格式。**\n\n## ffmpeg 安装\n\n自行下载使用系统安装对应的安装包[官网下载](https://ffmpeg.org/download.html)\n\n以下使用的平台都为Mac系统下\n\n<!-- more -->\n\n## 开始使用\n\n1. 打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用\n\n   ```ssh\n   ffmpeg -help\n   ```\n\n   ```ssh\n   ffmpeg version 3.3 Copyright (c) 2000-2017 the FFmpeg developers\n     built with Apple LLVM version 8.1.0 (clang-802.0.41)\n     configuration: --prefix=/usr/local/Cellar/ffmpeg/3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda\n     libavutil      55. 58.100 / 55. 58.100\n     libavcodec     57. 89.100 / 57. 89.100\n     libavformat    57. 71.100 / 57. 71.100\n     libavdevice    57.  6.100 / 57.  6.100\n     libavfilter     6. 82.100 /  6. 82.100\n     libavresample   3.  5.  0 /  3.  5.  0\n     libswscale      4.  6.100 /  4.  6.100\n     libswresample   2.  7.100 /  2.  7.100\n     libpostproc    54.  5.100 / 54.  5.100\n   Hyper fast Audio and Video encoder\n   usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...\n   ```\n\n   重点是关注 usage: ffmpeg [options][[infile options] -i infile]... {[outfile options] outfile}… 这句是说ffmpeg 的主要用法\n\n   \n\n2. 查看ffmpeg 支持的格式\n\n   查看封装格式，包括音频，视频等封装格式\n\n   ```ssh\n   ffmpeg -formats\n   ```\n\n   查看编解码器包括音频，视频等封装格式\n\n   ```ssh\n   ffmpeg -codecs\n   ```\n\n3. 进行格式转换\n\n   ```ssh\n   ffmpeg -i a.mp4 b.mkv\n   ```\n\n   这里是将mp4格式的视频转换成mkv格式。\n\n   **注：** 查看默认编码格式，以下的Matroska也就是指 mkv\n\n   ```code\n   ffmpeg -help muxer=Matroska\n\n   #以下为摘要信息，从中可以看出默认的视频编码为h264,音频编码为ac3,字幕流编码为ass，部分格式视频不支持字幕流\n   Muxer matroska [Matroska]:\n       Common extensions: mkv.\n       Mime type: video/x-matroska.\n       Default video codec: h264.\n       Default audio codec: ac3.\n       Default subtitle codec: ass.\n   ```\n\n4. 指定编码器进行转换\n\n   ```sh\n   ffmpeg -i a.mp4 -c:v hevc -c:a aac b.mkv\n   ```\n\n   **注：** `-c:v` 可以用`-vcodec`替换，当它们的值为copy时，就表示编码格式不进行转换\n\n5. 在转换时可以进行的调整\n\n   在 `ffmpeg -help` 时可以看到有一些和音频，视频，字幕相关的选项\n\n   ```ssh\n   Video options:\n   -vframes number     set the number of video frames to output\n   -r rate             set frame rate (Hz value, fraction or abbreviation)\n   -s size             set frame size (WxH or abbreviation)\n   -aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\n   -bits_per_raw_sample number  set the number of bits per raw sample\n   -vn                 disable video\n   -vcodec codec       force video codec ('copy' to copy stream)\n   -timecode hh:mm:ss[:;.]ff  set initial TimeCode value.\n   -pass n             select the pass number (1 to 3)\n   -vf filter_graph    set video filters\n   -ab bitrate         audio bitrate (please use -b:a)\n   -b bitrate          video bitrate (please use -b:v)\n   -dn                 disable data\n\n   Audio options:\n   -aframes number     set the number of audio frames to output\n   -aq quality         set audio quality (codec-specific)\n   -ar rate            set audio sampling rate (in Hz)\n   -ac channels        set number of audio channels\n   -an                 disable audio\n   -acodec codec       force audio codec ('copy' to copy stream)\n   -vol volume         change audio volume (256=normal)\n   -af filter_graph    set audio filters\n\n   Subtitle options:\n   -s size             set frame size (WxH or abbreviation)\n   -sn                 disable subtitle\n   -scodec codec       force subtitle codec ('copy' to copy stream)\n   -stag fourcc/tag    force subtitle tag/fourcc\n   -fix_sub_duration   fix subtitles duration\n   -canvas_size size   set canvas size (WxH or abbreviation)\n   -spre preset        set the subtitle options to the indicated preset\n   ```\n\n   当然还有对整个文件进行调整的参数\n\n   ```ssh\n   Per-file main options:\n   -f fmt              force format\n   -c codec            codec name\n   -codec codec        codec name\n   -pre preset         preset name\n   -map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile\n   -t duration         record or transcode \"duration\" seconds of audio/video\n   -to time_stop       record or transcode stop time\n   -fs limit_size      set the limit file size in bytes\n   -ss time_off        set the start time offset\n   -sseof time_off     set the start time offset relative to EOF\n   -seek_timestamp     enable/disable seeking by timestamp with -ss\n   -timestamp time     set the recording timestamp ('now' to set the current time)\n   -metadata string=string  add metadata\n   -program title=string:st=number...  add program with specified streams\n   -target type        specify target file type (\"vcd\", \"svcd\", \"dvd\", \"dv\" or \"dv50\" with optional prefixes \"pal-\", \"ntsc-\" or \"film-\")\n   -apad               audio pad\n   -frames number      set the number of frames to output\n   -filter filter_graph  set stream filtergraph\n   -filter_script filename  read stream filtergraph description from a file\n   -reinit_filter      reinit filtergraph on input parameter changes\n   -discard            discard\n   -disposition        disposition\n   ```\n\n   #### ffmpeg常用的日常命令\n\n   **关于FFmpeg的具体技术及参数细节，可以参考**[**ffmpeg官方文档**](https://ffmpeg.org/documentation.html)**，以下介绍一些常用的ffmpeg命令。**\n   \n   1. H264编码的其他格式转换TS\n   \n      ```shell\n      ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\n      ffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts\n      ```\n   \n      说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。\n   \n      -vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。\n   \n   2. 视频转帧图片\n   \n      ```shell\n      ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png\n      ```\n   \n      将视频中每一帧切出来，可用作测试人脸检测模块。\n   \n      -r：表示帧率，25即每秒25帧来处理帧。\n   \n      -f：表示输出格式，此处为image2格式。\n   \n       ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。\n   \n      批量转图：\n   \n      ```shell\n      find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -r 25 -f image2 ./path/%05d{}.png\n      ```\n   \n   3. 帧图片转视频\n   \n      ```shell\n      ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts\n      ```\n   \n      将连续的帧图片，转制为视频。\n   \n   4. 视频帧率处理\n   \n      ```shell\n      ffmpeg -i input.ts -vcode h264 -r 20 output.ts\n      ```\n   \n      模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。\n   \n   5. 从相机视频流录制ts或mp4格式的视频\n   \n      ```shell\n      ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts\n      ```\n   \n      说明：tcp协议\n   \n   6. 截取视频指令\n   \n      ```shell\n      ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT\n      ```\n   \n      说明：\n   \n      ​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05\n   \n      ​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10\n   \n   7. 合并视频指令\n   \n      ```shell\n      ffmpeg -i \"concat:intermediate1.ts|intermediate2.ts\" -c copy -bsf:a aac_adtstoasc output.ts\n      ```\n   \n   8. 视频旋转\n   \n       ```shell\n      find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -vf \"transpose=1\" -vcodec libx264 -an ./rota/{}\n       ```\n   \n   9. 图片选择\n   \n      ```shell\n      convert example.jpg -rotate 90 example-rotated.jpg\n      ```\n   \n   10. 获取视频文件的帧数\n   \n       ```shell\n       ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2>&1 | grep 'frame='\n       ```\n   \n   [文章参考](https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh) \n   \n   \n\n\n","source":"_posts/ffmpeg简易介绍.md","raw":"---\ntitle: ffmpeg简易介绍\ndate: 2017-05-22 14:34:12\ntags: \n- 扩展\ncategories:\n- 开源工具\n---\n\n## 媒体文件结构\n\n一个媒体文件并不像许多人想象的那样，是将媒体内容编码起来直接作为文件的。实际上，它通常是由多个不同种类的媒体流（ Stream ）组成，再以特定的封装格式封装起来的。\n\n比较常见的媒体流就是视频流跟音频流了，顾名思义，视频流存储的就是视频信息，音频流存储的就是音频信息。一个视频流或者音频流的内容，就是以特定的编码格式所存储的视频或音频信息。\n\n**一个文件的里面的媒体流所采用的编码格式跟这个文件的后缀名并没有完全的必然联系。** **文件的后缀名通常就代表这个文件的封装格式。**\n\n## ffmpeg 安装\n\n自行下载使用系统安装对应的安装包[官网下载](https://ffmpeg.org/download.html)\n\n以下使用的平台都为Mac系统下\n\n<!-- more -->\n\n## 开始使用\n\n1. 打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用\n\n   ```ssh\n   ffmpeg -help\n   ```\n\n   ```ssh\n   ffmpeg version 3.3 Copyright (c) 2000-2017 the FFmpeg developers\n     built with Apple LLVM version 8.1.0 (clang-802.0.41)\n     configuration: --prefix=/usr/local/Cellar/ffmpeg/3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda\n     libavutil      55. 58.100 / 55. 58.100\n     libavcodec     57. 89.100 / 57. 89.100\n     libavformat    57. 71.100 / 57. 71.100\n     libavdevice    57.  6.100 / 57.  6.100\n     libavfilter     6. 82.100 /  6. 82.100\n     libavresample   3.  5.  0 /  3.  5.  0\n     libswscale      4.  6.100 /  4.  6.100\n     libswresample   2.  7.100 /  2.  7.100\n     libpostproc    54.  5.100 / 54.  5.100\n   Hyper fast Audio and Video encoder\n   usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...\n   ```\n\n   重点是关注 usage: ffmpeg [options][[infile options] -i infile]... {[outfile options] outfile}… 这句是说ffmpeg 的主要用法\n\n   \n\n2. 查看ffmpeg 支持的格式\n\n   查看封装格式，包括音频，视频等封装格式\n\n   ```ssh\n   ffmpeg -formats\n   ```\n\n   查看编解码器包括音频，视频等封装格式\n\n   ```ssh\n   ffmpeg -codecs\n   ```\n\n3. 进行格式转换\n\n   ```ssh\n   ffmpeg -i a.mp4 b.mkv\n   ```\n\n   这里是将mp4格式的视频转换成mkv格式。\n\n   **注：** 查看默认编码格式，以下的Matroska也就是指 mkv\n\n   ```code\n   ffmpeg -help muxer=Matroska\n\n   #以下为摘要信息，从中可以看出默认的视频编码为h264,音频编码为ac3,字幕流编码为ass，部分格式视频不支持字幕流\n   Muxer matroska [Matroska]:\n       Common extensions: mkv.\n       Mime type: video/x-matroska.\n       Default video codec: h264.\n       Default audio codec: ac3.\n       Default subtitle codec: ass.\n   ```\n\n4. 指定编码器进行转换\n\n   ```sh\n   ffmpeg -i a.mp4 -c:v hevc -c:a aac b.mkv\n   ```\n\n   **注：** `-c:v` 可以用`-vcodec`替换，当它们的值为copy时，就表示编码格式不进行转换\n\n5. 在转换时可以进行的调整\n\n   在 `ffmpeg -help` 时可以看到有一些和音频，视频，字幕相关的选项\n\n   ```ssh\n   Video options:\n   -vframes number     set the number of video frames to output\n   -r rate             set frame rate (Hz value, fraction or abbreviation)\n   -s size             set frame size (WxH or abbreviation)\n   -aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\n   -bits_per_raw_sample number  set the number of bits per raw sample\n   -vn                 disable video\n   -vcodec codec       force video codec ('copy' to copy stream)\n   -timecode hh:mm:ss[:;.]ff  set initial TimeCode value.\n   -pass n             select the pass number (1 to 3)\n   -vf filter_graph    set video filters\n   -ab bitrate         audio bitrate (please use -b:a)\n   -b bitrate          video bitrate (please use -b:v)\n   -dn                 disable data\n\n   Audio options:\n   -aframes number     set the number of audio frames to output\n   -aq quality         set audio quality (codec-specific)\n   -ar rate            set audio sampling rate (in Hz)\n   -ac channels        set number of audio channels\n   -an                 disable audio\n   -acodec codec       force audio codec ('copy' to copy stream)\n   -vol volume         change audio volume (256=normal)\n   -af filter_graph    set audio filters\n\n   Subtitle options:\n   -s size             set frame size (WxH or abbreviation)\n   -sn                 disable subtitle\n   -scodec codec       force subtitle codec ('copy' to copy stream)\n   -stag fourcc/tag    force subtitle tag/fourcc\n   -fix_sub_duration   fix subtitles duration\n   -canvas_size size   set canvas size (WxH or abbreviation)\n   -spre preset        set the subtitle options to the indicated preset\n   ```\n\n   当然还有对整个文件进行调整的参数\n\n   ```ssh\n   Per-file main options:\n   -f fmt              force format\n   -c codec            codec name\n   -codec codec        codec name\n   -pre preset         preset name\n   -map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile\n   -t duration         record or transcode \"duration\" seconds of audio/video\n   -to time_stop       record or transcode stop time\n   -fs limit_size      set the limit file size in bytes\n   -ss time_off        set the start time offset\n   -sseof time_off     set the start time offset relative to EOF\n   -seek_timestamp     enable/disable seeking by timestamp with -ss\n   -timestamp time     set the recording timestamp ('now' to set the current time)\n   -metadata string=string  add metadata\n   -program title=string:st=number...  add program with specified streams\n   -target type        specify target file type (\"vcd\", \"svcd\", \"dvd\", \"dv\" or \"dv50\" with optional prefixes \"pal-\", \"ntsc-\" or \"film-\")\n   -apad               audio pad\n   -frames number      set the number of frames to output\n   -filter filter_graph  set stream filtergraph\n   -filter_script filename  read stream filtergraph description from a file\n   -reinit_filter      reinit filtergraph on input parameter changes\n   -discard            discard\n   -disposition        disposition\n   ```\n\n   #### ffmpeg常用的日常命令\n\n   **关于FFmpeg的具体技术及参数细节，可以参考**[**ffmpeg官方文档**](https://ffmpeg.org/documentation.html)**，以下介绍一些常用的ffmpeg命令。**\n   \n   1. H264编码的其他格式转换TS\n   \n      ```shell\n      ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\n      ffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts\n      ```\n   \n      说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。\n   \n      -vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。\n   \n   2. 视频转帧图片\n   \n      ```shell\n      ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png\n      ```\n   \n      将视频中每一帧切出来，可用作测试人脸检测模块。\n   \n      -r：表示帧率，25即每秒25帧来处理帧。\n   \n      -f：表示输出格式，此处为image2格式。\n   \n       ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。\n   \n      批量转图：\n   \n      ```shell\n      find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -r 25 -f image2 ./path/%05d{}.png\n      ```\n   \n   3. 帧图片转视频\n   \n      ```shell\n      ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts\n      ```\n   \n      将连续的帧图片，转制为视频。\n   \n   4. 视频帧率处理\n   \n      ```shell\n      ffmpeg -i input.ts -vcode h264 -r 20 output.ts\n      ```\n   \n      模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。\n   \n   5. 从相机视频流录制ts或mp4格式的视频\n   \n      ```shell\n      ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts\n      ```\n   \n      说明：tcp协议\n   \n   6. 截取视频指令\n   \n      ```shell\n      ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT\n      ```\n   \n      说明：\n   \n      ​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05\n   \n      ​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10\n   \n   7. 合并视频指令\n   \n      ```shell\n      ffmpeg -i \"concat:intermediate1.ts|intermediate2.ts\" -c copy -bsf:a aac_adtstoasc output.ts\n      ```\n   \n   8. 视频旋转\n   \n       ```shell\n      find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -vf \"transpose=1\" -vcodec libx264 -an ./rota/{}\n       ```\n   \n   9. 图片选择\n   \n      ```shell\n      convert example.jpg -rotate 90 example-rotated.jpg\n      ```\n   \n   10. 获取视频文件的帧数\n   \n       ```shell\n       ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2>&1 | grep 'frame='\n       ```\n   \n   [文章参考](https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh) \n   \n   \n\n\n","slug":"ffmpeg简易介绍","published":1,"updated":"2020-03-23T10:05:01.080Z","_id":"ckghk0s0d000nmdym5t2rfl42","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"媒体文件结构\"><a href=\"#媒体文件结构\" class=\"headerlink\" title=\"媒体文件结构\"></a>媒体文件结构</h2><p>一个媒体文件并不像许多人想象的那样，是将媒体内容编码起来直接作为文件的。实际上，它通常是由多个不同种类的媒体流（ Stream ）组成，再以特定的封装格式封装起来的。</p>\n<p>比较常见的媒体流就是视频流跟音频流了，顾名思义，视频流存储的就是视频信息，音频流存储的就是音频信息。一个视频流或者音频流的内容，就是以特定的编码格式所存储的视频或音频信息。</p>\n<p><strong>一个文件的里面的媒体流所采用的编码格式跟这个文件的后缀名并没有完全的必然联系。</strong> <strong>文件的后缀名通常就代表这个文件的封装格式。</strong></p>\n<h2 id=\"ffmpeg-安装\"><a href=\"#ffmpeg-安装\" class=\"headerlink\" title=\"ffmpeg 安装\"></a>ffmpeg 安装</h2><p>自行下载使用系统安装对应的安装包<a href=\"https://ffmpeg.org/download.html\">官网下载</a></p>\n<p>以下使用的平台都为Mac系统下</p>\n<a id=\"more\"></a>\n\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><ol>\n<li><p>打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用</p>\n<pre><code class=\"hljs ssh\">ffmpeg -help</code></pre>\n\n<pre><code class=\"hljs ssh\">ffmpeg version 3.3 Copyright (c) 2000-2017 the FFmpeg developers\n  built with Apple LLVM version 8.1.0 (clang-802.0.41)\n  configuration: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;ffmpeg&#x2F;3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc&#x3D;clang --host-cflags&#x3D; --host-ldflags&#x3D; --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda\n  libavutil      55. 58.100 &#x2F; 55. 58.100\n  libavcodec     57. 89.100 &#x2F; 57. 89.100\n  libavformat    57. 71.100 &#x2F; 57. 71.100\n  libavdevice    57.  6.100 &#x2F; 57.  6.100\n  libavfilter     6. 82.100 &#x2F;  6. 82.100\n  libavresample   3.  5.  0 &#x2F;  3.  5.  0\n  libswscale      4.  6.100 &#x2F;  4.  6.100\n  libswresample   2.  7.100 &#x2F;  2.  7.100\n  libpostproc    54.  5.100 &#x2F; 54.  5.100\nHyper fast Audio and Video encoder\nusage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</code></pre>\n\n<p>重点是关注 usage: ffmpeg [options][[infile options] -i infile]… {[outfile options] outfile}… 这句是说ffmpeg 的主要用法</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>查看ffmpeg 支持的格式</p>\n<p>查看封装格式，包括音频，视频等封装格式</p>\n<pre><code class=\"hljs ssh\">ffmpeg -formats</code></pre>\n\n<p>查看编解码器包括音频，视频等封装格式</p>\n<pre><code class=\"hljs ssh\">ffmpeg -codecs</code></pre>\n</li>\n<li><p>进行格式转换</p>\n<pre><code class=\"hljs ssh\">ffmpeg -i a.mp4 b.mkv</code></pre>\n\n<p>这里是将mp4格式的视频转换成mkv格式。</p>\n<p><strong>注：</strong> 查看默认编码格式，以下的Matroska也就是指 mkv</p>\n<pre><code class=\"hljs code\">ffmpeg -help muxer&#x3D;Matroska\n\n#以下为摘要信息，从中可以看出默认的视频编码为h264,音频编码为ac3,字幕流编码为ass，部分格式视频不支持字幕流\nMuxer matroska [Matroska]:\n    Common extensions: mkv.\n    Mime type: video&#x2F;x-matroska.\n    Default video codec: h264.\n    Default audio codec: ac3.\n    Default subtitle codec: ass.</code></pre>\n</li>\n<li><p>指定编码器进行转换</p>\n<pre><code class=\"hljs sh\">ffmpeg -i a.mp4 -c:v hevc -c:a aac b.mkv</code></pre>\n\n<p><strong>注：</strong> <code>-c:v</code> 可以用<code>-vcodec</code>替换，当它们的值为copy时，就表示编码格式不进行转换</p>\n</li>\n<li><p>在转换时可以进行的调整</p>\n<p>在 <code>ffmpeg -help</code> 时可以看到有一些和音频，视频，字幕相关的选项</p>\n<pre><code class=\"hljs ssh\">Video options:\n-vframes number     set the number of video frames to output\n-r rate             set frame rate (Hz value, fraction or abbreviation)\n-s size             set frame size (WxH or abbreviation)\n-aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\n-bits_per_raw_sample number  set the number of bits per raw sample\n-vn                 disable video\n-vcodec codec       force video codec (&#39;copy&#39; to copy stream)\n-timecode hh:mm:ss[:;.]ff  set initial TimeCode value.\n-pass n             select the pass number (1 to 3)\n-vf filter_graph    set video filters\n-ab bitrate         audio bitrate (please use -b:a)\n-b bitrate          video bitrate (please use -b:v)\n-dn                 disable data\n\nAudio options:\n-aframes number     set the number of audio frames to output\n-aq quality         set audio quality (codec-specific)\n-ar rate            set audio sampling rate (in Hz)\n-ac channels        set number of audio channels\n-an                 disable audio\n-acodec codec       force audio codec (&#39;copy&#39; to copy stream)\n-vol volume         change audio volume (256&#x3D;normal)\n-af filter_graph    set audio filters\n\nSubtitle options:\n-s size             set frame size (WxH or abbreviation)\n-sn                 disable subtitle\n-scodec codec       force subtitle codec (&#39;copy&#39; to copy stream)\n-stag fourcc&#x2F;tag    force subtitle tag&#x2F;fourcc\n-fix_sub_duration   fix subtitles duration\n-canvas_size size   set canvas size (WxH or abbreviation)\n-spre preset        set the subtitle options to the indicated preset</code></pre>\n\n<p>当然还有对整个文件进行调整的参数</p>\n<pre><code class=\"hljs ssh\">Per-file main options:\n-f fmt              force format\n-c codec            codec name\n-codec codec        codec name\n-pre preset         preset name\n-map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile\n-t duration         record or transcode &quot;duration&quot; seconds of audio&#x2F;video\n-to time_stop       record or transcode stop time\n-fs limit_size      set the limit file size in bytes\n-ss time_off        set the start time offset\n-sseof time_off     set the start time offset relative to EOF\n-seek_timestamp     enable&#x2F;disable seeking by timestamp with -ss\n-timestamp time     set the recording timestamp (&#39;now&#39; to set the current time)\n-metadata string&#x3D;string  add metadata\n-program title&#x3D;string:st&#x3D;number...  add program with specified streams\n-target type        specify target file type (&quot;vcd&quot;, &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot; or &quot;dv50&quot; with optional prefixes &quot;pal-&quot;, &quot;ntsc-&quot; or &quot;film-&quot;)\n-apad               audio pad\n-frames number      set the number of frames to output\n-filter filter_graph  set stream filtergraph\n-filter_script filename  read stream filtergraph description from a file\n-reinit_filter      reinit filtergraph on input parameter changes\n-discard            discard\n-disposition        disposition</code></pre>\n\n<h4 id=\"ffmpeg常用的日常命令\"><a href=\"#ffmpeg常用的日常命令\" class=\"headerlink\" title=\"ffmpeg常用的日常命令\"></a>ffmpeg常用的日常命令</h4><p><strong>关于FFmpeg的具体技术及参数细节，可以参考</strong><a href=\"https://ffmpeg.org/documentation.html\"><strong>ffmpeg官方文档</strong></a><strong>，以下介绍一些常用的ffmpeg命令。</strong></p>\n<ol>\n<li><p>H264编码的其他格式转换TS</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\nffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts</code></pre>\n\n<p>说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。</p>\n<p>-vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。</p>\n</li>\n<li><p>视频转帧图片</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png</code></pre>\n\n<p>将视频中每一帧切出来，可用作测试人脸检测模块。</p>\n<p>-r：表示帧率，25即每秒25帧来处理帧。</p>\n<p>-f：表示输出格式，此处为image2格式。</p>\n<p> ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。</p>\n<p>批量转图：</p>\n<pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -r 25 -f image2 ./path/%05d&#123;&#125;.png</code></pre>\n</li>\n<li><p>帧图片转视频</p>\n<pre><code class=\"hljs shell\">ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts</code></pre>\n\n<p>将连续的帧图片，转制为视频。</p>\n</li>\n<li><p>视频帧率处理</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.ts -vcode h264 -r 20 output.ts</code></pre>\n\n<p>模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。</p>\n</li>\n<li><p>从相机视频流录制ts或mp4格式的视频</p>\n<pre><code class=\"hljs shell\">ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts</code></pre>\n\n<p>说明：tcp协议</p>\n</li>\n<li><p>截取视频指令</p>\n<pre><code class=\"hljs shell\">ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT</code></pre>\n\n<p>说明：</p>\n<p>​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05</p>\n<p>​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10</p>\n</li>\n<li><p>合并视频指令</p>\n<pre><code class=\"hljs shell\">ffmpeg -i &quot;concat:intermediate1.ts|intermediate2.ts&quot; -c copy -bsf:a aac_adtstoasc output.ts</code></pre>\n</li>\n<li><p>视频旋转</p>\n <pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -vf &quot;transpose=1&quot; -vcodec libx264 -an ./rota/&#123;&#125;</code></pre>\n</li>\n<li><p>图片选择</p>\n<pre><code class=\"hljs shell\">convert example.jpg -rotate 90 example-rotated.jpg</code></pre>\n</li>\n<li><p>获取视频文件的帧数</p>\n<pre><code class=\"hljs shell\">ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2&gt;&amp;1 | grep &#x27;frame=&#x27;</code></pre>\n\n</li>\n</ol>\n<p><a href=\"https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh\">文章参考</a> </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"媒体文件结构\"><a href=\"#媒体文件结构\" class=\"headerlink\" title=\"媒体文件结构\"></a>媒体文件结构</h2><p>一个媒体文件并不像许多人想象的那样，是将媒体内容编码起来直接作为文件的。实际上，它通常是由多个不同种类的媒体流（ Stream ）组成，再以特定的封装格式封装起来的。</p>\n<p>比较常见的媒体流就是视频流跟音频流了，顾名思义，视频流存储的就是视频信息，音频流存储的就是音频信息。一个视频流或者音频流的内容，就是以特定的编码格式所存储的视频或音频信息。</p>\n<p><strong>一个文件的里面的媒体流所采用的编码格式跟这个文件的后缀名并没有完全的必然联系。</strong> <strong>文件的后缀名通常就代表这个文件的封装格式。</strong></p>\n<h2 id=\"ffmpeg-安装\"><a href=\"#ffmpeg-安装\" class=\"headerlink\" title=\"ffmpeg 安装\"></a>ffmpeg 安装</h2><p>自行下载使用系统安装对应的安装包<a href=\"https://ffmpeg.org/download.html\">官网下载</a></p>\n<p>以下使用的平台都为Mac系统下</p>","more":"<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><ol>\n<li><p>打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用</p>\n<pre><code class=\"hljs ssh\">ffmpeg -help</code></pre>\n\n<pre><code class=\"hljs ssh\">ffmpeg version 3.3 Copyright (c) 2000-2017 the FFmpeg developers\n  built with Apple LLVM version 8.1.0 (clang-802.0.41)\n  configuration: --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;ffmpeg&#x2F;3.3 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc&#x3D;clang --host-cflags&#x3D; --host-ldflags&#x3D; --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --disable-lzma --enable-vda\n  libavutil      55. 58.100 &#x2F; 55. 58.100\n  libavcodec     57. 89.100 &#x2F; 57. 89.100\n  libavformat    57. 71.100 &#x2F; 57. 71.100\n  libavdevice    57.  6.100 &#x2F; 57.  6.100\n  libavfilter     6. 82.100 &#x2F;  6. 82.100\n  libavresample   3.  5.  0 &#x2F;  3.  5.  0\n  libswscale      4.  6.100 &#x2F;  4.  6.100\n  libswresample   2.  7.100 &#x2F;  2.  7.100\n  libpostproc    54.  5.100 &#x2F; 54.  5.100\nHyper fast Audio and Video encoder\nusage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</code></pre>\n\n<p>重点是关注 usage: ffmpeg [options][[infile options] -i infile]… {[outfile options] outfile}… 这句是说ffmpeg 的主要用法</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>查看ffmpeg 支持的格式</p>\n<p>查看封装格式，包括音频，视频等封装格式</p>\n<pre><code class=\"hljs ssh\">ffmpeg -formats</code></pre>\n\n<p>查看编解码器包括音频，视频等封装格式</p>\n<pre><code class=\"hljs ssh\">ffmpeg -codecs</code></pre>\n</li>\n<li><p>进行格式转换</p>\n<pre><code class=\"hljs ssh\">ffmpeg -i a.mp4 b.mkv</code></pre>\n\n<p>这里是将mp4格式的视频转换成mkv格式。</p>\n<p><strong>注：</strong> 查看默认编码格式，以下的Matroska也就是指 mkv</p>\n<pre><code class=\"hljs code\">ffmpeg -help muxer&#x3D;Matroska\n\n#以下为摘要信息，从中可以看出默认的视频编码为h264,音频编码为ac3,字幕流编码为ass，部分格式视频不支持字幕流\nMuxer matroska [Matroska]:\n    Common extensions: mkv.\n    Mime type: video&#x2F;x-matroska.\n    Default video codec: h264.\n    Default audio codec: ac3.\n    Default subtitle codec: ass.</code></pre>\n</li>\n<li><p>指定编码器进行转换</p>\n<pre><code class=\"hljs sh\">ffmpeg -i a.mp4 -c:v hevc -c:a aac b.mkv</code></pre>\n\n<p><strong>注：</strong> <code>-c:v</code> 可以用<code>-vcodec</code>替换，当它们的值为copy时，就表示编码格式不进行转换</p>\n</li>\n<li><p>在转换时可以进行的调整</p>\n<p>在 <code>ffmpeg -help</code> 时可以看到有一些和音频，视频，字幕相关的选项</p>\n<pre><code class=\"hljs ssh\">Video options:\n-vframes number     set the number of video frames to output\n-r rate             set frame rate (Hz value, fraction or abbreviation)\n-s size             set frame size (WxH or abbreviation)\n-aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)\n-bits_per_raw_sample number  set the number of bits per raw sample\n-vn                 disable video\n-vcodec codec       force video codec (&#39;copy&#39; to copy stream)\n-timecode hh:mm:ss[:;.]ff  set initial TimeCode value.\n-pass n             select the pass number (1 to 3)\n-vf filter_graph    set video filters\n-ab bitrate         audio bitrate (please use -b:a)\n-b bitrate          video bitrate (please use -b:v)\n-dn                 disable data\n\nAudio options:\n-aframes number     set the number of audio frames to output\n-aq quality         set audio quality (codec-specific)\n-ar rate            set audio sampling rate (in Hz)\n-ac channels        set number of audio channels\n-an                 disable audio\n-acodec codec       force audio codec (&#39;copy&#39; to copy stream)\n-vol volume         change audio volume (256&#x3D;normal)\n-af filter_graph    set audio filters\n\nSubtitle options:\n-s size             set frame size (WxH or abbreviation)\n-sn                 disable subtitle\n-scodec codec       force subtitle codec (&#39;copy&#39; to copy stream)\n-stag fourcc&#x2F;tag    force subtitle tag&#x2F;fourcc\n-fix_sub_duration   fix subtitles duration\n-canvas_size size   set canvas size (WxH or abbreviation)\n-spre preset        set the subtitle options to the indicated preset</code></pre>\n\n<p>当然还有对整个文件进行调整的参数</p>\n<pre><code class=\"hljs ssh\">Per-file main options:\n-f fmt              force format\n-c codec            codec name\n-codec codec        codec name\n-pre preset         preset name\n-map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile\n-t duration         record or transcode &quot;duration&quot; seconds of audio&#x2F;video\n-to time_stop       record or transcode stop time\n-fs limit_size      set the limit file size in bytes\n-ss time_off        set the start time offset\n-sseof time_off     set the start time offset relative to EOF\n-seek_timestamp     enable&#x2F;disable seeking by timestamp with -ss\n-timestamp time     set the recording timestamp (&#39;now&#39; to set the current time)\n-metadata string&#x3D;string  add metadata\n-program title&#x3D;string:st&#x3D;number...  add program with specified streams\n-target type        specify target file type (&quot;vcd&quot;, &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot; or &quot;dv50&quot; with optional prefixes &quot;pal-&quot;, &quot;ntsc-&quot; or &quot;film-&quot;)\n-apad               audio pad\n-frames number      set the number of frames to output\n-filter filter_graph  set stream filtergraph\n-filter_script filename  read stream filtergraph description from a file\n-reinit_filter      reinit filtergraph on input parameter changes\n-discard            discard\n-disposition        disposition</code></pre>\n\n<h4 id=\"ffmpeg常用的日常命令\"><a href=\"#ffmpeg常用的日常命令\" class=\"headerlink\" title=\"ffmpeg常用的日常命令\"></a>ffmpeg常用的日常命令</h4><p><strong>关于FFmpeg的具体技术及参数细节，可以参考</strong><a href=\"https://ffmpeg.org/documentation.html\"><strong>ffmpeg官方文档</strong></a><strong>，以下介绍一些常用的ffmpeg命令。</strong></p>\n<ol>\n<li><p>H264编码的其他格式转换TS</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\nffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts</code></pre>\n\n<p>说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。</p>\n<p>-vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。</p>\n</li>\n<li><p>视频转帧图片</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png</code></pre>\n\n<p>将视频中每一帧切出来，可用作测试人脸检测模块。</p>\n<p>-r：表示帧率，25即每秒25帧来处理帧。</p>\n<p>-f：表示输出格式，此处为image2格式。</p>\n<p> ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。</p>\n<p>批量转图：</p>\n<pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -r 25 -f image2 ./path/%05d&#123;&#125;.png</code></pre>\n</li>\n<li><p>帧图片转视频</p>\n<pre><code class=\"hljs shell\">ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts</code></pre>\n\n<p>将连续的帧图片，转制为视频。</p>\n</li>\n<li><p>视频帧率处理</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.ts -vcode h264 -r 20 output.ts</code></pre>\n\n<p>模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。</p>\n</li>\n<li><p>从相机视频流录制ts或mp4格式的视频</p>\n<pre><code class=\"hljs shell\">ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts</code></pre>\n\n<p>说明：tcp协议</p>\n</li>\n<li><p>截取视频指令</p>\n<pre><code class=\"hljs shell\">ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT</code></pre>\n\n<p>说明：</p>\n<p>​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05</p>\n<p>​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10</p>\n</li>\n<li><p>合并视频指令</p>\n<pre><code class=\"hljs shell\">ffmpeg -i &quot;concat:intermediate1.ts|intermediate2.ts&quot; -c copy -bsf:a aac_adtstoasc output.ts</code></pre>\n</li>\n<li><p>视频旋转</p>\n <pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -vf &quot;transpose=1&quot; -vcodec libx264 -an ./rota/&#123;&#125;</code></pre>\n</li>\n<li><p>图片选择</p>\n<pre><code class=\"hljs shell\">convert example.jpg -rotate 90 example-rotated.jpg</code></pre>\n</li>\n<li><p>获取视频文件的帧数</p>\n<pre><code class=\"hljs shell\">ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2&gt;&amp;1 | grep &#x27;frame=&#x27;</code></pre>\n\n</li>\n</ol>\n<p><a href=\"https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh\">文章参考</a> </p>\n</li>\n</ol>"},{"title":"iterm,tmux,vim 的常用快捷键","date":"2017-06-02T05:52:12.000Z","_content":"\n上一篇博客我们搭建了Mac下流畅的终端使用环境，这篇博客我们讲一些常用的快捷键来提高开发效率。废话不多说我们开始吧\n\n\n\n## iterm2 快捷\n\n通常我们在使用时，一个窗口总是感觉不够用，这时我们就需要多窗口，或者一个窗口需要多个屏。打开Iterm2，我们按下`command + t`，来新建窗口，通过`commmand + w`来关闭当前窗口，如果我们想要切换不同的窗口时，我们可以通过`command + 方向键` 或者`command +  数字`来切换窗口。`command + q` 退出应用程序\n\n**注：** `command + t`或者`command + w`或者`command +q` 在很多应用都是通用的,比如在chrom 上，这几个快捷键，分别表示新建tab页，关闭tab页，推出chrom。但是chrom 切换tab是使用`command + option +方向键` 这个就和iterm2有区别了。\n\n\n\n在链接远程服务器时，我需要在同一窗口，查看不同服务器的状态，或者其他的一些信息。多窗口去查看就太麻烦 了。iterm 的分屏就能满足你的需要了。iterm2在分屏时，可以进行横向分屏和纵向分屏。纵向分屏使用`command + d`横向分屏使用`command + shift +d`，关闭当前分屏的快捷键也是使用`command + w`，切换各个分屏使用的是`command + option + 方向键`，以下是效果图\n\n<!-- more -->\n\n![](https://cocoon-break.github.io/images/screenShot/iterm2_keymap.jpg)\n\n\n\n接下来就是在输入的时候，我们需要快速回到行首使用`ctrl + a`，快速回到行末使用`ctrl + e`，输入失误就需要删除错误了，`ctrl + u`是将当前行清空，使用 `ctrl + w`,删除光标之前的单词，使用 `ctrl + h`删除光标之前所有字符，使用`ctrl + k` 删除光标之后的所有字符。\n\n\n\n总结下 ：\n\n- 窗口和屏相关\n  - 新建窗口：command + t\n  - 关闭窗口或者分屏：command + w\n  - 切换标签：command +  左右方向键\n  - 切换全屏：command + enter\n  - 水平分屏：command + shift + d \n  - 垂直分屏：command + d \n  - 切换分屏：command + option + 方向键\n- 编辑相关\n  - 清除当前行：ctrl + u\n  - 删除光标之前的字符：ctrl + h\n  - 删除光标之前的单词：ctrl + w\n  - 删除光标到文本末尾：ctrl + k\n  - 到行首： ctrl + a\n  - 到行末：ctrl + e\n\n\n\n## tmux 快捷键\n\n 打开iterm2 输入`tmux` 就进入了tmux的交互模式了，tmux 也有窗口和屏的概念这里就不再说明了。直接进入主题，快捷键的使用。\n\n在使用任何功能时我们都得先按下`ctrl + b` 然后**松开**，接着按下其他的键，比如我要新建一个窗口，先按下`ctrl + b`  然后在按下`c`,  这就完成了窗口的新建。\n\n- 快捷键都是先按下`ctrl + b`然后在按一下键\n  - c\t\t新建窗口\n  - &             关闭当前窗口\n  - p              切换至上一个窗口\n  - n              切换至下一个窗口\n  - %              将当前窗口纵向分屏\n  - \"                将当前窗口横向分屏\n  - 方向键      在多个分屏中切换\n  - d                脱离当前tmux，在输入tmux attach 就能重新进入\n  - z                使当前屏占满全屏，在次按下则恢复之前屏样式\n  - x                关闭当前屏\n  - alt + 方向键   调整当前屏大小\n\n这里只将一些基础的快捷键，更多快捷键和配置，请自行谷歌，百度，以下为tmux  分屏之后的效果图\n\n![](https://cocoon-break.github.io/images/screenShot/iterm2_tmux_keymap.jpg)\n\n\n\n## vim 快捷键\n\nvim 的功能很强大，这里也不会深入讲解介绍，只是收集了一些快捷键，以便提供一些效率。\n\n- 查找\n  - 从光标处向下搜索：/ + 要查找的词\n  - 从光标处向上搜索：? + 要查找的词\n  - 快速回到页首：{\n  - 去页尾：}\n  - 回行首：shift + ^\n  - 回行末：shift + $\n- 编辑\n  - 删除光标出的字母：x\n  - 删除光标所在行：dd\n  - 删除单词包括空格：dw\n  - 回撤上一次编辑：u \n  - 取消撤回功能(对u功取消)：control + r\n  - 复制光标所在行：yy\n  - 复制n(数字)行：nyy\n  - 复制单词：yw\n  - 复制n个单词：nyw\n  - 复制光标所在位置到行末：y$\n  - 复制光标所在位置到行首：y^\n  - 粘贴：p\n\n更多vim 操作快捷键：[vim快捷键](http://www.lcode.cc/2017/04/10/vim-shortcut-key.html)\n\n这篇博客只是收集和介绍一些基础简单的快捷键，并没有很深入的去使用iterm2 ，tmux，vim，这些功能都很强大，想继续深入的同学可以去查查资料。","source":"_posts/iterm,tmux,vim的常用快捷键.md","raw":"---\ntitle: iterm,tmux,vim 的常用快捷键\ndate: 2017-06-02 13:52:12\ntags: \n- 开发效率\ncategories:\n- 开发效率\n---\n\n上一篇博客我们搭建了Mac下流畅的终端使用环境，这篇博客我们讲一些常用的快捷键来提高开发效率。废话不多说我们开始吧\n\n\n\n## iterm2 快捷\n\n通常我们在使用时，一个窗口总是感觉不够用，这时我们就需要多窗口，或者一个窗口需要多个屏。打开Iterm2，我们按下`command + t`，来新建窗口，通过`commmand + w`来关闭当前窗口，如果我们想要切换不同的窗口时，我们可以通过`command + 方向键` 或者`command +  数字`来切换窗口。`command + q` 退出应用程序\n\n**注：** `command + t`或者`command + w`或者`command +q` 在很多应用都是通用的,比如在chrom 上，这几个快捷键，分别表示新建tab页，关闭tab页，推出chrom。但是chrom 切换tab是使用`command + option +方向键` 这个就和iterm2有区别了。\n\n\n\n在链接远程服务器时，我需要在同一窗口，查看不同服务器的状态，或者其他的一些信息。多窗口去查看就太麻烦 了。iterm 的分屏就能满足你的需要了。iterm2在分屏时，可以进行横向分屏和纵向分屏。纵向分屏使用`command + d`横向分屏使用`command + shift +d`，关闭当前分屏的快捷键也是使用`command + w`，切换各个分屏使用的是`command + option + 方向键`，以下是效果图\n\n<!-- more -->\n\n![](https://cocoon-break.github.io/images/screenShot/iterm2_keymap.jpg)\n\n\n\n接下来就是在输入的时候，我们需要快速回到行首使用`ctrl + a`，快速回到行末使用`ctrl + e`，输入失误就需要删除错误了，`ctrl + u`是将当前行清空，使用 `ctrl + w`,删除光标之前的单词，使用 `ctrl + h`删除光标之前所有字符，使用`ctrl + k` 删除光标之后的所有字符。\n\n\n\n总结下 ：\n\n- 窗口和屏相关\n  - 新建窗口：command + t\n  - 关闭窗口或者分屏：command + w\n  - 切换标签：command +  左右方向键\n  - 切换全屏：command + enter\n  - 水平分屏：command + shift + d \n  - 垂直分屏：command + d \n  - 切换分屏：command + option + 方向键\n- 编辑相关\n  - 清除当前行：ctrl + u\n  - 删除光标之前的字符：ctrl + h\n  - 删除光标之前的单词：ctrl + w\n  - 删除光标到文本末尾：ctrl + k\n  - 到行首： ctrl + a\n  - 到行末：ctrl + e\n\n\n\n## tmux 快捷键\n\n 打开iterm2 输入`tmux` 就进入了tmux的交互模式了，tmux 也有窗口和屏的概念这里就不再说明了。直接进入主题，快捷键的使用。\n\n在使用任何功能时我们都得先按下`ctrl + b` 然后**松开**，接着按下其他的键，比如我要新建一个窗口，先按下`ctrl + b`  然后在按下`c`,  这就完成了窗口的新建。\n\n- 快捷键都是先按下`ctrl + b`然后在按一下键\n  - c\t\t新建窗口\n  - &             关闭当前窗口\n  - p              切换至上一个窗口\n  - n              切换至下一个窗口\n  - %              将当前窗口纵向分屏\n  - \"                将当前窗口横向分屏\n  - 方向键      在多个分屏中切换\n  - d                脱离当前tmux，在输入tmux attach 就能重新进入\n  - z                使当前屏占满全屏，在次按下则恢复之前屏样式\n  - x                关闭当前屏\n  - alt + 方向键   调整当前屏大小\n\n这里只将一些基础的快捷键，更多快捷键和配置，请自行谷歌，百度，以下为tmux  分屏之后的效果图\n\n![](https://cocoon-break.github.io/images/screenShot/iterm2_tmux_keymap.jpg)\n\n\n\n## vim 快捷键\n\nvim 的功能很强大，这里也不会深入讲解介绍，只是收集了一些快捷键，以便提供一些效率。\n\n- 查找\n  - 从光标处向下搜索：/ + 要查找的词\n  - 从光标处向上搜索：? + 要查找的词\n  - 快速回到页首：{\n  - 去页尾：}\n  - 回行首：shift + ^\n  - 回行末：shift + $\n- 编辑\n  - 删除光标出的字母：x\n  - 删除光标所在行：dd\n  - 删除单词包括空格：dw\n  - 回撤上一次编辑：u \n  - 取消撤回功能(对u功取消)：control + r\n  - 复制光标所在行：yy\n  - 复制n(数字)行：nyy\n  - 复制单词：yw\n  - 复制n个单词：nyw\n  - 复制光标所在位置到行末：y$\n  - 复制光标所在位置到行首：y^\n  - 粘贴：p\n\n更多vim 操作快捷键：[vim快捷键](http://www.lcode.cc/2017/04/10/vim-shortcut-key.html)\n\n这篇博客只是收集和介绍一些基础简单的快捷键，并没有很深入的去使用iterm2 ，tmux，vim，这些功能都很强大，想继续深入的同学可以去查查资料。","slug":"iterm,tmux,vim的常用快捷键","published":1,"updated":"2020-02-27T03:41:58.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0e000pmdymgeg4frcz","content":"<p>上一篇博客我们搭建了Mac下流畅的终端使用环境，这篇博客我们讲一些常用的快捷键来提高开发效率。废话不多说我们开始吧</p>\n<h2 id=\"iterm2-快捷\"><a href=\"#iterm2-快捷\" class=\"headerlink\" title=\"iterm2 快捷\"></a>iterm2 快捷</h2><p>通常我们在使用时，一个窗口总是感觉不够用，这时我们就需要多窗口，或者一个窗口需要多个屏。打开Iterm2，我们按下<code>command + t</code>，来新建窗口，通过<code>commmand + w</code>来关闭当前窗口，如果我们想要切换不同的窗口时，我们可以通过<code>command + 方向键</code> 或者<code>command +  数字</code>来切换窗口。<code>command + q</code> 退出应用程序</p>\n<p><strong>注：</strong> <code>command + t</code>或者<code>command + w</code>或者<code>command +q</code> 在很多应用都是通用的,比如在chrom 上，这几个快捷键，分别表示新建tab页，关闭tab页，推出chrom。但是chrom 切换tab是使用<code>command + option +方向键</code> 这个就和iterm2有区别了。</p>\n<p>在链接远程服务器时，我需要在同一窗口，查看不同服务器的状态，或者其他的一些信息。多窗口去查看就太麻烦 了。iterm 的分屏就能满足你的需要了。iterm2在分屏时，可以进行横向分屏和纵向分屏。纵向分屏使用<code>command + d</code>横向分屏使用<code>command + shift +d</code>，关闭当前分屏的快捷键也是使用<code>command + w</code>，切换各个分屏使用的是<code>command + option + 方向键</code>，以下是效果图</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://cocoon-break.github.io/images/screenShot/iterm2_keymap.jpg\"></p>\n<p>接下来就是在输入的时候，我们需要快速回到行首使用<code>ctrl + a</code>，快速回到行末使用<code>ctrl + e</code>，输入失误就需要删除错误了，<code>ctrl + u</code>是将当前行清空，使用 <code>ctrl + w</code>,删除光标之前的单词，使用 <code>ctrl + h</code>删除光标之前所有字符，使用<code>ctrl + k</code> 删除光标之后的所有字符。</p>\n<p>总结下 ：</p>\n<ul>\n<li>窗口和屏相关<ul>\n<li>新建窗口：command + t</li>\n<li>关闭窗口或者分屏：command + w</li>\n<li>切换标签：command +  左右方向键</li>\n<li>切换全屏：command + enter</li>\n<li>水平分屏：command + shift + d </li>\n<li>垂直分屏：command + d </li>\n<li>切换分屏：command + option + 方向键</li>\n</ul>\n</li>\n<li>编辑相关<ul>\n<li>清除当前行：ctrl + u</li>\n<li>删除光标之前的字符：ctrl + h</li>\n<li>删除光标之前的单词：ctrl + w</li>\n<li>删除光标到文本末尾：ctrl + k</li>\n<li>到行首： ctrl + a</li>\n<li>到行末：ctrl + e</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"tmux-快捷键\"><a href=\"#tmux-快捷键\" class=\"headerlink\" title=\"tmux 快捷键\"></a>tmux 快捷键</h2><p> 打开iterm2 输入<code>tmux</code> 就进入了tmux的交互模式了，tmux 也有窗口和屏的概念这里就不再说明了。直接进入主题，快捷键的使用。</p>\n<p>在使用任何功能时我们都得先按下<code>ctrl + b</code> 然后<strong>松开</strong>，接着按下其他的键，比如我要新建一个窗口，先按下<code>ctrl + b</code>  然后在按下<code>c</code>,  这就完成了窗口的新建。</p>\n<ul>\n<li>快捷键都是先按下<code>ctrl + b</code>然后在按一下键<ul>\n<li>c        新建窗口</li>\n<li>&amp;             关闭当前窗口</li>\n<li>p              切换至上一个窗口</li>\n<li>n              切换至下一个窗口</li>\n<li>%              将当前窗口纵向分屏</li>\n<li>“                将当前窗口横向分屏</li>\n<li>方向键      在多个分屏中切换</li>\n<li>d                脱离当前tmux，在输入tmux attach 就能重新进入</li>\n<li>z                使当前屏占满全屏，在次按下则恢复之前屏样式</li>\n<li>x                关闭当前屏</li>\n<li>alt + 方向键   调整当前屏大小</li>\n</ul>\n</li>\n</ul>\n<p>这里只将一些基础的快捷键，更多快捷键和配置，请自行谷歌，百度，以下为tmux  分屏之后的效果图</p>\n<p><img src=\"https://cocoon-break.github.io/images/screenShot/iterm2_tmux_keymap.jpg\"></p>\n<h2 id=\"vim-快捷键\"><a href=\"#vim-快捷键\" class=\"headerlink\" title=\"vim 快捷键\"></a>vim 快捷键</h2><p>vim 的功能很强大，这里也不会深入讲解介绍，只是收集了一些快捷键，以便提供一些效率。</p>\n<ul>\n<li>查找<ul>\n<li>从光标处向下搜索：/ + 要查找的词</li>\n<li>从光标处向上搜索：? + 要查找的词</li>\n<li>快速回到页首：{</li>\n<li>去页尾：}</li>\n<li>回行首：shift + ^</li>\n<li>回行末：shift + $</li>\n</ul>\n</li>\n<li>编辑<ul>\n<li>删除光标出的字母：x</li>\n<li>删除光标所在行：dd</li>\n<li>删除单词包括空格：dw</li>\n<li>回撤上一次编辑：u </li>\n<li>取消撤回功能(对u功取消)：control + r</li>\n<li>复制光标所在行：yy</li>\n<li>复制n(数字)行：nyy</li>\n<li>复制单词：yw</li>\n<li>复制n个单词：nyw</li>\n<li>复制光标所在位置到行末：y$</li>\n<li>复制光标所在位置到行首：y^</li>\n<li>粘贴：p</li>\n</ul>\n</li>\n</ul>\n<p>更多vim 操作快捷键：<a href=\"http://www.lcode.cc/2017/04/10/vim-shortcut-key.html\">vim快捷键</a></p>\n<p>这篇博客只是收集和介绍一些基础简单的快捷键，并没有很深入的去使用iterm2 ，tmux，vim，这些功能都很强大，想继续深入的同学可以去查查资料。</p>\n","site":{"data":{}},"excerpt":"<p>上一篇博客我们搭建了Mac下流畅的终端使用环境，这篇博客我们讲一些常用的快捷键来提高开发效率。废话不多说我们开始吧</p>\n<h2 id=\"iterm2-快捷\"><a href=\"#iterm2-快捷\" class=\"headerlink\" title=\"iterm2 快捷\"></a>iterm2 快捷</h2><p>通常我们在使用时，一个窗口总是感觉不够用，这时我们就需要多窗口，或者一个窗口需要多个屏。打开Iterm2，我们按下<code>command + t</code>，来新建窗口，通过<code>commmand + w</code>来关闭当前窗口，如果我们想要切换不同的窗口时，我们可以通过<code>command + 方向键</code> 或者<code>command +  数字</code>来切换窗口。<code>command + q</code> 退出应用程序</p>\n<p><strong>注：</strong> <code>command + t</code>或者<code>command + w</code>或者<code>command +q</code> 在很多应用都是通用的,比如在chrom 上，这几个快捷键，分别表示新建tab页，关闭tab页，推出chrom。但是chrom 切换tab是使用<code>command + option +方向键</code> 这个就和iterm2有区别了。</p>\n<p>在链接远程服务器时，我需要在同一窗口，查看不同服务器的状态，或者其他的一些信息。多窗口去查看就太麻烦 了。iterm 的分屏就能满足你的需要了。iterm2在分屏时，可以进行横向分屏和纵向分屏。纵向分屏使用<code>command + d</code>横向分屏使用<code>command + shift +d</code>，关闭当前分屏的快捷键也是使用<code>command + w</code>，切换各个分屏使用的是<code>command + option + 方向键</code>，以下是效果图</p>","more":"<p><img src=\"https://cocoon-break.github.io/images/screenShot/iterm2_keymap.jpg\"></p>\n<p>接下来就是在输入的时候，我们需要快速回到行首使用<code>ctrl + a</code>，快速回到行末使用<code>ctrl + e</code>，输入失误就需要删除错误了，<code>ctrl + u</code>是将当前行清空，使用 <code>ctrl + w</code>,删除光标之前的单词，使用 <code>ctrl + h</code>删除光标之前所有字符，使用<code>ctrl + k</code> 删除光标之后的所有字符。</p>\n<p>总结下 ：</p>\n<ul>\n<li>窗口和屏相关<ul>\n<li>新建窗口：command + t</li>\n<li>关闭窗口或者分屏：command + w</li>\n<li>切换标签：command +  左右方向键</li>\n<li>切换全屏：command + enter</li>\n<li>水平分屏：command + shift + d </li>\n<li>垂直分屏：command + d </li>\n<li>切换分屏：command + option + 方向键</li>\n</ul>\n</li>\n<li>编辑相关<ul>\n<li>清除当前行：ctrl + u</li>\n<li>删除光标之前的字符：ctrl + h</li>\n<li>删除光标之前的单词：ctrl + w</li>\n<li>删除光标到文本末尾：ctrl + k</li>\n<li>到行首： ctrl + a</li>\n<li>到行末：ctrl + e</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"tmux-快捷键\"><a href=\"#tmux-快捷键\" class=\"headerlink\" title=\"tmux 快捷键\"></a>tmux 快捷键</h2><p> 打开iterm2 输入<code>tmux</code> 就进入了tmux的交互模式了，tmux 也有窗口和屏的概念这里就不再说明了。直接进入主题，快捷键的使用。</p>\n<p>在使用任何功能时我们都得先按下<code>ctrl + b</code> 然后<strong>松开</strong>，接着按下其他的键，比如我要新建一个窗口，先按下<code>ctrl + b</code>  然后在按下<code>c</code>,  这就完成了窗口的新建。</p>\n<ul>\n<li>快捷键都是先按下<code>ctrl + b</code>然后在按一下键<ul>\n<li>c        新建窗口</li>\n<li>&amp;             关闭当前窗口</li>\n<li>p              切换至上一个窗口</li>\n<li>n              切换至下一个窗口</li>\n<li>%              将当前窗口纵向分屏</li>\n<li>“                将当前窗口横向分屏</li>\n<li>方向键      在多个分屏中切换</li>\n<li>d                脱离当前tmux，在输入tmux attach 就能重新进入</li>\n<li>z                使当前屏占满全屏，在次按下则恢复之前屏样式</li>\n<li>x                关闭当前屏</li>\n<li>alt + 方向键   调整当前屏大小</li>\n</ul>\n</li>\n</ul>\n<p>这里只将一些基础的快捷键，更多快捷键和配置，请自行谷歌，百度，以下为tmux  分屏之后的效果图</p>\n<p><img src=\"https://cocoon-break.github.io/images/screenShot/iterm2_tmux_keymap.jpg\"></p>\n<h2 id=\"vim-快捷键\"><a href=\"#vim-快捷键\" class=\"headerlink\" title=\"vim 快捷键\"></a>vim 快捷键</h2><p>vim 的功能很强大，这里也不会深入讲解介绍，只是收集了一些快捷键，以便提供一些效率。</p>\n<ul>\n<li>查找<ul>\n<li>从光标处向下搜索：/ + 要查找的词</li>\n<li>从光标处向上搜索：? + 要查找的词</li>\n<li>快速回到页首：{</li>\n<li>去页尾：}</li>\n<li>回行首：shift + ^</li>\n<li>回行末：shift + $</li>\n</ul>\n</li>\n<li>编辑<ul>\n<li>删除光标出的字母：x</li>\n<li>删除光标所在行：dd</li>\n<li>删除单词包括空格：dw</li>\n<li>回撤上一次编辑：u </li>\n<li>取消撤回功能(对u功取消)：control + r</li>\n<li>复制光标所在行：yy</li>\n<li>复制n(数字)行：nyy</li>\n<li>复制单词：yw</li>\n<li>复制n个单词：nyw</li>\n<li>复制光标所在位置到行末：y$</li>\n<li>复制光标所在位置到行首：y^</li>\n<li>粘贴：p</li>\n</ul>\n</li>\n</ul>\n<p>更多vim 操作快捷键：<a href=\"http://www.lcode.cc/2017/04/10/vim-shortcut-key.html\">vim快捷键</a></p>\n<p>这篇博客只是收集和介绍一些基础简单的快捷键，并没有很深入的去使用iterm2 ，tmux，vim，这些功能都很强大，想继续深入的同学可以去查查资料。</p>"},{"title":"golang 之 slice & defer 关键字","date":"2018-09-10T11:53:22.000Z","index_img":["/images/golang/logo.jpg"],"_content":"\n今天我们讲讲golang的slice和defer。\n\nslice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。\n\n在正式开始讲slice之前我们来说一说golang 中的`defer`，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？\n\n```go\npackage main\nimport \"fmt\"\nfunc f() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\nfunc f2() (r int) {\n\tt := 5\n\tdefer func() {\n\t\tt = t + 5\n\t}()\n\treturn t\n}\nfunc f3() (r int) {\n\tdefer func(r int) {\n\t\tr = r + 5\n\t}(r)\n\treturn 1\n}\n\nfunc main() {\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n}\n```\n\n答案留在最后讲解\n\n### slice\n\n#### 数组\n\n在说slice之前，我们先来了解下数组。\n\n数组是指定长度和元素类型的数据集合。比如以下数组\n\n```go\nvar intArr [3]int//创建了长度为3的int数组\na[0]=1 //根据索引访问元素\nfmt.println(a[1])//int 类型数组默认值为0\n```\n\n数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。\n\n#### slice\n\n在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义\n\n```go\ntype slice struct {\n\tarray unsafe.Pointer// 指向底层数组的指针\n\tlen   int// 长度，切片可用元素的个数，slice的下标不能超过长度 \n\tcap   int// 容量 >= 长度，在底层不扩容的情况下，cap是len的最大限度\n}\n```\n\n需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。\n\n##### slice的扩容\n\n在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的\n\n```go\n// growslice handles slice growth during append.\n// It is passed the slice element type, the old slice, and the desired new minimum capacity,\n// and it returns a new slice with at least that capacity, with the old data\n// copied into it.\n// The new slice's length is set to the old slice's length,\n// NOT to the new requested capacity.\n// This is for codegen convenience. The old slice's length is used immediately\n// to calculate where to write new values during an append.\n// TODO: When the old backend is gone, reconsider this decision.\n// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.\nfunc growslice(et *_type, old slice, cap int) slice {\n\t//忽略部分源码\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\t// Check 0 < newcap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// Set newcap to the requested cap when\n\t\t\t// the newcap calculation overflowed.\n\t\t\tif newcap <= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n//忽略部分源码\n\treturn slice{p, old.len, newcap}\n}\n```\n\n当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是\n\n- 如果新的大小是当前大小2倍以上，则大小增长为新大小\n- 如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。\n\n扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 `growslice` 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。\n\n##### nil slice 和空slice\n\nnil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。\n\n而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。\n\nnil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 `nil` 切片。\n\n| 创建方式  | nil切片              | 空切片                  |\n| --------- | -------------------- | ----------------------- |\n| 方式一    | var s1 []int         | var s2 = []int{}        |\n| 方式二    | var s4 = *new([]int) | var s3 = make([]int, 0) |\n| 长度      | 0                    | 0                       |\n| 容量      | 0                    | 0                       |\n| 和nil比较 | true                 | false                   |\n\n#### slice 和unsafe.Pointer相互转换\n\n在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。\n\n我们先来看看从slice中获取一块内存地址\n\n```go\nslice:=make([]int,10)\nptr:=unsafe.Pointer(&slice[0])//获取数组中第一个元素的内存地址\n```\n\n从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式\n\n第一种，先将`ptr`强制类型转换为另一种指针，一个指向`[1<<10]int`数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是`s`就是一个10个元素的slice。\n\n```go\nvar ptr unsafe.Pointer\ns := ((*[1<<10]int)(ptr))[:10]\n```\n\n第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1<<10意思是相同的\n\n```go\nvar ptr unsafe.Pointer\nvar s1 = struct {\n    addr uintptr\n    len int\n    cap int\n}{ptr, length, length}\ns := *(*[]byte)(unsafe.Pointer(&s1))\n```\n\n第三种方法，通过reflect.SliceHeader的方式来构造slice。\n\n```go\nvar o []byte\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = uintptr(ptr)\n```\n\n### defer\n\n不知道你是否得出文章开始代码的正确结果呢？\n\n `defer` 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解**return xxx这一条语句并不是一条原子指令!**\n\n函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。\n\ndefer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。\n\n其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:\n\n```shell\n返回值 = xxx\n调用defer函数\n空的return\n```\n\n 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码\n\n```go\nfunc f() (result int) {\n\tresult = 0 //return语句不是一条原子调用，return xxx其实是赋值＋ret指令\n\tfunc() { //defer被插入到return之前执行，也就是赋返回值和ret指令之间\n\t\tresult++\n\t}()\n\treturn\n}\nfunc f2() (r int) {\n\tt := 5\n\tr = t //赋值指令\n\tfunc() { //defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过\n\t\tt = t + 5\n\t}()\n\treturn //空的return指令\n}\nfunc f3() (r int) {\n\tr = 1 //给返回值赋值\n\tfunc(r int) { //这里改的r是传值传进去的r，不会改变要返回的那个r值\n\t\tr = r + 5\n\t}(r)\n\treturn //空的return\n}\n```\n\n接下来我们来看看另外一小段代码\n\n```go\nfunc main(){\n  startedAt := time.Now()\n\tdefer fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n}\n//输出结果并不是1s，而是几百纳秒\n```\n\n上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 `defer` 关键字会立刻对函数中引用的外部参数进行拷贝，所以 `time.Since(startedAt)` 的结果不是在 `main` 函数退出之前计算的，而是在 `defer` 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下`defer` 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。\n\n\n\n参考：[深入解析go中slice底层实现](https://halfrost.com/go_slice/)\n\n[深度解析Go语音之slice](https://www.cnblogs.com/qcrao-2018/p/10631989.html)\n\n[深入解析Go](https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html)\n\n","source":"_posts/golang之slice and map.md","raw":"---\ntitle: golang 之 slice & defer 关键字\ndate: 2018-09-10 19:53:22\nindex_img:\n- /images/golang/logo.jpg\ntags: \n- golang\ncategories:\n- golang\n---\n\n今天我们讲讲golang的slice和defer。\n\nslice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。\n\n在正式开始讲slice之前我们来说一说golang 中的`defer`，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？\n\n```go\npackage main\nimport \"fmt\"\nfunc f() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\nfunc f2() (r int) {\n\tt := 5\n\tdefer func() {\n\t\tt = t + 5\n\t}()\n\treturn t\n}\nfunc f3() (r int) {\n\tdefer func(r int) {\n\t\tr = r + 5\n\t}(r)\n\treturn 1\n}\n\nfunc main() {\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n}\n```\n\n答案留在最后讲解\n\n### slice\n\n#### 数组\n\n在说slice之前，我们先来了解下数组。\n\n数组是指定长度和元素类型的数据集合。比如以下数组\n\n```go\nvar intArr [3]int//创建了长度为3的int数组\na[0]=1 //根据索引访问元素\nfmt.println(a[1])//int 类型数组默认值为0\n```\n\n数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。\n\n#### slice\n\n在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义\n\n```go\ntype slice struct {\n\tarray unsafe.Pointer// 指向底层数组的指针\n\tlen   int// 长度，切片可用元素的个数，slice的下标不能超过长度 \n\tcap   int// 容量 >= 长度，在底层不扩容的情况下，cap是len的最大限度\n}\n```\n\n需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。\n\n##### slice的扩容\n\n在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的\n\n```go\n// growslice handles slice growth during append.\n// It is passed the slice element type, the old slice, and the desired new minimum capacity,\n// and it returns a new slice with at least that capacity, with the old data\n// copied into it.\n// The new slice's length is set to the old slice's length,\n// NOT to the new requested capacity.\n// This is for codegen convenience. The old slice's length is used immediately\n// to calculate where to write new values during an append.\n// TODO: When the old backend is gone, reconsider this decision.\n// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.\nfunc growslice(et *_type, old slice, cap int) slice {\n\t//忽略部分源码\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\t// Check 0 < newcap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// Set newcap to the requested cap when\n\t\t\t// the newcap calculation overflowed.\n\t\t\tif newcap <= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n//忽略部分源码\n\treturn slice{p, old.len, newcap}\n}\n```\n\n当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是\n\n- 如果新的大小是当前大小2倍以上，则大小增长为新大小\n- 如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。\n\n扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 `growslice` 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。\n\n##### nil slice 和空slice\n\nnil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。\n\n而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。\n\nnil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 `nil` 切片。\n\n| 创建方式  | nil切片              | 空切片                  |\n| --------- | -------------------- | ----------------------- |\n| 方式一    | var s1 []int         | var s2 = []int{}        |\n| 方式二    | var s4 = *new([]int) | var s3 = make([]int, 0) |\n| 长度      | 0                    | 0                       |\n| 容量      | 0                    | 0                       |\n| 和nil比较 | true                 | false                   |\n\n#### slice 和unsafe.Pointer相互转换\n\n在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。\n\n我们先来看看从slice中获取一块内存地址\n\n```go\nslice:=make([]int,10)\nptr:=unsafe.Pointer(&slice[0])//获取数组中第一个元素的内存地址\n```\n\n从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式\n\n第一种，先将`ptr`强制类型转换为另一种指针，一个指向`[1<<10]int`数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是`s`就是一个10个元素的slice。\n\n```go\nvar ptr unsafe.Pointer\ns := ((*[1<<10]int)(ptr))[:10]\n```\n\n第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1<<10意思是相同的\n\n```go\nvar ptr unsafe.Pointer\nvar s1 = struct {\n    addr uintptr\n    len int\n    cap int\n}{ptr, length, length}\ns := *(*[]byte)(unsafe.Pointer(&s1))\n```\n\n第三种方法，通过reflect.SliceHeader的方式来构造slice。\n\n```go\nvar o []byte\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = uintptr(ptr)\n```\n\n### defer\n\n不知道你是否得出文章开始代码的正确结果呢？\n\n `defer` 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解**return xxx这一条语句并不是一条原子指令!**\n\n函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。\n\ndefer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。\n\n其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:\n\n```shell\n返回值 = xxx\n调用defer函数\n空的return\n```\n\n 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码\n\n```go\nfunc f() (result int) {\n\tresult = 0 //return语句不是一条原子调用，return xxx其实是赋值＋ret指令\n\tfunc() { //defer被插入到return之前执行，也就是赋返回值和ret指令之间\n\t\tresult++\n\t}()\n\treturn\n}\nfunc f2() (r int) {\n\tt := 5\n\tr = t //赋值指令\n\tfunc() { //defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过\n\t\tt = t + 5\n\t}()\n\treturn //空的return指令\n}\nfunc f3() (r int) {\n\tr = 1 //给返回值赋值\n\tfunc(r int) { //这里改的r是传值传进去的r，不会改变要返回的那个r值\n\t\tr = r + 5\n\t}(r)\n\treturn //空的return\n}\n```\n\n接下来我们来看看另外一小段代码\n\n```go\nfunc main(){\n  startedAt := time.Now()\n\tdefer fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n}\n//输出结果并不是1s，而是几百纳秒\n```\n\n上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 `defer` 关键字会立刻对函数中引用的外部参数进行拷贝，所以 `time.Since(startedAt)` 的结果不是在 `main` 函数退出之前计算的，而是在 `defer` 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下`defer` 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。\n\n\n\n参考：[深入解析go中slice底层实现](https://halfrost.com/go_slice/)\n\n[深度解析Go语音之slice](https://www.cnblogs.com/qcrao-2018/p/10631989.html)\n\n[深入解析Go](https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html)\n\n","slug":"golang之slice and map","published":1,"updated":"2020-03-26T06:12:13.150Z","_id":"ckghk0s0g000umdyma01a1i38","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天我们讲讲golang的slice和defer。</p>\n<p>slice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。</p>\n<p>在正式开始讲slice之前我们来说一说golang 中的<code>defer</code>，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> t\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n&#125;</code></pre>\n\n<p>答案留在最后讲解</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>在说slice之前，我们先来了解下数组。</p>\n<p>数组是指定长度和元素类型的数据集合。比如以下数组</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> intArr [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">//创建了长度为3的int数组</span>\na[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//根据索引访问元素</span>\nfmt.<span class=\"hljs-built_in\">println</span>(a[<span class=\"hljs-number\">1</span>])<span class=\"hljs-comment\">//int 类型数组默认值为0</span></code></pre>\n\n<p>数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。</p>\n<h4 id=\"slice-1\"><a href=\"#slice-1\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p>在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> slice <span class=\"hljs-keyword\">struct</span> &#123;\n\tarray unsafe.Pointer<span class=\"hljs-comment\">// 指向底层数组的指针</span>\n\t<span class=\"hljs-built_in\">len</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 长度，切片可用元素的个数，slice的下标不能超过长度 </span>\n\t<span class=\"hljs-built_in\">cap</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 容量 &gt;= 长度，在底层不扩容的情况下，cap是len的最大限度</span>\n&#125;</code></pre>\n\n<p>需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。</p>\n<h5 id=\"slice的扩容\"><a href=\"#slice的扩容\" class=\"headerlink\" title=\"slice的扩容\"></a>slice的扩容</h5><p>在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// growslice handles slice growth during append.</span>\n<span class=\"hljs-comment\">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span>\n<span class=\"hljs-comment\">// and it returns a new slice with at least that capacity, with the old data</span>\n<span class=\"hljs-comment\">// copied into it.</span>\n<span class=\"hljs-comment\">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span>\n<span class=\"hljs-comment\">// NOT to the new requested capacity.</span>\n<span class=\"hljs-comment\">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span>\n<span class=\"hljs-comment\">// to calculate where to write new values during an append.</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> When the old backend is gone, reconsider this decision.</span>\n<span class=\"hljs-comment\">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">growslice</span><span class=\"hljs-params\">(et *_type, old slice, <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">slice</span></span> &#123;\n\t<span class=\"hljs-comment\">//忽略部分源码</span>\n\tnewcap := old.<span class=\"hljs-built_in\">cap</span>\n\tdoublecap := newcap + newcap\n\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">cap</span> &gt; doublecap &#123;\n\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t<span class=\"hljs-keyword\">if</span> old.<span class=\"hljs-built_in\">len</span> &lt; <span class=\"hljs-number\">1024</span> &#123;\n\t\t\tnewcap = doublecap\n\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t\t<span class=\"hljs-comment\">// Check 0 &lt; newcap to detect overflow</span>\n\t\t\t<span class=\"hljs-comment\">// and prevent an infinite loop.</span>\n\t\t\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class=\"hljs-built_in\">cap</span> &#123;\n\t\t\t\tnewcap += newcap / <span class=\"hljs-number\">4</span>\n\t\t\t&#125;\n\t\t\t<span class=\"hljs-comment\">// Set newcap to the requested cap when</span>\n\t\t\t<span class=\"hljs-comment\">// the newcap calculation overflowed.</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> newcap &lt;= <span class=\"hljs-number\">0</span> &#123;\n\t\t\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n<span class=\"hljs-comment\">//忽略部分源码</span>\n\t<span class=\"hljs-keyword\">return</span> slice&#123;p, old.<span class=\"hljs-built_in\">len</span>, newcap&#125;\n&#125;</code></pre>\n\n<p>当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是</p>\n<ul>\n<li>如果新的大小是当前大小2倍以上，则大小增长为新大小</li>\n<li>如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</li>\n</ul>\n<p>扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p>\n<h5 id=\"nil-slice-和空slice\"><a href=\"#nil-slice-和空slice\" class=\"headerlink\" title=\"nil slice 和空slice\"></a>nil slice 和空slice</h5><p>nil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。</p>\n<p>而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。</p>\n<p>nil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p>\n<table>\n<thead>\n<tr>\n<th>创建方式</th>\n<th>nil切片</th>\n<th>空切片</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>方式一</td>\n<td>var s1 []int</td>\n<td>var s2 = []int{}</td>\n</tr>\n<tr>\n<td>方式二</td>\n<td>var s4 = *new([]int)</td>\n<td>var s3 = make([]int, 0)</td>\n</tr>\n<tr>\n<td>长度</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>容量</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>和nil比较</td>\n<td>true</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"slice-和unsafe-Pointer相互转换\"><a href=\"#slice-和unsafe-Pointer相互转换\" class=\"headerlink\" title=\"slice 和unsafe.Pointer相互转换\"></a>slice 和unsafe.Pointer相互转换</h4><p>在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。</p>\n<p>我们先来看看从slice中获取一块内存地址</p>\n<pre><code class=\"hljs go\">slice:=<span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-number\">10</span>)\nptr:=unsafe.Pointer(&amp;slice[<span class=\"hljs-number\">0</span>])<span class=\"hljs-comment\">//获取数组中第一个元素的内存地址</span></code></pre>\n\n<p>从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式</p>\n<p>第一种，先将<code>ptr</code>强制类型转换为另一种指针，一个指向<code>[1&lt;&lt;10]int</code>数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是<code>s</code>就是一个10个元素的slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\ns := ((*[<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">10</span>]<span class=\"hljs-keyword\">int</span>)(ptr))[:<span class=\"hljs-number\">10</span>]</code></pre>\n\n<p>第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1&lt;&lt;10意思是相同的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\n<span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">struct</span> &#123;\n    addr <span class=\"hljs-keyword\">uintptr</span>\n    <span class=\"hljs-built_in\">len</span> <span class=\"hljs-keyword\">int</span>\n    <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>\n&#125;&#123;ptr, length, length&#125;\ns := *(*[]<span class=\"hljs-keyword\">byte</span>)(unsafe.Pointer(&amp;s1))</code></pre>\n\n<p>第三种方法，通过reflect.SliceHeader的方式来构造slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> o []<span class=\"hljs-keyword\">byte</span>\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = <span class=\"hljs-keyword\">uintptr</span>(ptr)</code></pre>\n\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p>不知道你是否得出文章开始代码的正确结果呢？</p>\n<p> <code>defer</code> 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解<strong>return xxx这一条语句并不是一条原子指令!</strong></p>\n<p>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</p>\n<p>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。</p>\n<p>其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:</p>\n<pre><code class=\"hljs shell\">返回值 = xxx\n调用defer函数\n空的return</code></pre>\n\n<p> 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tresult = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">//return语句不是一条原子调用，return xxx其实是赋值＋ret指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到return之前执行，也就是赋返回值和ret指令之间</span>\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\tr = t <span class=\"hljs-comment\">//赋值指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span>\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return指令</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tr = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//给返回值赋值</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123; <span class=\"hljs-comment\">//这里改的r是传值传进去的r，不会改变要返回的那个r值</span>\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return</span>\n&#125;</code></pre>\n\n<p>接下来我们来看看另外一小段代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;\n  startedAt := time.Now()\n\t<span class=\"hljs-keyword\">defer</span> fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n&#125;\n<span class=\"hljs-comment\">//输出结果并不是1s，而是几百纳秒</span></code></pre>\n\n<p>上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻对函数中引用的外部参数进行拷贝，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下<code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。</p>\n<p>参考：<a href=\"https://halfrost.com/go_slice/\">深入解析go中slice底层实现</a></p>\n<p><a href=\"https://www.cnblogs.com/qcrao-2018/p/10631989.html\">深度解析Go语音之slice</a></p>\n<p><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">深入解析Go</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们讲讲golang的slice和defer。</p>\n<p>slice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。</p>\n<p>在正式开始讲slice之前我们来说一说golang 中的<code>defer</code>，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> t\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n&#125;</code></pre>\n\n<p>答案留在最后讲解</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>在说slice之前，我们先来了解下数组。</p>\n<p>数组是指定长度和元素类型的数据集合。比如以下数组</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> intArr [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">//创建了长度为3的int数组</span>\na[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//根据索引访问元素</span>\nfmt.<span class=\"hljs-built_in\">println</span>(a[<span class=\"hljs-number\">1</span>])<span class=\"hljs-comment\">//int 类型数组默认值为0</span></code></pre>\n\n<p>数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。</p>\n<h4 id=\"slice-1\"><a href=\"#slice-1\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p>在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> slice <span class=\"hljs-keyword\">struct</span> &#123;\n\tarray unsafe.Pointer<span class=\"hljs-comment\">// 指向底层数组的指针</span>\n\t<span class=\"hljs-built_in\">len</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 长度，切片可用元素的个数，slice的下标不能超过长度 </span>\n\t<span class=\"hljs-built_in\">cap</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 容量 &gt;= 长度，在底层不扩容的情况下，cap是len的最大限度</span>\n&#125;</code></pre>\n\n<p>需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。</p>\n<h5 id=\"slice的扩容\"><a href=\"#slice的扩容\" class=\"headerlink\" title=\"slice的扩容\"></a>slice的扩容</h5><p>在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// growslice handles slice growth during append.</span>\n<span class=\"hljs-comment\">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span>\n<span class=\"hljs-comment\">// and it returns a new slice with at least that capacity, with the old data</span>\n<span class=\"hljs-comment\">// copied into it.</span>\n<span class=\"hljs-comment\">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span>\n<span class=\"hljs-comment\">// NOT to the new requested capacity.</span>\n<span class=\"hljs-comment\">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span>\n<span class=\"hljs-comment\">// to calculate where to write new values during an append.</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> When the old backend is gone, reconsider this decision.</span>\n<span class=\"hljs-comment\">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">growslice</span><span class=\"hljs-params\">(et *_type, old slice, <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">slice</span></span> &#123;\n\t<span class=\"hljs-comment\">//忽略部分源码</span>\n\tnewcap := old.<span class=\"hljs-built_in\">cap</span>\n\tdoublecap := newcap + newcap\n\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">cap</span> &gt; doublecap &#123;\n\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t<span class=\"hljs-keyword\">if</span> old.<span class=\"hljs-built_in\">len</span> &lt; <span class=\"hljs-number\">1024</span> &#123;\n\t\t\tnewcap = doublecap\n\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t\t<span class=\"hljs-comment\">// Check 0 &lt; newcap to detect overflow</span>\n\t\t\t<span class=\"hljs-comment\">// and prevent an infinite loop.</span>\n\t\t\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class=\"hljs-built_in\">cap</span> &#123;\n\t\t\t\tnewcap += newcap / <span class=\"hljs-number\">4</span>\n\t\t\t&#125;\n\t\t\t<span class=\"hljs-comment\">// Set newcap to the requested cap when</span>\n\t\t\t<span class=\"hljs-comment\">// the newcap calculation overflowed.</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> newcap &lt;= <span class=\"hljs-number\">0</span> &#123;\n\t\t\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n<span class=\"hljs-comment\">//忽略部分源码</span>\n\t<span class=\"hljs-keyword\">return</span> slice&#123;p, old.<span class=\"hljs-built_in\">len</span>, newcap&#125;\n&#125;</code></pre>\n\n<p>当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是</p>\n<ul>\n<li>如果新的大小是当前大小2倍以上，则大小增长为新大小</li>\n<li>如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</li>\n</ul>\n<p>扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p>\n<h5 id=\"nil-slice-和空slice\"><a href=\"#nil-slice-和空slice\" class=\"headerlink\" title=\"nil slice 和空slice\"></a>nil slice 和空slice</h5><p>nil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。</p>\n<p>而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。</p>\n<p>nil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p>\n<table>\n<thead>\n<tr>\n<th>创建方式</th>\n<th>nil切片</th>\n<th>空切片</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>方式一</td>\n<td>var s1 []int</td>\n<td>var s2 = []int{}</td>\n</tr>\n<tr>\n<td>方式二</td>\n<td>var s4 = *new([]int)</td>\n<td>var s3 = make([]int, 0)</td>\n</tr>\n<tr>\n<td>长度</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>容量</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>和nil比较</td>\n<td>true</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"slice-和unsafe-Pointer相互转换\"><a href=\"#slice-和unsafe-Pointer相互转换\" class=\"headerlink\" title=\"slice 和unsafe.Pointer相互转换\"></a>slice 和unsafe.Pointer相互转换</h4><p>在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。</p>\n<p>我们先来看看从slice中获取一块内存地址</p>\n<pre><code class=\"hljs go\">slice:=<span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-number\">10</span>)\nptr:=unsafe.Pointer(&amp;slice[<span class=\"hljs-number\">0</span>])<span class=\"hljs-comment\">//获取数组中第一个元素的内存地址</span></code></pre>\n\n<p>从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式</p>\n<p>第一种，先将<code>ptr</code>强制类型转换为另一种指针，一个指向<code>[1&lt;&lt;10]int</code>数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是<code>s</code>就是一个10个元素的slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\ns := ((*[<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">10</span>]<span class=\"hljs-keyword\">int</span>)(ptr))[:<span class=\"hljs-number\">10</span>]</code></pre>\n\n<p>第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1&lt;&lt;10意思是相同的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\n<span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">struct</span> &#123;\n    addr <span class=\"hljs-keyword\">uintptr</span>\n    <span class=\"hljs-built_in\">len</span> <span class=\"hljs-keyword\">int</span>\n    <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>\n&#125;&#123;ptr, length, length&#125;\ns := *(*[]<span class=\"hljs-keyword\">byte</span>)(unsafe.Pointer(&amp;s1))</code></pre>\n\n<p>第三种方法，通过reflect.SliceHeader的方式来构造slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> o []<span class=\"hljs-keyword\">byte</span>\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = <span class=\"hljs-keyword\">uintptr</span>(ptr)</code></pre>\n\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p>不知道你是否得出文章开始代码的正确结果呢？</p>\n<p> <code>defer</code> 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解<strong>return xxx这一条语句并不是一条原子指令!</strong></p>\n<p>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</p>\n<p>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。</p>\n<p>其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:</p>\n<pre><code class=\"hljs shell\">返回值 = xxx\n调用defer函数\n空的return</code></pre>\n\n<p> 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tresult = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">//return语句不是一条原子调用，return xxx其实是赋值＋ret指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到return之前执行，也就是赋返回值和ret指令之间</span>\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\tr = t <span class=\"hljs-comment\">//赋值指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span>\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return指令</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tr = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//给返回值赋值</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123; <span class=\"hljs-comment\">//这里改的r是传值传进去的r，不会改变要返回的那个r值</span>\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return</span>\n&#125;</code></pre>\n\n<p>接下来我们来看看另外一小段代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;\n  startedAt := time.Now()\n\t<span class=\"hljs-keyword\">defer</span> fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n&#125;\n<span class=\"hljs-comment\">//输出结果并不是1s，而是几百纳秒</span></code></pre>\n\n<p>上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻对函数中引用的外部参数进行拷贝，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下<code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。</p>\n<p>参考：<a href=\"https://halfrost.com/go_slice/\">深入解析go中slice底层实现</a></p>\n<p><a href=\"https://www.cnblogs.com/qcrao-2018/p/10631989.html\">深度解析Go语音之slice</a></p>\n<p><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">深入解析Go</a></p>\n"},{"title":"golang 之 cgo","date":"2018-08-30T10:00:12.000Z","index_img":["/images/golang/string.jpg"],"_content":"\n使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。\n\n### cgo 的简单例子\n\n让我们从一个简单的cgo 例子说起\n\n```go\npackage main\n//#include <stdio.h>\n//#include <stdlib.h>\nimport \"C\" //该语句要单独写一行\n\nimport (\n   \"unsafe\"\n)\n\nfunc main() {\n   //C.CString将go string 转换成C string\n   s := C.CString(\"Hello, World\\n\")\n   // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n   // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n   // 而且这种内存泄露pprof 也定位不出来\n   defer C.free(unsafe.Pointer(s))\n   //C.puts 函数向标准输出窗口打印，\n   C.puts(s)\n}\n```\n\n虽然上面的代码有注释了，但是还是有一些需要特别注意的。\n\n1. 第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo\n\n   ```go\n   //#include <stdio.h>\n   //#include <stdlib.h>\n   import \"C\"\n   ```\n\n2. 第二个是main 函数里面的内容\n\n   ```go\n   func main() {\n      //C.CString将go string 转换成C string\n      s := C.CString(\"Hello, World\\n\")\n      // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n      // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n      // 而且这种内存泄露pprof 也定位不出来\n      defer C.free(unsafe.Pointer(s))\n      //C.puts 函数向标准输出窗口打印，\n      C.puts(s)\n   }\n   ```\n\n   - Go代码中的`s`变量在传递给c代码使用完成之后，需要调用`C.free`进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。\n\n     ![](/images/golang/string.jpg)\n\n     从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。\n\n     我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了\n\n     ```go\n     // Go string to C string\n     // The C string is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CString(string) *C.char\n     \n     // 这个文档上的大概意思是\n     // C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）\n     ```\n\n     我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。\n\n     ```go\n     // Go []byte slice to C array\n     // The C array is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CBytes([]byte) unsafe.Pointer\n     \n     // C string to Go string\n     func C.GoString(*C.char) string\n     \n     // C data with explicit length to Go string\n     func C.GoStringN(*C.char, C.int) string\n     \n     // C data with explicit length to Go []byte\n     func C.GoBytes(unsafe.Pointer, C.int) []byte\n     ```\n\n     一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。\n     所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即`free`）传入的这份内存。\n     所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。\n\n     \n\n   - 其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过`unsafe.Pointer`获取原始指针进行传递。`unsafe.Pointer`是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。\n\nGo语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考[Go语言高级编程](https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html)\n\n### Go 和 C 之间的数组传递\n\n#### Go数组到C \n\n我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint loop(int** list_data, int leng, char** data)\n{\n  int* m = (int*)list_data;\n  int sum = 0;\n  for(int i=0; i<leng; i++)\n  {\n    sum += m[i];\n  }\n  *data = \"finised task\";\n  return sum;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc GoSilence2CArray() {\n\tvar ids = []int32{1, 2, 3, 5}\n\tvar res *C.char\n\tlength := C.int(len(ids))\n\tle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n}\nfunc main() {\n\tGoSilence2CArray()\n}\n```\n\n整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。\n\n```go\n//正确写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n//错误写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids)), length, &res)\n```\n\nSlice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&ids，那相当于把ids这个数据结构的地址处的数据强制转换为`(**C.int)`。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是`(**C.int)(unsafe.Pointer(&ids[0]))`。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)\n\n#### C数组到Go slice\n\n还是直接看例子\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct{\n   char* name;\n}person;\n\nperson* get_person(int n){\n   person* ret = (person*)malloc(sizeof(person) * n);\n   for(int i=0;i<n;i++){\n      ret[i].name=\"wu\";\n   }\n   return ret;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc CArray2GoSilence() {\n\tsize := 2\n\tperson := C.get_person(C.int(size))\n\tperson_array := (*[1 << 30]C.person)(unsafe.Pointer(person))\n\tvar names []string\n\tfor i := 0; i < size; i++ {\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = append(names, name)\n\t}\n\tfor _, name := range names {\n\t\tfmt.Println(name)\n\t}\n\tC.free(unsafe.Pointer(person))\n}\nfunc main() {\n\tCArray2GoSilence()\n}\n```\n\nC语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。`(*[1 << 30]C.person)(unsafe.Pointer(person))` 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。\n\n### cgo利用pkg_config 使用第三方的so库\n\n#### pkg_config\n\n我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。**pkg-config** 是一个在[源代码](https://zh.wikipedia.org/wiki/源代码)[编译](https://zh.wikipedia.org/wiki/编译)时查询已安装的[库](https://zh.wikipedia.org/wiki/库)的使用接口的计算机工具[软件](https://zh.wikipedia.org/wiki/软件)。pkg-config原本是设计用于[Linux](https://zh.wikipedia.org/wiki/Linux)的，但现在在各个版本的[BSD](https://zh.wikipedia.org/wiki/BSD)、[windows](https://zh.wikipedia.org/wiki/Windows)、[Mac OS X](https://zh.wikipedia.org/wiki/Mac_OS_X)和[Solaris](https://zh.wikipedia.org/wiki/Solaris)上都有着可用的版本。\n\n那么pkg-config有什么作用呢？\n\n1. 检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。\n2. 获得编译预处理参数，如宏定义，头文件的位置。\n3. 得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。\n4. 自动加入所依赖的其它库的设置。\n\npkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于[libpng](https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1)的.pc文件的样例:\n\n```shell\nprefix=/usr/local\nexec_prefix=${prefix}\nlibdir=${exec_prefix}/lib\nincludedir=${exec_prefix}/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L${libdir} -lpng12 -lz\nCflags: -I${includedir}/libpng12\n```\n\n这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。\n\npkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。\n\n#### cgo 使用pkg-config\n\n我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分\n\n```go\npackage cgo\n// #cgo pkg-config: megproduct\n// #cgo CXXFLAGS: -std=c++11\n// #include \"plate.h\"\n// #include \"stdlib.h\"\nimport \"C\"\n//后续使用方法和go 调用C的方式一致了\n```\n\n我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。\n\n我们来看下megproduct.pc 是咋样的\n\n```shell\nprefix=/go/DATA/plate-sdk-190710\nlibdir=${prefix}/lib\nincludedir=${prefix}/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: ${libdir}/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I${includedir}\n```\n\n使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config\n\n\n\n本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。\n\n\n\n参考：[Go语言使用cgo时的内存管理笔记](https://www.pengrl.com/p/29054/)\n\n​\t\t\t[官方文档](https://golang.org/cmd/cgo/)\n\n​\t\t\t[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)","source":"_posts/golang之cgo.md","raw":"---\ntitle: golang 之 cgo\ndate: 2018-08-30 18:00:12\nindex_img:\n- /images/golang/string.jpg\ntags: \n- golang cgo\ncategories:\n- golang\n---\n\n使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。\n\n### cgo 的简单例子\n\n让我们从一个简单的cgo 例子说起\n\n```go\npackage main\n//#include <stdio.h>\n//#include <stdlib.h>\nimport \"C\" //该语句要单独写一行\n\nimport (\n   \"unsafe\"\n)\n\nfunc main() {\n   //C.CString将go string 转换成C string\n   s := C.CString(\"Hello, World\\n\")\n   // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n   // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n   // 而且这种内存泄露pprof 也定位不出来\n   defer C.free(unsafe.Pointer(s))\n   //C.puts 函数向标准输出窗口打印，\n   C.puts(s)\n}\n```\n\n虽然上面的代码有注释了，但是还是有一些需要特别注意的。\n\n1. 第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo\n\n   ```go\n   //#include <stdio.h>\n   //#include <stdlib.h>\n   import \"C\"\n   ```\n\n2. 第二个是main 函数里面的内容\n\n   ```go\n   func main() {\n      //C.CString将go string 转换成C string\n      s := C.CString(\"Hello, World\\n\")\n      // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n      // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n      // 而且这种内存泄露pprof 也定位不出来\n      defer C.free(unsafe.Pointer(s))\n      //C.puts 函数向标准输出窗口打印，\n      C.puts(s)\n   }\n   ```\n\n   - Go代码中的`s`变量在传递给c代码使用完成之后，需要调用`C.free`进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。\n\n     ![](/images/golang/string.jpg)\n\n     从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。\n\n     我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了\n\n     ```go\n     // Go string to C string\n     // The C string is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CString(string) *C.char\n     \n     // 这个文档上的大概意思是\n     // C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）\n     ```\n\n     我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。\n\n     ```go\n     // Go []byte slice to C array\n     // The C array is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CBytes([]byte) unsafe.Pointer\n     \n     // C string to Go string\n     func C.GoString(*C.char) string\n     \n     // C data with explicit length to Go string\n     func C.GoStringN(*C.char, C.int) string\n     \n     // C data with explicit length to Go []byte\n     func C.GoBytes(unsafe.Pointer, C.int) []byte\n     ```\n\n     一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。\n     所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即`free`）传入的这份内存。\n     所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。\n\n     \n\n   - 其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过`unsafe.Pointer`获取原始指针进行传递。`unsafe.Pointer`是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。\n\nGo语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考[Go语言高级编程](https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html)\n\n### Go 和 C 之间的数组传递\n\n#### Go数组到C \n\n我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint loop(int** list_data, int leng, char** data)\n{\n  int* m = (int*)list_data;\n  int sum = 0;\n  for(int i=0; i<leng; i++)\n  {\n    sum += m[i];\n  }\n  *data = \"finised task\";\n  return sum;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc GoSilence2CArray() {\n\tvar ids = []int32{1, 2, 3, 5}\n\tvar res *C.char\n\tlength := C.int(len(ids))\n\tle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n}\nfunc main() {\n\tGoSilence2CArray()\n}\n```\n\n整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。\n\n```go\n//正确写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n//错误写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids)), length, &res)\n```\n\nSlice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&ids，那相当于把ids这个数据结构的地址处的数据强制转换为`(**C.int)`。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是`(**C.int)(unsafe.Pointer(&ids[0]))`。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)\n\n#### C数组到Go slice\n\n还是直接看例子\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct{\n   char* name;\n}person;\n\nperson* get_person(int n){\n   person* ret = (person*)malloc(sizeof(person) * n);\n   for(int i=0;i<n;i++){\n      ret[i].name=\"wu\";\n   }\n   return ret;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc CArray2GoSilence() {\n\tsize := 2\n\tperson := C.get_person(C.int(size))\n\tperson_array := (*[1 << 30]C.person)(unsafe.Pointer(person))\n\tvar names []string\n\tfor i := 0; i < size; i++ {\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = append(names, name)\n\t}\n\tfor _, name := range names {\n\t\tfmt.Println(name)\n\t}\n\tC.free(unsafe.Pointer(person))\n}\nfunc main() {\n\tCArray2GoSilence()\n}\n```\n\nC语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。`(*[1 << 30]C.person)(unsafe.Pointer(person))` 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。\n\n### cgo利用pkg_config 使用第三方的so库\n\n#### pkg_config\n\n我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。**pkg-config** 是一个在[源代码](https://zh.wikipedia.org/wiki/源代码)[编译](https://zh.wikipedia.org/wiki/编译)时查询已安装的[库](https://zh.wikipedia.org/wiki/库)的使用接口的计算机工具[软件](https://zh.wikipedia.org/wiki/软件)。pkg-config原本是设计用于[Linux](https://zh.wikipedia.org/wiki/Linux)的，但现在在各个版本的[BSD](https://zh.wikipedia.org/wiki/BSD)、[windows](https://zh.wikipedia.org/wiki/Windows)、[Mac OS X](https://zh.wikipedia.org/wiki/Mac_OS_X)和[Solaris](https://zh.wikipedia.org/wiki/Solaris)上都有着可用的版本。\n\n那么pkg-config有什么作用呢？\n\n1. 检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。\n2. 获得编译预处理参数，如宏定义，头文件的位置。\n3. 得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。\n4. 自动加入所依赖的其它库的设置。\n\npkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于[libpng](https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1)的.pc文件的样例:\n\n```shell\nprefix=/usr/local\nexec_prefix=${prefix}\nlibdir=${exec_prefix}/lib\nincludedir=${exec_prefix}/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L${libdir} -lpng12 -lz\nCflags: -I${includedir}/libpng12\n```\n\n这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。\n\npkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。\n\n#### cgo 使用pkg-config\n\n我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分\n\n```go\npackage cgo\n// #cgo pkg-config: megproduct\n// #cgo CXXFLAGS: -std=c++11\n// #include \"plate.h\"\n// #include \"stdlib.h\"\nimport \"C\"\n//后续使用方法和go 调用C的方式一致了\n```\n\n我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。\n\n我们来看下megproduct.pc 是咋样的\n\n```shell\nprefix=/go/DATA/plate-sdk-190710\nlibdir=${prefix}/lib\nincludedir=${prefix}/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: ${libdir}/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I${includedir}\n```\n\n使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config\n\n\n\n本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。\n\n\n\n参考：[Go语言使用cgo时的内存管理笔记](https://www.pengrl.com/p/29054/)\n\n​\t\t\t[官方文档](https://golang.org/cmd/cgo/)\n\n​\t\t\t[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)","slug":"golang之cgo","published":1,"updated":"2020-03-26T05:07:55.030Z","_id":"ckghk0s0g000xmdymhahveqnx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。</p>\n<h3 id=\"cgo-的简单例子\"><a href=\"#cgo-的简单例子\" class=\"headerlink\" title=\"cgo 的简单例子\"></a>cgo 的简单例子</h3><p>让我们从一个简单的cgo 例子说起</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n\n<span class=\"hljs-keyword\">import</span> (\n   <span class=\"hljs-string\">&quot;unsafe&quot;</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<p>虽然上面的代码有注释了，但是还是有一些需要特别注意的。</p>\n<ol>\n<li><p>第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span></code></pre>\n</li>\n<li><p>第二个是main 函数里面的内容</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<ul>\n<li><p>Go代码中的<code>s</code>变量在传递给c代码使用完成之后，需要调用<code>C.free</code>进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。</p>\n<p><img src=\"/images/golang/string.jpg\"></p>\n<p>从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。</p>\n<p>我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go string to C string</span>\n<span class=\"hljs-comment\">// The C string is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CString</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>)</span> *<span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">char</span></span>\n\n<span class=\"hljs-comment\">// 这个文档上的大概意思是</span>\n<span class=\"hljs-comment\">// C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）</span></code></pre>\n\n<p>我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go []byte slice to C array</span>\n<span class=\"hljs-comment\">// The C array is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CBytes</span><span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">unsafe</span>.<span class=\"hljs-title\">Pointer</span></span>\n\n<span class=\"hljs-comment\">// C string to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoString</span><span class=\"hljs-params\">(*C.char)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoStringN</span><span class=\"hljs-params\">(*C.char, C.<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go []byte</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoBytes</span><span class=\"hljs-params\">(unsafe.Pointer, C.<span class=\"hljs-keyword\">int</span>)</span> []<span class=\"hljs-title\">byte</span></span></code></pre>\n\n<p>一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。<br>所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即<code>free</code>）传入的这份内存。<br>所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过<code>unsafe.Pointer</code>获取原始指针进行传递。<code>unsafe.Pointer</code>是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。</li>\n</ul>\n<p>Go语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考<a href=\"https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html\">Go语言高级编程</a></p>\n<h3 id=\"Go-和-C-之间的数组传递\"><a href=\"#Go-和-C-之间的数组传递\" class=\"headerlink\" title=\"Go 和 C 之间的数组传递\"></a>Go 和 C 之间的数组传递</h3><h4 id=\"Go数组到C\"><a href=\"#Go数组到C\" class=\"headerlink\" title=\"Go数组到C\"></a>Go数组到C</h4><p>我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">int loop(int** list_data, int leng, char** data)</span>\n<span class=\"hljs-comment\">&#123;</span>\n<span class=\"hljs-comment\">  int* m = (int*)list_data;</span>\n<span class=\"hljs-comment\">  int sum = 0;</span>\n<span class=\"hljs-comment\">  for(int i=0; i&lt;leng; i++)</span>\n<span class=\"hljs-comment\">  &#123;</span>\n<span class=\"hljs-comment\">    sum += m[i];</span>\n<span class=\"hljs-comment\">  &#125;</span>\n<span class=\"hljs-comment\">  *data = &quot;finised task&quot;;</span>\n<span class=\"hljs-comment\">  return sum;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GoSilence2CArray</span><span class=\"hljs-params\">()</span></span> &#123;\n\t<span class=\"hljs-keyword\">var</span> ids = []<span class=\"hljs-keyword\">int32</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>&#125;\n\t<span class=\"hljs-keyword\">var</span> res *C.char\n\tlength := C.<span class=\"hljs-keyword\">int</span>(<span class=\"hljs-built_in\">len</span>(ids))\n\tle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tGoSilence2CArray()\n&#125;</code></pre>\n\n<p>整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//正确写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n<span class=\"hljs-comment\">//错误写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids)), length, &amp;res)</code></pre>\n\n<p>Slice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&amp;ids，那相当于把ids这个数据结构的地址处的数据强制转换为<code>(**C.int)</code>。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是<code>(**C.int)(unsafe.Pointer(&amp;ids[0]))</code>。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看<a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n<h4 id=\"C数组到Go-slice\"><a href=\"#C数组到Go-slice\" class=\"headerlink\" title=\"C数组到Go slice\"></a>C数组到Go slice</h4><p>还是直接看例子</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">typedef struct&#123;</span>\n<span class=\"hljs-comment\">   char* name;</span>\n<span class=\"hljs-comment\">&#125;person;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">person* get_person(int n)&#123;</span>\n<span class=\"hljs-comment\">   person* ret = (person*)malloc(sizeof(person) * n);</span>\n<span class=\"hljs-comment\">   for(int i=0;i&lt;n;i++)&#123;</span>\n<span class=\"hljs-comment\">      ret[i].name=&quot;wu&quot;;</span>\n<span class=\"hljs-comment\">   &#125;</span>\n<span class=\"hljs-comment\">   return ret;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CArray2GoSilence</span><span class=\"hljs-params\">()</span></span> &#123;\n\tsize := <span class=\"hljs-number\">2</span>\n\tperson := C.get_person(C.<span class=\"hljs-keyword\">int</span>(size))\n\tperson_array := (*[<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">30</span>]C.person)(unsafe.Pointer(person))\n\t<span class=\"hljs-keyword\">var</span> names []<span class=\"hljs-keyword\">string</span>\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = <span class=\"hljs-built_in\">append</span>(names, name)\n\t&#125;\n\t<span class=\"hljs-keyword\">for</span> _, name := <span class=\"hljs-keyword\">range</span> names &#123;\n\t\tfmt.Println(name)\n\t&#125;\n\tC.free(unsafe.Pointer(person))\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tCArray2GoSilence()\n&#125;</code></pre>\n\n<p>C语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。<code>(*[1 &lt;&lt; 30]C.person)(unsafe.Pointer(person))</code> 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。</p>\n<h3 id=\"cgo利用pkg-config-使用第三方的so库\"><a href=\"#cgo利用pkg-config-使用第三方的so库\" class=\"headerlink\" title=\"cgo利用pkg_config 使用第三方的so库\"></a>cgo利用pkg_config 使用第三方的so库</h3><h4 id=\"pkg-config\"><a href=\"#pkg-config\" class=\"headerlink\" title=\"pkg_config\"></a>pkg_config</h4><p>我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。<strong>pkg-config</strong> 是一个在<a href=\"https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81\">源代码</a><a href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91\">编译</a>时查询已安装的<a href=\"https://zh.wikipedia.org/wiki/%E5%BA%93\">库</a>的使用接口的计算机工具<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6\">软件</a>。pkg-config原本是设计用于<a href=\"https://zh.wikipedia.org/wiki/Linux\">Linux</a>的，但现在在各个版本的<a href=\"https://zh.wikipedia.org/wiki/BSD\">BSD</a>、<a href=\"https://zh.wikipedia.org/wiki/Windows\">windows</a>、<a href=\"https://zh.wikipedia.org/wiki/Mac_OS_X\">Mac OS X</a>和<a href=\"https://zh.wikipedia.org/wiki/Solaris\">Solaris</a>上都有着可用的版本。</p>\n<p>那么pkg-config有什么作用呢？</p>\n<ol>\n<li>检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。</li>\n<li>获得编译预处理参数，如宏定义，头文件的位置。</li>\n<li>得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。</li>\n<li>自动加入所依赖的其它库的设置。</li>\n</ol>\n<p>pkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于<a href=\"https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1\">libpng</a>的.pc文件的样例:</p>\n<pre><code class=\"hljs shell\">prefix=/usr/local\nexec_prefix=$&#123;prefix&#125;\nlibdir=$&#123;exec_prefix&#125;/lib\nincludedir=$&#123;exec_prefix&#125;/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L$&#123;libdir&#125; -lpng12 -lz\nCflags: -I$&#123;includedir&#125;/libpng12</code></pre>\n\n<p>这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。</p>\n<p>pkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。</p>\n<h4 id=\"cgo-使用pkg-config\"><a href=\"#cgo-使用pkg-config\" class=\"headerlink\" title=\"cgo 使用pkg-config\"></a>cgo 使用pkg-config</h4><p>我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> cgo\n<span class=\"hljs-comment\">// #cgo pkg-config: megproduct</span>\n<span class=\"hljs-comment\">// #cgo CXXFLAGS: -std=c++11</span>\n<span class=\"hljs-comment\">// #include &quot;plate.h&quot;</span>\n<span class=\"hljs-comment\">// #include &quot;stdlib.h&quot;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span>\n<span class=\"hljs-comment\">//后续使用方法和go 调用C的方式一致了</span></code></pre>\n\n<p>我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。</p>\n<p>我们来看下megproduct.pc 是咋样的</p>\n<pre><code class=\"hljs shell\">prefix=/go/DATA/plate-sdk-190710\nlibdir=$&#123;prefix&#125;/lib\nincludedir=$&#123;prefix&#125;/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: $&#123;libdir&#125;/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I$&#123;includedir&#125;</code></pre>\n\n<p>使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config</p>\n<p>本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。</p>\n<p>参考：<a href=\"https://www.pengrl.com/p/29054/\">Go语言使用cgo时的内存管理笔记</a></p>\n<p>​            <a href=\"https://golang.org/cmd/cgo/\">官方文档</a></p>\n<p>​            <a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。</p>\n<h3 id=\"cgo-的简单例子\"><a href=\"#cgo-的简单例子\" class=\"headerlink\" title=\"cgo 的简单例子\"></a>cgo 的简单例子</h3><p>让我们从一个简单的cgo 例子说起</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n\n<span class=\"hljs-keyword\">import</span> (\n   <span class=\"hljs-string\">&quot;unsafe&quot;</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<p>虽然上面的代码有注释了，但是还是有一些需要特别注意的。</p>\n<ol>\n<li><p>第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span></code></pre>\n</li>\n<li><p>第二个是main 函数里面的内容</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<ul>\n<li><p>Go代码中的<code>s</code>变量在传递给c代码使用完成之后，需要调用<code>C.free</code>进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。</p>\n<p><img src=\"/images/golang/string.jpg\"></p>\n<p>从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。</p>\n<p>我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go string to C string</span>\n<span class=\"hljs-comment\">// The C string is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CString</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>)</span> *<span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">char</span></span>\n\n<span class=\"hljs-comment\">// 这个文档上的大概意思是</span>\n<span class=\"hljs-comment\">// C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）</span></code></pre>\n\n<p>我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go []byte slice to C array</span>\n<span class=\"hljs-comment\">// The C array is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CBytes</span><span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">unsafe</span>.<span class=\"hljs-title\">Pointer</span></span>\n\n<span class=\"hljs-comment\">// C string to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoString</span><span class=\"hljs-params\">(*C.char)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoStringN</span><span class=\"hljs-params\">(*C.char, C.<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go []byte</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoBytes</span><span class=\"hljs-params\">(unsafe.Pointer, C.<span class=\"hljs-keyword\">int</span>)</span> []<span class=\"hljs-title\">byte</span></span></code></pre>\n\n<p>一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。<br>所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即<code>free</code>）传入的这份内存。<br>所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过<code>unsafe.Pointer</code>获取原始指针进行传递。<code>unsafe.Pointer</code>是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。</li>\n</ul>\n<p>Go语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考<a href=\"https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html\">Go语言高级编程</a></p>\n<h3 id=\"Go-和-C-之间的数组传递\"><a href=\"#Go-和-C-之间的数组传递\" class=\"headerlink\" title=\"Go 和 C 之间的数组传递\"></a>Go 和 C 之间的数组传递</h3><h4 id=\"Go数组到C\"><a href=\"#Go数组到C\" class=\"headerlink\" title=\"Go数组到C\"></a>Go数组到C</h4><p>我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">int loop(int** list_data, int leng, char** data)</span>\n<span class=\"hljs-comment\">&#123;</span>\n<span class=\"hljs-comment\">  int* m = (int*)list_data;</span>\n<span class=\"hljs-comment\">  int sum = 0;</span>\n<span class=\"hljs-comment\">  for(int i=0; i&lt;leng; i++)</span>\n<span class=\"hljs-comment\">  &#123;</span>\n<span class=\"hljs-comment\">    sum += m[i];</span>\n<span class=\"hljs-comment\">  &#125;</span>\n<span class=\"hljs-comment\">  *data = &quot;finised task&quot;;</span>\n<span class=\"hljs-comment\">  return sum;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GoSilence2CArray</span><span class=\"hljs-params\">()</span></span> &#123;\n\t<span class=\"hljs-keyword\">var</span> ids = []<span class=\"hljs-keyword\">int32</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>&#125;\n\t<span class=\"hljs-keyword\">var</span> res *C.char\n\tlength := C.<span class=\"hljs-keyword\">int</span>(<span class=\"hljs-built_in\">len</span>(ids))\n\tle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tGoSilence2CArray()\n&#125;</code></pre>\n\n<p>整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//正确写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n<span class=\"hljs-comment\">//错误写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids)), length, &amp;res)</code></pre>\n\n<p>Slice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&amp;ids，那相当于把ids这个数据结构的地址处的数据强制转换为<code>(**C.int)</code>。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是<code>(**C.int)(unsafe.Pointer(&amp;ids[0]))</code>。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看<a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n<h4 id=\"C数组到Go-slice\"><a href=\"#C数组到Go-slice\" class=\"headerlink\" title=\"C数组到Go slice\"></a>C数组到Go slice</h4><p>还是直接看例子</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">typedef struct&#123;</span>\n<span class=\"hljs-comment\">   char* name;</span>\n<span class=\"hljs-comment\">&#125;person;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">person* get_person(int n)&#123;</span>\n<span class=\"hljs-comment\">   person* ret = (person*)malloc(sizeof(person) * n);</span>\n<span class=\"hljs-comment\">   for(int i=0;i&lt;n;i++)&#123;</span>\n<span class=\"hljs-comment\">      ret[i].name=&quot;wu&quot;;</span>\n<span class=\"hljs-comment\">   &#125;</span>\n<span class=\"hljs-comment\">   return ret;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CArray2GoSilence</span><span class=\"hljs-params\">()</span></span> &#123;\n\tsize := <span class=\"hljs-number\">2</span>\n\tperson := C.get_person(C.<span class=\"hljs-keyword\">int</span>(size))\n\tperson_array := (*[<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">30</span>]C.person)(unsafe.Pointer(person))\n\t<span class=\"hljs-keyword\">var</span> names []<span class=\"hljs-keyword\">string</span>\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = <span class=\"hljs-built_in\">append</span>(names, name)\n\t&#125;\n\t<span class=\"hljs-keyword\">for</span> _, name := <span class=\"hljs-keyword\">range</span> names &#123;\n\t\tfmt.Println(name)\n\t&#125;\n\tC.free(unsafe.Pointer(person))\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tCArray2GoSilence()\n&#125;</code></pre>\n\n<p>C语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。<code>(*[1 &lt;&lt; 30]C.person)(unsafe.Pointer(person))</code> 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。</p>\n<h3 id=\"cgo利用pkg-config-使用第三方的so库\"><a href=\"#cgo利用pkg-config-使用第三方的so库\" class=\"headerlink\" title=\"cgo利用pkg_config 使用第三方的so库\"></a>cgo利用pkg_config 使用第三方的so库</h3><h4 id=\"pkg-config\"><a href=\"#pkg-config\" class=\"headerlink\" title=\"pkg_config\"></a>pkg_config</h4><p>我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。<strong>pkg-config</strong> 是一个在<a href=\"https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81\">源代码</a><a href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91\">编译</a>时查询已安装的<a href=\"https://zh.wikipedia.org/wiki/%E5%BA%93\">库</a>的使用接口的计算机工具<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6\">软件</a>。pkg-config原本是设计用于<a href=\"https://zh.wikipedia.org/wiki/Linux\">Linux</a>的，但现在在各个版本的<a href=\"https://zh.wikipedia.org/wiki/BSD\">BSD</a>、<a href=\"https://zh.wikipedia.org/wiki/Windows\">windows</a>、<a href=\"https://zh.wikipedia.org/wiki/Mac_OS_X\">Mac OS X</a>和<a href=\"https://zh.wikipedia.org/wiki/Solaris\">Solaris</a>上都有着可用的版本。</p>\n<p>那么pkg-config有什么作用呢？</p>\n<ol>\n<li>检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。</li>\n<li>获得编译预处理参数，如宏定义，头文件的位置。</li>\n<li>得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。</li>\n<li>自动加入所依赖的其它库的设置。</li>\n</ol>\n<p>pkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于<a href=\"https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1\">libpng</a>的.pc文件的样例:</p>\n<pre><code class=\"hljs shell\">prefix=/usr/local\nexec_prefix=$&#123;prefix&#125;\nlibdir=$&#123;exec_prefix&#125;/lib\nincludedir=$&#123;exec_prefix&#125;/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L$&#123;libdir&#125; -lpng12 -lz\nCflags: -I$&#123;includedir&#125;/libpng12</code></pre>\n\n<p>这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。</p>\n<p>pkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。</p>\n<h4 id=\"cgo-使用pkg-config\"><a href=\"#cgo-使用pkg-config\" class=\"headerlink\" title=\"cgo 使用pkg-config\"></a>cgo 使用pkg-config</h4><p>我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> cgo\n<span class=\"hljs-comment\">// #cgo pkg-config: megproduct</span>\n<span class=\"hljs-comment\">// #cgo CXXFLAGS: -std=c++11</span>\n<span class=\"hljs-comment\">// #include &quot;plate.h&quot;</span>\n<span class=\"hljs-comment\">// #include &quot;stdlib.h&quot;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span>\n<span class=\"hljs-comment\">//后续使用方法和go 调用C的方式一致了</span></code></pre>\n\n<p>我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。</p>\n<p>我们来看下megproduct.pc 是咋样的</p>\n<pre><code class=\"hljs shell\">prefix=/go/DATA/plate-sdk-190710\nlibdir=$&#123;prefix&#125;/lib\nincludedir=$&#123;prefix&#125;/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: $&#123;libdir&#125;/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I$&#123;includedir&#125;</code></pre>\n\n<p>使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config</p>\n<p>本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。</p>\n<p>参考：<a href=\"https://www.pengrl.com/p/29054/\">Go语言使用cgo时的内存管理笔记</a></p>\n<p>​            <a href=\"https://golang.org/cmd/cgo/\">官方文档</a></p>\n<p>​            <a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n"},{"title":"java 之 JNA","date":"2018-10-15T11:00:12.000Z","index_img":["/images/java/jna.jpg"],"_content":"\n我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步[官方文档](https://github.com/java-native-access/jna)。\n\n不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：\n\n| C基本类型 |    长度     |  Java类型  |       Windows类型       |\n| :-------: | :---------: | :--------: | :---------------------: |\n|   char    |   8位整型   |    byte    |       BYTE、TCHAR       |\n|   short   |  16位整型   |   short    |          WORD           |\n|  wchar_t  | 16/32位字符 |    char    |          TCHAR          |\n|    int    |  32位整型   |    int     |          DWORD          |\n|    int    |   布尔值    |  boolean   |          BOOL           |\n|   long    | 32/64位整型 | NativeLong |          LONG           |\n| long long |  64位整型   |    long    |         __int64         |\n|   float   | 32位浮点型  |   float    |                         |\n|  double   | 64位浮点型  |   double   |                         |\n|   char*   |   C字符串   |   String   |         LPTCSTR         |\n|   void*   |    指针     |  Pointer   | LPVOID、HANDLE、LP*XXX* |\n\n#### 开发过程\n\n我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。\n\n##### 定义一个接口和编写相应的结构体映射\n\n定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Library;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.Structure;\nimport com.sun.jna.Structure.ByValue;\nimport com.sun.jna.ptr.IntByReference;\nimport com.sun.jna.win32.StdCallLibrary.StdCallCallback;\nimport com.sun.jna.Callback;\n\npublic interface NVSSDK extends Library {\n  public static class PicTime extends Structure {\n\n        public int uiYear;\n        public int uiMonth;\n        public int uiDay;\n        public int uiWeek;\n        public int uiHour;\n        public int uiMinute;\n        public int uiSecondsr;\n        public int uiMilliseconds;\n    }\n\n    public static class PicData extends Structure {\n        public PicData(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n\n        public PicTime tPicTime;\n        public int iDataLen;\n        public Pointer pcPicData;\n    }\n  public static class FacePicStream extends Structure {\n        public FacePicStream(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n        public int iStructLen;\n        public int iSizeOfFull;        \n        public Pointer tFullData;\n        public int iFaceCount;\n        public int iSizeOfFace;        \n        public Pointer[] tPicData = new Pointer[32];\n        public int iFaceFrameId;       \n        public PicTime tNewPicTime;\n    }\n   public static interface NET_PICSTREAM_NOTIFY extends StdCallCallback {\n        int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen,\n                          Pointer _lpUserData);\n    }\n\t public static class NetPicPara extends Structure {\n        public int iStructLen;                //Structure length\n        public int iChannelNo;\n        public NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        public Pointer pvUser;\n    }\n    int NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID);\n\n```\n\n上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。\n\n在另外一个类中加载动态库\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Native;\nimport com.sun.jna.ptr.IntByReference;\npublic class NetClient {\n    private static NVSSDK nvssdk;\n    private static NetClient netClient;\n    private NetClient() {\n    }\n\n    public static NetClient getInstance() {\n        if (netClient == null) {\n            synchronized (NetClient.class) {\n                if (netClient == null) {\n                    netClient = new NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(\"NVSSDK\",\n                            NVSSDK.class);\n                }\n            }\n        }\n        return netClient;\n    }\n   //开始接收图片流\n    public int StartRecvNetPicStream(int _iLogonID, NVSSDK.NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID) {\n        return nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    }\n}\n```\n\n##### 相关的头文件\n\n```c\ntypedef struct tagFacePicStream\n{\n\tint \t\t\tiStructLen;\t\t\t//Structure length\n\tint\t\t\t\tiSizeOfFull;\t\t//The size of strcut PicData\n\tPicData*\t\tptFullData;\t\t\t//The data of full screen\n\tint\t\t\t\tiFaceCount;\t\t\t//The current frame detects the number of face\n\tint\t\t\t\tiSizeOfFace;\t\t//The size of strcut FacePicData\n\tFacePicData*\tptFaceData[108];\n\tint\t\t\t\tiFaceFrameId;\t\t//The face jpeg frame no\n\tPicTime\t\t\ttNewPicTime;\t\t//The picture capture time, ptFullData contain time is out of date\n} FacePicStream, *pFacePicStream;\n\ntypedef struct tagSnapPicData\n{\n\tint \t\tiSnapType;\t\t//Snap type\n\tint \t\tiWidth;\t\t\t//Picture wide\n\tint \t\tiHeight;\t\t//Picture high\n\tint\t\t\tiSize;\t\t\t//The size of strcut PicData\n\tPicData*\tptPicData;\n} SnapPicData, *pSnapPicData;\n\ntypedef struct tagPicTime\n{\n\tunsigned int uiYear;\n\tunsigned int uiMonth;\n\tunsigned int uiDay;\n\tunsigned int uiWeek;\n\tunsigned int uiHour;\n\tunsigned int uiMinute;\n\tunsigned int uiSecondsr;\n\tunsigned int uiMilliseconds;\n} PicTime, *pPicTime;\n//回调\ntypedef int (__stdcall *NET_PICSTREAM_NOTIFY)(unsigned int _uiRecvID, long _lCommand, void* _pvBuf, int _iBufLen, void* _pvUser);\ntypedef struct tagNetPicPara\n{\n\tint \t\t\t\t\tiStructLen;\t\t\t\t//Structure length\n\tint\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\tvoid*\t\t\t\t\tpvUser;\n\tint\t\t\t\t\t\tiPicType;\t\t\t\t//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit0£ºFace picture stream \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit1£ºpedestrian \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit2:plate number\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit3:motor vehicles\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit4:Non-motor vehicle\n} NetPicPara, *pNetPicPara;\n//方法\nint __stdcall NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara* _ptPara, int _iBufLen, unsigned int* _puiRecvID);\n```\n\n##### 使用过程\n\n需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将**指针转换成头文件中对应的结构体**。\n\n```java \nprivate void SetPicQueue(final C4SCamera camera) {\n        NVSSDK.NetPicPara picPara = new NVSSDK.NetPicPara();\n        picPara.iChannelNo = 0;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = new NVSSDK.NET_PICSTREAM_NOTIFY() {\n            public int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen, Pointer _lpUserData) {\n                if (_tInfo == null || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) {\n                    return 0;\n                }\n                if (!camera.capture.get()) {\n                    return 0;\n                }\n                NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n                if (picStream.tFullData != null) {\n                    NVSSDK.PicData fullData = new NVSSDK.PicData(picStream.tFullData);\n                    if (fullData != null && fullData.iDataLen > 0 && camera.capture.get()) {\n                        byte[] data = fullData.pcPicData.getByteArray(0, fullData.iDataLen);\n                        FaceInfo faceInfo = new FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    }\n                }\n                return 0;\n            }\n        };\n        IntByReference relsize = new IntByReference();\n        int iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    }\n```\n\n#### 遇到的问题\n\n1. **java.lang.UnsatisfiedLinkError: Unable to load library 'NVSSDK':**\n\n   这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能\n\n   - jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk\n\n   - 还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。\n\n     ```java\n     System.setProperty(\"jna.library.path\", dllPath);\n     ```\n\n2. 在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。\n\n   - 结构体的构造方法,添加useMemory(pointer);和read();\n\n     ```java\n       public static class FacePicStream extends Structure{\n     \t\tpublic FacePicStream(Pointer pointer) {\n                 super(pointer);\n                 useMemory(pointer);\n                 read();\n             }    \n       }\n     ```\n\n   - 使用\n\n     ```java\n     Pointer _tInfo;\n     NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n     ```\n   \n3. Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。\n\n   ","source":"_posts/java 之 JNA.md","raw":"---\ntitle: java 之 JNA\ndate: 2018-10-15 19:00:12\nindex_img:\n- /images/java/jna.jpg\ntags: \n- jna\ncategories:\n- Java\n---\n\n我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步[官方文档](https://github.com/java-native-access/jna)。\n\n不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：\n\n| C基本类型 |    长度     |  Java类型  |       Windows类型       |\n| :-------: | :---------: | :--------: | :---------------------: |\n|   char    |   8位整型   |    byte    |       BYTE、TCHAR       |\n|   short   |  16位整型   |   short    |          WORD           |\n|  wchar_t  | 16/32位字符 |    char    |          TCHAR          |\n|    int    |  32位整型   |    int     |          DWORD          |\n|    int    |   布尔值    |  boolean   |          BOOL           |\n|   long    | 32/64位整型 | NativeLong |          LONG           |\n| long long |  64位整型   |    long    |         __int64         |\n|   float   | 32位浮点型  |   float    |                         |\n|  double   | 64位浮点型  |   double   |                         |\n|   char*   |   C字符串   |   String   |         LPTCSTR         |\n|   void*   |    指针     |  Pointer   | LPVOID、HANDLE、LP*XXX* |\n\n#### 开发过程\n\n我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。\n\n##### 定义一个接口和编写相应的结构体映射\n\n定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Library;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.Structure;\nimport com.sun.jna.Structure.ByValue;\nimport com.sun.jna.ptr.IntByReference;\nimport com.sun.jna.win32.StdCallLibrary.StdCallCallback;\nimport com.sun.jna.Callback;\n\npublic interface NVSSDK extends Library {\n  public static class PicTime extends Structure {\n\n        public int uiYear;\n        public int uiMonth;\n        public int uiDay;\n        public int uiWeek;\n        public int uiHour;\n        public int uiMinute;\n        public int uiSecondsr;\n        public int uiMilliseconds;\n    }\n\n    public static class PicData extends Structure {\n        public PicData(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n\n        public PicTime tPicTime;\n        public int iDataLen;\n        public Pointer pcPicData;\n    }\n  public static class FacePicStream extends Structure {\n        public FacePicStream(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n        public int iStructLen;\n        public int iSizeOfFull;        \n        public Pointer tFullData;\n        public int iFaceCount;\n        public int iSizeOfFace;        \n        public Pointer[] tPicData = new Pointer[32];\n        public int iFaceFrameId;       \n        public PicTime tNewPicTime;\n    }\n   public static interface NET_PICSTREAM_NOTIFY extends StdCallCallback {\n        int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen,\n                          Pointer _lpUserData);\n    }\n\t public static class NetPicPara extends Structure {\n        public int iStructLen;                //Structure length\n        public int iChannelNo;\n        public NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        public Pointer pvUser;\n    }\n    int NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID);\n\n```\n\n上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。\n\n在另外一个类中加载动态库\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Native;\nimport com.sun.jna.ptr.IntByReference;\npublic class NetClient {\n    private static NVSSDK nvssdk;\n    private static NetClient netClient;\n    private NetClient() {\n    }\n\n    public static NetClient getInstance() {\n        if (netClient == null) {\n            synchronized (NetClient.class) {\n                if (netClient == null) {\n                    netClient = new NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(\"NVSSDK\",\n                            NVSSDK.class);\n                }\n            }\n        }\n        return netClient;\n    }\n   //开始接收图片流\n    public int StartRecvNetPicStream(int _iLogonID, NVSSDK.NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID) {\n        return nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    }\n}\n```\n\n##### 相关的头文件\n\n```c\ntypedef struct tagFacePicStream\n{\n\tint \t\t\tiStructLen;\t\t\t//Structure length\n\tint\t\t\t\tiSizeOfFull;\t\t//The size of strcut PicData\n\tPicData*\t\tptFullData;\t\t\t//The data of full screen\n\tint\t\t\t\tiFaceCount;\t\t\t//The current frame detects the number of face\n\tint\t\t\t\tiSizeOfFace;\t\t//The size of strcut FacePicData\n\tFacePicData*\tptFaceData[108];\n\tint\t\t\t\tiFaceFrameId;\t\t//The face jpeg frame no\n\tPicTime\t\t\ttNewPicTime;\t\t//The picture capture time, ptFullData contain time is out of date\n} FacePicStream, *pFacePicStream;\n\ntypedef struct tagSnapPicData\n{\n\tint \t\tiSnapType;\t\t//Snap type\n\tint \t\tiWidth;\t\t\t//Picture wide\n\tint \t\tiHeight;\t\t//Picture high\n\tint\t\t\tiSize;\t\t\t//The size of strcut PicData\n\tPicData*\tptPicData;\n} SnapPicData, *pSnapPicData;\n\ntypedef struct tagPicTime\n{\n\tunsigned int uiYear;\n\tunsigned int uiMonth;\n\tunsigned int uiDay;\n\tunsigned int uiWeek;\n\tunsigned int uiHour;\n\tunsigned int uiMinute;\n\tunsigned int uiSecondsr;\n\tunsigned int uiMilliseconds;\n} PicTime, *pPicTime;\n//回调\ntypedef int (__stdcall *NET_PICSTREAM_NOTIFY)(unsigned int _uiRecvID, long _lCommand, void* _pvBuf, int _iBufLen, void* _pvUser);\ntypedef struct tagNetPicPara\n{\n\tint \t\t\t\t\tiStructLen;\t\t\t\t//Structure length\n\tint\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\tvoid*\t\t\t\t\tpvUser;\n\tint\t\t\t\t\t\tiPicType;\t\t\t\t//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit0£ºFace picture stream \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit1£ºpedestrian \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit2:plate number\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit3:motor vehicles\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit4:Non-motor vehicle\n} NetPicPara, *pNetPicPara;\n//方法\nint __stdcall NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara* _ptPara, int _iBufLen, unsigned int* _puiRecvID);\n```\n\n##### 使用过程\n\n需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将**指针转换成头文件中对应的结构体**。\n\n```java \nprivate void SetPicQueue(final C4SCamera camera) {\n        NVSSDK.NetPicPara picPara = new NVSSDK.NetPicPara();\n        picPara.iChannelNo = 0;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = new NVSSDK.NET_PICSTREAM_NOTIFY() {\n            public int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen, Pointer _lpUserData) {\n                if (_tInfo == null || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) {\n                    return 0;\n                }\n                if (!camera.capture.get()) {\n                    return 0;\n                }\n                NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n                if (picStream.tFullData != null) {\n                    NVSSDK.PicData fullData = new NVSSDK.PicData(picStream.tFullData);\n                    if (fullData != null && fullData.iDataLen > 0 && camera.capture.get()) {\n                        byte[] data = fullData.pcPicData.getByteArray(0, fullData.iDataLen);\n                        FaceInfo faceInfo = new FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    }\n                }\n                return 0;\n            }\n        };\n        IntByReference relsize = new IntByReference();\n        int iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    }\n```\n\n#### 遇到的问题\n\n1. **java.lang.UnsatisfiedLinkError: Unable to load library 'NVSSDK':**\n\n   这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能\n\n   - jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk\n\n   - 还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。\n\n     ```java\n     System.setProperty(\"jna.library.path\", dllPath);\n     ```\n\n2. 在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。\n\n   - 结构体的构造方法,添加useMemory(pointer);和read();\n\n     ```java\n       public static class FacePicStream extends Structure{\n     \t\tpublic FacePicStream(Pointer pointer) {\n                 super(pointer);\n                 useMemory(pointer);\n                 read();\n             }    \n       }\n     ```\n\n   - 使用\n\n     ```java\n     Pointer _tInfo;\n     NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n     ```\n   \n3. Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。\n\n   ","slug":"java 之 JNA","published":1,"updated":"2020-11-09T11:06:47.372Z","_id":"ckghk0s0i0012mdymhh95dxbp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步<a href=\"https://github.com/java-native-access/jna\">官方文档</a>。</p>\n<p>不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">C基本类型</th>\n<th align=\"center\">长度</th>\n<th align=\"center\">Java类型</th>\n<th align=\"center\">Windows类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">8位整型</td>\n<td align=\"center\">byte</td>\n<td align=\"center\">BYTE、TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">16位整型</td>\n<td align=\"center\">short</td>\n<td align=\"center\">WORD</td>\n</tr>\n<tr>\n<td align=\"center\">wchar_t</td>\n<td align=\"center\">16/32位字符</td>\n<td align=\"center\">char</td>\n<td align=\"center\">TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">32位整型</td>\n<td align=\"center\">int</td>\n<td align=\"center\">DWORD</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">布尔值</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">BOOL</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">32/64位整型</td>\n<td align=\"center\">NativeLong</td>\n<td align=\"center\">LONG</td>\n</tr>\n<tr>\n<td align=\"center\">long long</td>\n<td align=\"center\">64位整型</td>\n<td align=\"center\">long</td>\n<td align=\"center\">__int64</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32位浮点型</td>\n<td align=\"center\">float</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">64位浮点型</td>\n<td align=\"center\">double</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">char*</td>\n<td align=\"center\">C字符串</td>\n<td align=\"center\">String</td>\n<td align=\"center\">LPTCSTR</td>\n</tr>\n<tr>\n<td align=\"center\">void*</td>\n<td align=\"center\">指针</td>\n<td align=\"center\">Pointer</td>\n<td align=\"center\">LPVOID、HANDLE、LP<em>XXX</em></td>\n</tr>\n</tbody></table>\n<h4 id=\"开发过程\"><a href=\"#开发过程\" class=\"headerlink\" title=\"开发过程\"></a>开发过程</h4><p>我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。</p>\n<h5 id=\"定义一个接口和编写相应的结构体映射\"><a href=\"#定义一个接口和编写相应的结构体映射\" class=\"headerlink\" title=\"定义一个接口和编写相应的结构体映射\"></a>定义一个接口和编写相应的结构体映射</h5><p>定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Library;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Pointer;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure.ByValue;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.win32.StdCallLibrary.StdCallCallback;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Callback;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NVSSDK</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Library</span> </span>&#123;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicTime</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiYear;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiDay;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiHour;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicData</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">PicData</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n\n        <span class=\"hljs-keyword\">public</span> PicTime tPicTime;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iDataLen;\n        <span class=\"hljs-keyword\">public</span> Pointer pcPicData;\n    &#125;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFull;        \n        <span class=\"hljs-keyword\">public</span> Pointer tFullData;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceCount;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFace;        \n        <span class=\"hljs-keyword\">public</span> Pointer[] tPicData = <span class=\"hljs-keyword\">new</span> Pointer[<span class=\"hljs-number\">32</span>];\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceFrameId;       \n        <span class=\"hljs-keyword\">public</span> PicTime tNewPicTime;\n    &#125;\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NET_PICSTREAM_NOTIFY</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StdCallCallback</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                          Pointer _lpUserData)</span></span>;\n    &#125;\n\t <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetPicPara</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;                <span class=\"hljs-comment\">//Structure length</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iChannelNo;\n        <span class=\"hljs-keyword\">public</span> NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        <span class=\"hljs-keyword\">public</span> Pointer pvUser;\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span></span>;\n</code></pre>\n\n<p>上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。</p>\n<p>在另外一个类中加载动态库</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Native;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetClient</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NVSSDK nvssdk;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NetClient netClient;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">NetClient</span><span class=\"hljs-params\">()</span> </span>&#123;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> NetClient <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">synchronized</span> (NetClient.class) &#123;\n                <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n                    netClient = <span class=\"hljs-keyword\">new</span> NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(<span class=\"hljs-string\">&quot;NVSSDK&quot;</span>,\n                            NVSSDK.class);\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> netClient;\n    &#125;\n   <span class=\"hljs-comment\">//开始接收图片流</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NVSSDK.NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"相关的头文件\"><a href=\"#相关的头文件\" class=\"headerlink\" title=\"相关的头文件\"></a>相关的头文件</h5><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagFacePicStream</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\tiStructLen;\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFull;\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\t\tptFullData;\t\t\t<span class=\"hljs-comment\">//The data of full screen</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceCount;\t\t\t<span class=\"hljs-comment\">//The current frame detects the number of face</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFace;\t\t<span class=\"hljs-comment\">//The size of strcut FacePicData</span>\n\tFacePicData*\tptFaceData[<span class=\"hljs-number\">108</span>];\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceFrameId;\t\t<span class=\"hljs-comment\">//The face jpeg frame no</span>\n\tPicTime\t\t\ttNewPicTime;\t\t<span class=\"hljs-comment\">//The picture capture time, ptFullData contain time is out of date</span>\n&#125; FacePicStream, *pFacePicStream;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagSnapPicData</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiSnapType;\t\t<span class=\"hljs-comment\">//Snap type</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiWidth;\t\t\t<span class=\"hljs-comment\">//Picture wide</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiHeight;\t\t<span class=\"hljs-comment\">//Picture high</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\tiSize;\t\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\tptPicData;\n&#125; SnapPicData, *pSnapPicData;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagPicTime</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiYear;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiDay;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiHour;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n&#125; PicTime, *pPicTime;\n<span class=\"hljs-comment\">//回调</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(__stdcall *NET_PICSTREAM_NOTIFY)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> _uiRecvID, <span class=\"hljs-keyword\">long</span> _lCommand, <span class=\"hljs-keyword\">void</span>* _pvBuf, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">void</span>* _pvUser)</span></span>;\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagNetPicPara</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\t\t\tiStructLen;\t\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\t<span class=\"hljs-keyword\">void</span>*\t\t\t\t\tpvUser;\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiPicType;\t\t\t\t<span class=\"hljs-comment\">//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit0£ºFace picture stream </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit1£ºpedestrian </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit2:plate number</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit3:motor vehicles</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit4:Non-motor vehicle</span>\n&#125; NetPicPara, *pNetPicPara;\n<span class=\"hljs-comment\">//方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> __stdcall <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara* _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>* _puiRecvID)</span></span>;</code></pre>\n\n<h5 id=\"使用过程\"><a href=\"#使用过程\" class=\"headerlink\" title=\"使用过程\"></a>使用过程</h5><p>需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将<strong>指针转换成头文件中对应的结构体</strong>。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SetPicQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> C4SCamera camera)</span> </span>&#123;\n        NVSSDK.NetPicPara picPara = <span class=\"hljs-keyword\">new</span> NVSSDK.NetPicPara();\n        picPara.iChannelNo = <span class=\"hljs-number\">0</span>;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = <span class=\"hljs-keyword\">new</span> NVSSDK.NET_PICSTREAM_NOTIFY() &#123;\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen, Pointer _lpUserData)</span> </span>&#123;\n                <span class=\"hljs-keyword\">if</span> (_tInfo == <span class=\"hljs-keyword\">null</span> || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (!camera.capture.get()) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                NVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);\n                <span class=\"hljs-keyword\">if</span> (picStream.tFullData != <span class=\"hljs-keyword\">null</span>) &#123;\n                    NVSSDK.PicData fullData = <span class=\"hljs-keyword\">new</span> NVSSDK.PicData(picStream.tFullData);\n                    <span class=\"hljs-keyword\">if</span> (fullData != <span class=\"hljs-keyword\">null</span> &amp;&amp; fullData.iDataLen &gt; <span class=\"hljs-number\">0</span> &amp;&amp; camera.capture.get()) &#123;\n                        <span class=\"hljs-keyword\">byte</span>[] data = fullData.pcPicData.getByteArray(<span class=\"hljs-number\">0</span>, fullData.iDataLen);\n                        FaceInfo faceInfo = <span class=\"hljs-keyword\">new</span> FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    &#125;\n                &#125;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n            &#125;\n        &#125;;\n        IntByReference relsize = <span class=\"hljs-keyword\">new</span> IntByReference();\n        <span class=\"hljs-keyword\">int</span> iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    &#125;</code></pre>\n\n<h4 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h4><ol>\n<li><p><strong>java.lang.UnsatisfiedLinkError: Unable to load library ‘NVSSDK’:</strong></p>\n<p>这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能</p>\n<ul>\n<li><p>jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk</p>\n</li>\n<li><p>还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。</p>\n<pre><code class=\"hljs java\">System.setProperty(<span class=\"hljs-string\">&quot;jna.library.path&quot;</span>, dllPath);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。</p>\n<ul>\n<li><p>结构体的构造方法,添加useMemory(pointer);和read();</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span></span>&#123;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n          <span class=\"hljs-keyword\">super</span>(pointer);\n          useMemory(pointer);\n          read();\n      &#125;    \n&#125;</code></pre>\n</li>\n<li><p>使用</p>\n<pre><code class=\"hljs java\">Pointer _tInfo;\nNVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步<a href=\"https://github.com/java-native-access/jna\">官方文档</a>。</p>\n<p>不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">C基本类型</th>\n<th align=\"center\">长度</th>\n<th align=\"center\">Java类型</th>\n<th align=\"center\">Windows类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">8位整型</td>\n<td align=\"center\">byte</td>\n<td align=\"center\">BYTE、TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">16位整型</td>\n<td align=\"center\">short</td>\n<td align=\"center\">WORD</td>\n</tr>\n<tr>\n<td align=\"center\">wchar_t</td>\n<td align=\"center\">16/32位字符</td>\n<td align=\"center\">char</td>\n<td align=\"center\">TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">32位整型</td>\n<td align=\"center\">int</td>\n<td align=\"center\">DWORD</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">布尔值</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">BOOL</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">32/64位整型</td>\n<td align=\"center\">NativeLong</td>\n<td align=\"center\">LONG</td>\n</tr>\n<tr>\n<td align=\"center\">long long</td>\n<td align=\"center\">64位整型</td>\n<td align=\"center\">long</td>\n<td align=\"center\">__int64</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32位浮点型</td>\n<td align=\"center\">float</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">64位浮点型</td>\n<td align=\"center\">double</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">char*</td>\n<td align=\"center\">C字符串</td>\n<td align=\"center\">String</td>\n<td align=\"center\">LPTCSTR</td>\n</tr>\n<tr>\n<td align=\"center\">void*</td>\n<td align=\"center\">指针</td>\n<td align=\"center\">Pointer</td>\n<td align=\"center\">LPVOID、HANDLE、LP<em>XXX</em></td>\n</tr>\n</tbody></table>\n<h4 id=\"开发过程\"><a href=\"#开发过程\" class=\"headerlink\" title=\"开发过程\"></a>开发过程</h4><p>我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。</p>\n<h5 id=\"定义一个接口和编写相应的结构体映射\"><a href=\"#定义一个接口和编写相应的结构体映射\" class=\"headerlink\" title=\"定义一个接口和编写相应的结构体映射\"></a>定义一个接口和编写相应的结构体映射</h5><p>定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Library;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Pointer;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure.ByValue;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.win32.StdCallLibrary.StdCallCallback;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Callback;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NVSSDK</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Library</span> </span>&#123;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicTime</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiYear;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiDay;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiHour;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicData</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">PicData</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n\n        <span class=\"hljs-keyword\">public</span> PicTime tPicTime;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iDataLen;\n        <span class=\"hljs-keyword\">public</span> Pointer pcPicData;\n    &#125;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFull;        \n        <span class=\"hljs-keyword\">public</span> Pointer tFullData;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceCount;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFace;        \n        <span class=\"hljs-keyword\">public</span> Pointer[] tPicData = <span class=\"hljs-keyword\">new</span> Pointer[<span class=\"hljs-number\">32</span>];\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceFrameId;       \n        <span class=\"hljs-keyword\">public</span> PicTime tNewPicTime;\n    &#125;\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NET_PICSTREAM_NOTIFY</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StdCallCallback</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                          Pointer _lpUserData)</span></span>;\n    &#125;\n\t <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetPicPara</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;                <span class=\"hljs-comment\">//Structure length</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iChannelNo;\n        <span class=\"hljs-keyword\">public</span> NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        <span class=\"hljs-keyword\">public</span> Pointer pvUser;\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span></span>;\n</code></pre>\n\n<p>上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。</p>\n<p>在另外一个类中加载动态库</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Native;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetClient</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NVSSDK nvssdk;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NetClient netClient;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">NetClient</span><span class=\"hljs-params\">()</span> </span>&#123;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> NetClient <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">synchronized</span> (NetClient.class) &#123;\n                <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n                    netClient = <span class=\"hljs-keyword\">new</span> NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(<span class=\"hljs-string\">&quot;NVSSDK&quot;</span>,\n                            NVSSDK.class);\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> netClient;\n    &#125;\n   <span class=\"hljs-comment\">//开始接收图片流</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NVSSDK.NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"相关的头文件\"><a href=\"#相关的头文件\" class=\"headerlink\" title=\"相关的头文件\"></a>相关的头文件</h5><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagFacePicStream</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\tiStructLen;\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFull;\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\t\tptFullData;\t\t\t<span class=\"hljs-comment\">//The data of full screen</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceCount;\t\t\t<span class=\"hljs-comment\">//The current frame detects the number of face</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFace;\t\t<span class=\"hljs-comment\">//The size of strcut FacePicData</span>\n\tFacePicData*\tptFaceData[<span class=\"hljs-number\">108</span>];\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceFrameId;\t\t<span class=\"hljs-comment\">//The face jpeg frame no</span>\n\tPicTime\t\t\ttNewPicTime;\t\t<span class=\"hljs-comment\">//The picture capture time, ptFullData contain time is out of date</span>\n&#125; FacePicStream, *pFacePicStream;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagSnapPicData</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiSnapType;\t\t<span class=\"hljs-comment\">//Snap type</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiWidth;\t\t\t<span class=\"hljs-comment\">//Picture wide</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiHeight;\t\t<span class=\"hljs-comment\">//Picture high</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\tiSize;\t\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\tptPicData;\n&#125; SnapPicData, *pSnapPicData;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagPicTime</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiYear;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiDay;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiHour;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n&#125; PicTime, *pPicTime;\n<span class=\"hljs-comment\">//回调</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(__stdcall *NET_PICSTREAM_NOTIFY)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> _uiRecvID, <span class=\"hljs-keyword\">long</span> _lCommand, <span class=\"hljs-keyword\">void</span>* _pvBuf, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">void</span>* _pvUser)</span></span>;\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagNetPicPara</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\t\t\tiStructLen;\t\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\t<span class=\"hljs-keyword\">void</span>*\t\t\t\t\tpvUser;\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiPicType;\t\t\t\t<span class=\"hljs-comment\">//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit0£ºFace picture stream </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit1£ºpedestrian </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit2:plate number</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit3:motor vehicles</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit4:Non-motor vehicle</span>\n&#125; NetPicPara, *pNetPicPara;\n<span class=\"hljs-comment\">//方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> __stdcall <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara* _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>* _puiRecvID)</span></span>;</code></pre>\n\n<h5 id=\"使用过程\"><a href=\"#使用过程\" class=\"headerlink\" title=\"使用过程\"></a>使用过程</h5><p>需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将<strong>指针转换成头文件中对应的结构体</strong>。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SetPicQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> C4SCamera camera)</span> </span>&#123;\n        NVSSDK.NetPicPara picPara = <span class=\"hljs-keyword\">new</span> NVSSDK.NetPicPara();\n        picPara.iChannelNo = <span class=\"hljs-number\">0</span>;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = <span class=\"hljs-keyword\">new</span> NVSSDK.NET_PICSTREAM_NOTIFY() &#123;\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen, Pointer _lpUserData)</span> </span>&#123;\n                <span class=\"hljs-keyword\">if</span> (_tInfo == <span class=\"hljs-keyword\">null</span> || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (!camera.capture.get()) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                NVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);\n                <span class=\"hljs-keyword\">if</span> (picStream.tFullData != <span class=\"hljs-keyword\">null</span>) &#123;\n                    NVSSDK.PicData fullData = <span class=\"hljs-keyword\">new</span> NVSSDK.PicData(picStream.tFullData);\n                    <span class=\"hljs-keyword\">if</span> (fullData != <span class=\"hljs-keyword\">null</span> &amp;&amp; fullData.iDataLen &gt; <span class=\"hljs-number\">0</span> &amp;&amp; camera.capture.get()) &#123;\n                        <span class=\"hljs-keyword\">byte</span>[] data = fullData.pcPicData.getByteArray(<span class=\"hljs-number\">0</span>, fullData.iDataLen);\n                        FaceInfo faceInfo = <span class=\"hljs-keyword\">new</span> FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    &#125;\n                &#125;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n            &#125;\n        &#125;;\n        IntByReference relsize = <span class=\"hljs-keyword\">new</span> IntByReference();\n        <span class=\"hljs-keyword\">int</span> iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    &#125;</code></pre>\n\n<h4 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h4><ol>\n<li><p><strong>java.lang.UnsatisfiedLinkError: Unable to load library ‘NVSSDK’:</strong></p>\n<p>这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能</p>\n<ul>\n<li><p>jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk</p>\n</li>\n<li><p>还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。</p>\n<pre><code class=\"hljs java\">System.setProperty(<span class=\"hljs-string\">&quot;jna.library.path&quot;</span>, dllPath);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。</p>\n<ul>\n<li><p>结构体的构造方法,添加useMemory(pointer);和read();</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span></span>&#123;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n          <span class=\"hljs-keyword\">super</span>(pointer);\n          useMemory(pointer);\n          read();\n      &#125;    \n&#125;</code></pre>\n</li>\n<li><p>使用</p>\n<pre><code class=\"hljs java\">Pointer _tInfo;\nNVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。</p>\n</li>\n</ol>\n"},{"title":"python 开发服务端","date":"2017-06-19T02:19:31.000Z","_content":"\n最新在开发微信公众号，选择了python做为后端开发的语言。之所以选择python作为开发语言，是因为python开发起来比较快，而且也容易上手。选用的python版本是python2.7.13\n\n\n\n## 先了解下python的一些基本知识\n\n- 在mac 上执行  `pip install xxx`会把包安装到哪里？\n\n  如果Mac上装了多个版本的Python，可以同过`python  --version`查看，然后会将包安装到`/usr/local/lib/pythonxxx/site-packages`下\n\n- 创建虚拟开发环境\n\n  在使用Python开发的时候，各个应用所需的Python版本可能不同，这时我们就需要一个独立的Python开发环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。\n\n  - 安装virtualenv\n\n    ```sh\n    pip install virtualenv\n    ```\n\n  - 创建一个目录并创建一个独立的Python环境venv\n\n    ```sh\n    mkdir testPython\n    cd testPython\n    virtualenv --no-site-packages venv\n    ```\n\n    **注：** 参数`--no-site-packages`，不会将系统已安装的第三方包复制过来，这样我们就得到一个干净的Python开发环境\n\n  - 使用这个venv环境\n\n    ```sh\n    source venv/bin/activate\n    ```\n\n    接下来`pip install xxx` 都会把Python包放在`testPython/venv/lib/python2.7/site-packages`目录下\n\n  - 离开venv 环境\n\n     ```sh\n     deactivte\n     ```\n\n  virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令`source venv/bin/activate`进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令`python`和`pip`均指向当前的virtualenv环境。\n\n\n\n\n​\t**注：** 使用venv 环境之后，执行`pip install xxxx` ，它会把这些依赖包安装在`venv/lib/python2.7/site-packages`目录下\n\n- 依赖第三方库的统一配置文件 **requirements.txt**\n\n  ```text\n  Flask==0.12\n  ```\n\n  通过`pip install -r requirements.txt`来安装文件中依赖的一些第三方库\n\n\n\n\n<!-- more -->\n\n\n\n## 项目开发\n\nflask是python的一个轻量级Web应用框架，对于一些小的站点来说flask，已经能够满足需求了。执行`pip install flask`安装。[flask 官网](http://flask.pocoo.org/)\n\n创建一个run.py文件，写如以下代码。然后执行python run.py，一个简易的web服务就OK了。访问localhost:8080端口\n\n```python\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/test', methods=['GET', 'POST'])\ndef test():\n    return jsonify({'msg':'hello world'})\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n```\n\n\n\n链接数据库使用的sqlalchemy,\tsqlalchemy 是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。[SQLAlchemy官网](http://www.sqlalchemy.org/)\n\n\n- 本地机器已经安装了mysql，但是在使用sqlalchemy 报No module named mysql。\n\n   ```python \n   pip install pymysql\n   ```\n\n- 链接数据库样例\n\n   ```python\n   from sqlalchemy import Column, String, create_engine\n\n   # 初始化数据库连接:\n   engine = create_engine('mysql+pymysql://'+username+':'+password+'@localhost:3306/doudouSpace')\n\n   def create_user_table():\n       connect = engine.connect()\n       try:\n           result = connect.execute('xxxx') #xxx 表示sql语句\n           result.close()\n       except Exception as e:\n           print e\n\n   ```\n\n   **注：**更多详细文档请参考官网\n\n\n\n日志模块也是开发工作中的一个重要部分，可以方便我们调试开发。我们使用python自带的logging模块，我们要将日志信息输出到文件中，而不是只输出到控制台中。\n\n- 封装下日志模块\n\n  ```python\n  import logging\n  from logging.handlers import RotatingFileHandler\n  from . import config\n  \n  log_filename = 'output.log'\n  logging.basicConfig(level=logging.DEBUG,\n                      format='%(filename)s:%(lineno)s - %(asctime)s %(levelname)s %(message)s',\n                      filename=log_filename,\n                      filemode='a')\n  \n  logger = logging.getLogger()\n  log_handler = logging.handlers.WatchedFileHandler(log_filename)\n  logger.addHandler(log_handler)\n   \n  def debug(msg):\n      # logging.debug(msg)\n      logger.debug(msg)\n  \n  def info(msg):\n      # logging.info(msg)\n      logger.info(msg)\n  \n  def warning(msg):\n      # logging.warning(msg)\n      logger.warning(msg)\n  \n  def error(msg):\n      # logging.error(msg)\n      logger.error(msg)\n      \n  ```\n  其他的一些在这里就不在过多的介绍了，我做了一个python开发后端rest接口的模版工程，放在GitHub上，有兴趣的话可以看看[python_tmplate](https://github.com/Cocoon-break/python_tmplate) ","source":"_posts/python 开发服务端.md","raw":"---\ntitle: python 开发服务端\ndate: 2017-06-19 10:19:31\ntags:\n- Python\ncategories:\n- Python\n---\n\n最新在开发微信公众号，选择了python做为后端开发的语言。之所以选择python作为开发语言，是因为python开发起来比较快，而且也容易上手。选用的python版本是python2.7.13\n\n\n\n## 先了解下python的一些基本知识\n\n- 在mac 上执行  `pip install xxx`会把包安装到哪里？\n\n  如果Mac上装了多个版本的Python，可以同过`python  --version`查看，然后会将包安装到`/usr/local/lib/pythonxxx/site-packages`下\n\n- 创建虚拟开发环境\n\n  在使用Python开发的时候，各个应用所需的Python版本可能不同，这时我们就需要一个独立的Python开发环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。\n\n  - 安装virtualenv\n\n    ```sh\n    pip install virtualenv\n    ```\n\n  - 创建一个目录并创建一个独立的Python环境venv\n\n    ```sh\n    mkdir testPython\n    cd testPython\n    virtualenv --no-site-packages venv\n    ```\n\n    **注：** 参数`--no-site-packages`，不会将系统已安装的第三方包复制过来，这样我们就得到一个干净的Python开发环境\n\n  - 使用这个venv环境\n\n    ```sh\n    source venv/bin/activate\n    ```\n\n    接下来`pip install xxx` 都会把Python包放在`testPython/venv/lib/python2.7/site-packages`目录下\n\n  - 离开venv 环境\n\n     ```sh\n     deactivte\n     ```\n\n  virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令`source venv/bin/activate`进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令`python`和`pip`均指向当前的virtualenv环境。\n\n\n\n\n​\t**注：** 使用venv 环境之后，执行`pip install xxxx` ，它会把这些依赖包安装在`venv/lib/python2.7/site-packages`目录下\n\n- 依赖第三方库的统一配置文件 **requirements.txt**\n\n  ```text\n  Flask==0.12\n  ```\n\n  通过`pip install -r requirements.txt`来安装文件中依赖的一些第三方库\n\n\n\n\n<!-- more -->\n\n\n\n## 项目开发\n\nflask是python的一个轻量级Web应用框架，对于一些小的站点来说flask，已经能够满足需求了。执行`pip install flask`安装。[flask 官网](http://flask.pocoo.org/)\n\n创建一个run.py文件，写如以下代码。然后执行python run.py，一个简易的web服务就OK了。访问localhost:8080端口\n\n```python\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/test', methods=['GET', 'POST'])\ndef test():\n    return jsonify({'msg':'hello world'})\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n```\n\n\n\n链接数据库使用的sqlalchemy,\tsqlalchemy 是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。[SQLAlchemy官网](http://www.sqlalchemy.org/)\n\n\n- 本地机器已经安装了mysql，但是在使用sqlalchemy 报No module named mysql。\n\n   ```python \n   pip install pymysql\n   ```\n\n- 链接数据库样例\n\n   ```python\n   from sqlalchemy import Column, String, create_engine\n\n   # 初始化数据库连接:\n   engine = create_engine('mysql+pymysql://'+username+':'+password+'@localhost:3306/doudouSpace')\n\n   def create_user_table():\n       connect = engine.connect()\n       try:\n           result = connect.execute('xxxx') #xxx 表示sql语句\n           result.close()\n       except Exception as e:\n           print e\n\n   ```\n\n   **注：**更多详细文档请参考官网\n\n\n\n日志模块也是开发工作中的一个重要部分，可以方便我们调试开发。我们使用python自带的logging模块，我们要将日志信息输出到文件中，而不是只输出到控制台中。\n\n- 封装下日志模块\n\n  ```python\n  import logging\n  from logging.handlers import RotatingFileHandler\n  from . import config\n  \n  log_filename = 'output.log'\n  logging.basicConfig(level=logging.DEBUG,\n                      format='%(filename)s:%(lineno)s - %(asctime)s %(levelname)s %(message)s',\n                      filename=log_filename,\n                      filemode='a')\n  \n  logger = logging.getLogger()\n  log_handler = logging.handlers.WatchedFileHandler(log_filename)\n  logger.addHandler(log_handler)\n   \n  def debug(msg):\n      # logging.debug(msg)\n      logger.debug(msg)\n  \n  def info(msg):\n      # logging.info(msg)\n      logger.info(msg)\n  \n  def warning(msg):\n      # logging.warning(msg)\n      logger.warning(msg)\n  \n  def error(msg):\n      # logging.error(msg)\n      logger.error(msg)\n      \n  ```\n  其他的一些在这里就不在过多的介绍了，我做了一个python开发后端rest接口的模版工程，放在GitHub上，有兴趣的话可以看看[python_tmplate](https://github.com/Cocoon-break/python_tmplate) ","slug":"python 开发服务端","published":1,"updated":"2020-02-27T03:47:53.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0i0015mdym4zpcbcvf","content":"<p>最新在开发微信公众号，选择了python做为后端开发的语言。之所以选择python作为开发语言，是因为python开发起来比较快，而且也容易上手。选用的python版本是python2.7.13</p>\n<h2 id=\"先了解下python的一些基本知识\"><a href=\"#先了解下python的一些基本知识\" class=\"headerlink\" title=\"先了解下python的一些基本知识\"></a>先了解下python的一些基本知识</h2><ul>\n<li><p>在mac 上执行  <code>pip install xxx</code>会把包安装到哪里？</p>\n<p>如果Mac上装了多个版本的Python，可以同过<code>python  --version</code>查看，然后会将包安装到<code>/usr/local/lib/pythonxxx/site-packages</code>下</p>\n</li>\n<li><p>创建虚拟开发环境</p>\n<p>在使用Python开发的时候，各个应用所需的Python版本可能不同，这时我们就需要一个独立的Python开发环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>\n<ul>\n<li><p>安装virtualenv</p>\n<pre><code class=\"hljs sh\">pip install virtualenv</code></pre>\n</li>\n<li><p>创建一个目录并创建一个独立的Python环境venv</p>\n<pre><code class=\"hljs sh\">mkdir testPython\n<span class=\"hljs-built_in\">cd</span> testPython\nvirtualenv --no-site-packages venv</code></pre>\n\n<p><strong>注：</strong> 参数<code>--no-site-packages</code>，不会将系统已安装的第三方包复制过来，这样我们就得到一个干净的Python开发环境</p>\n</li>\n<li><p>使用这个venv环境</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">source</span> venv/bin/activate</code></pre>\n\n<p>接下来<code>pip install xxx</code> 都会把Python包放在<code>testPython/venv/lib/python2.7/site-packages</code>目录下</p>\n</li>\n<li><p>离开venv 环境</p>\n <pre><code class=\"hljs sh\">deactivte</code></pre>\n\n</li>\n</ul>\n<p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令<code>source venv/bin/activate</code>进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令<code>python</code>和<code>pip</code>均指向当前的virtualenv环境。</p>\n</li>\n</ul>\n<p>​    <strong>注：</strong> 使用venv 环境之后，执行<code>pip install xxxx</code> ，它会把这些依赖包安装在<code>venv/lib/python2.7/site-packages</code>目录下</p>\n<ul>\n<li><p>依赖第三方库的统一配置文件 <strong>requirements.txt</strong></p>\n<pre><code class=\"hljs text\">Flask==0.12</code></pre>\n\n<p>通过<code>pip install -r requirements.txt</code>来安装文件中依赖的一些第三方库</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n\n\n<h2 id=\"项目开发\"><a href=\"#项目开发\" class=\"headerlink\" title=\"项目开发\"></a>项目开发</h2><p>flask是python的一个轻量级Web应用框架，对于一些小的站点来说flask，已经能够满足需求了。执行<code>pip install flask</code>安装。<a href=\"http://flask.pocoo.org/\">flask 官网</a></p>\n<p>创建一个run.py文件，写如以下代码。然后执行python run.py，一个简易的web服务就OK了。访问localhost:8080端口</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask, request\n\napp = Flask(__name__)\n\n<span class=\"hljs-meta\">@app.route(&#x27;/test&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">test</span>():</span>\n    <span class=\"hljs-keyword\">return</span> jsonify(&#123;<span class=\"hljs-string\">&#x27;msg&#x27;</span>:<span class=\"hljs-string\">&#x27;hello world&#x27;</span>&#125;)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:\n    app.run(host=<span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>, port=<span class=\"hljs-number\">8080</span>)</code></pre>\n\n\n\n<p>链接数据库使用的sqlalchemy,    sqlalchemy 是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。<a href=\"http://www.sqlalchemy.org/\">SQLAlchemy官网</a></p>\n<ul>\n<li><p>本地机器已经安装了mysql，但是在使用sqlalchemy 报No module named mysql。</p>\n <pre><code class=\"hljs python\">pip install pymysql</code></pre>\n</li>\n<li><p>链接数据库样例</p>\n <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> sqlalchemy <span class=\"hljs-keyword\">import</span> Column, String, create_engine\n\n<span class=\"hljs-comment\"># 初始化数据库连接:</span>\nengine = create_engine(<span class=\"hljs-string\">&#x27;mysql+pymysql://&#x27;</span>+username+<span class=\"hljs-string\">&#x27;:&#x27;</span>+password+<span class=\"hljs-string\">&#x27;@localhost:3306/doudouSpace&#x27;</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">create_user_table</span>():</span>\n    connect = engine.connect()\n    <span class=\"hljs-keyword\">try</span>:\n        result = connect.execute(<span class=\"hljs-string\">&#x27;xxxx&#x27;</span>) <span class=\"hljs-comment\">#xxx 表示sql语句</span>\n        result.close()\n    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n        <span class=\"hljs-built_in\">print</span> e\n</code></pre>\n\n<p> <strong>注：</strong>更多详细文档请参考官网</p>\n</li>\n</ul>\n<p>日志模块也是开发工作中的一个重要部分，可以方便我们调试开发。我们使用python自带的logging模块，我们要将日志信息输出到文件中，而不是只输出到控制台中。</p>\n<ul>\n<li><p>封装下日志模块</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">from</span> logging.handlers <span class=\"hljs-keyword\">import</span> RotatingFileHandler\n<span class=\"hljs-keyword\">from</span> . <span class=\"hljs-keyword\">import</span> config\n\nlog_filename = <span class=\"hljs-string\">&#x27;output.log&#x27;</span>\nlogging.basicConfig(level=logging.DEBUG,\n                    <span class=\"hljs-built_in\">format</span>=<span class=\"hljs-string\">&#x27;%(filename)s:%(lineno)s - %(asctime)s %(levelname)s %(message)s&#x27;</span>,\n                    filename=log_filename,\n                    filemode=<span class=\"hljs-string\">&#x27;a&#x27;</span>)\n\nlogger = logging.getLogger()\nlog_handler = logging.handlers.WatchedFileHandler(log_filename)\nlogger.addHandler(log_handler)\n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">debug</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.debug(msg)</span>\n    logger.debug(msg)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">info</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.info(msg)</span>\n    logger.info(msg)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">warning</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.warning(msg)</span>\n    logger.warning(msg)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">error</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.error(msg)</span>\n    logger.error(msg)</code></pre>\n<p>其他的一些在这里就不在过多的介绍了，我做了一个python开发后端rest接口的模版工程，放在GitHub上，有兴趣的话可以看看<a href=\"https://github.com/Cocoon-break/python_tmplate\">python_tmplate</a> </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最新在开发微信公众号，选择了python做为后端开发的语言。之所以选择python作为开发语言，是因为python开发起来比较快，而且也容易上手。选用的python版本是python2.7.13</p>\n<h2 id=\"先了解下python的一些基本知识\"><a href=\"#先了解下python的一些基本知识\" class=\"headerlink\" title=\"先了解下python的一些基本知识\"></a>先了解下python的一些基本知识</h2><ul>\n<li><p>在mac 上执行  <code>pip install xxx</code>会把包安装到哪里？</p>\n<p>如果Mac上装了多个版本的Python，可以同过<code>python  --version</code>查看，然后会将包安装到<code>/usr/local/lib/pythonxxx/site-packages</code>下</p>\n</li>\n<li><p>创建虚拟开发环境</p>\n<p>在使用Python开发的时候，各个应用所需的Python版本可能不同，这时我们就需要一个独立的Python开发环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>\n<ul>\n<li><p>安装virtualenv</p>\n<pre><code class=\"hljs sh\">pip install virtualenv</code></pre>\n</li>\n<li><p>创建一个目录并创建一个独立的Python环境venv</p>\n<pre><code class=\"hljs sh\">mkdir testPython\n<span class=\"hljs-built_in\">cd</span> testPython\nvirtualenv --no-site-packages venv</code></pre>\n\n<p><strong>注：</strong> 参数<code>--no-site-packages</code>，不会将系统已安装的第三方包复制过来，这样我们就得到一个干净的Python开发环境</p>\n</li>\n<li><p>使用这个venv环境</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">source</span> venv/bin/activate</code></pre>\n\n<p>接下来<code>pip install xxx</code> 都会把Python包放在<code>testPython/venv/lib/python2.7/site-packages</code>目录下</p>\n</li>\n<li><p>离开venv 环境</p>\n <pre><code class=\"hljs sh\">deactivte</code></pre>\n\n</li>\n</ul>\n<p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令<code>source venv/bin/activate</code>进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令<code>python</code>和<code>pip</code>均指向当前的virtualenv环境。</p>\n</li>\n</ul>\n<p>​    <strong>注：</strong> 使用venv 环境之后，执行<code>pip install xxxx</code> ，它会把这些依赖包安装在<code>venv/lib/python2.7/site-packages</code>目录下</p>\n<ul>\n<li><p>依赖第三方库的统一配置文件 <strong>requirements.txt</strong></p>\n<pre><code class=\"hljs text\">Flask==0.12</code></pre>\n\n<p>通过<code>pip install -r requirements.txt</code>来安装文件中依赖的一些第三方库</p>\n</li>\n</ul>","more":"<h2 id=\"项目开发\"><a href=\"#项目开发\" class=\"headerlink\" title=\"项目开发\"></a>项目开发</h2><p>flask是python的一个轻量级Web应用框架，对于一些小的站点来说flask，已经能够满足需求了。执行<code>pip install flask</code>安装。<a href=\"http://flask.pocoo.org/\">flask 官网</a></p>\n<p>创建一个run.py文件，写如以下代码。然后执行python run.py，一个简易的web服务就OK了。访问localhost:8080端口</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask, request\n\napp = Flask(__name__)\n\n<span class=\"hljs-meta\">@app.route(&#x27;/test&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">test</span>():</span>\n    <span class=\"hljs-keyword\">return</span> jsonify(&#123;<span class=\"hljs-string\">&#x27;msg&#x27;</span>:<span class=\"hljs-string\">&#x27;hello world&#x27;</span>&#125;)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:\n    app.run(host=<span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>, port=<span class=\"hljs-number\">8080</span>)</code></pre>\n\n\n\n<p>链接数据库使用的sqlalchemy,    sqlalchemy 是Python SQL工具包和对象关系映射器，为应用程序开发人员提供了SQL的全部功能和灵活性。<a href=\"http://www.sqlalchemy.org/\">SQLAlchemy官网</a></p>\n<ul>\n<li><p>本地机器已经安装了mysql，但是在使用sqlalchemy 报No module named mysql。</p>\n <pre><code class=\"hljs python\">pip install pymysql</code></pre>\n</li>\n<li><p>链接数据库样例</p>\n <pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> sqlalchemy <span class=\"hljs-keyword\">import</span> Column, String, create_engine\n\n<span class=\"hljs-comment\"># 初始化数据库连接:</span>\nengine = create_engine(<span class=\"hljs-string\">&#x27;mysql+pymysql://&#x27;</span>+username+<span class=\"hljs-string\">&#x27;:&#x27;</span>+password+<span class=\"hljs-string\">&#x27;@localhost:3306/doudouSpace&#x27;</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">create_user_table</span>():</span>\n    connect = engine.connect()\n    <span class=\"hljs-keyword\">try</span>:\n        result = connect.execute(<span class=\"hljs-string\">&#x27;xxxx&#x27;</span>) <span class=\"hljs-comment\">#xxx 表示sql语句</span>\n        result.close()\n    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n        <span class=\"hljs-built_in\">print</span> e\n</code></pre>\n\n<p> <strong>注：</strong>更多详细文档请参考官网</p>\n</li>\n</ul>\n<p>日志模块也是开发工作中的一个重要部分，可以方便我们调试开发。我们使用python自带的logging模块，我们要将日志信息输出到文件中，而不是只输出到控制台中。</p>\n<ul>\n<li><p>封装下日志模块</p>\n<pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> logging\n<span class=\"hljs-keyword\">from</span> logging.handlers <span class=\"hljs-keyword\">import</span> RotatingFileHandler\n<span class=\"hljs-keyword\">from</span> . <span class=\"hljs-keyword\">import</span> config\n\nlog_filename = <span class=\"hljs-string\">&#x27;output.log&#x27;</span>\nlogging.basicConfig(level=logging.DEBUG,\n                    <span class=\"hljs-built_in\">format</span>=<span class=\"hljs-string\">&#x27;%(filename)s:%(lineno)s - %(asctime)s %(levelname)s %(message)s&#x27;</span>,\n                    filename=log_filename,\n                    filemode=<span class=\"hljs-string\">&#x27;a&#x27;</span>)\n\nlogger = logging.getLogger()\nlog_handler = logging.handlers.WatchedFileHandler(log_filename)\nlogger.addHandler(log_handler)\n \n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">debug</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.debug(msg)</span>\n    logger.debug(msg)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">info</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.info(msg)</span>\n    logger.info(msg)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">warning</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.warning(msg)</span>\n    logger.warning(msg)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">error</span>(<span class=\"hljs-params\">msg</span>):</span>\n    <span class=\"hljs-comment\"># logging.error(msg)</span>\n    logger.error(msg)</code></pre>\n<p>其他的一些在这里就不在过多的介绍了，我做了一个python开发后端rest接口的模版工程，放在GitHub上，有兴趣的话可以看看<a href=\"https://github.com/Cocoon-break/python_tmplate\">python_tmplate</a> </p>\n</li>\n</ul>"},{"title":"xargs 和 jq","date":"2017-07-05T05:45:12.000Z","_content":"\n​\txargs是Linux系统上自带的命令，xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。jq 不是Linux系统自带的命令，需要自行安装。jq主要在Linux上解析json。\n\n## xargs\n\n​\t举一个例子，我们常用的一个命令`rm -rf *.log` 如果文件log文件太多我们会得到一个异常的信/bin/rm Argument list too long，也就是说rm能接受的参数是有限的。这时我们就可以利用xargs 过滤。\n\n```sh\nls *.log | xargs rm -rf \n```\n\nls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。\n\n**题外话：** Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：`rm -rf -xxxx.log`是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。可以通过在文件名前加两个减号解决。\n\n如`rm -rf -- -xxxx.log`\n\n​\txargs 的具体用法，还是一个文件夹中有一大堆文件，通过`ls`可以将文件多行输出。但是我想单行或者指定行数输出呢！通过给xargs指定-n 参数。\n\n```sh\nls *.log | xargs -n2 #-n2 就是指定两行输出，-n3就是三行输出，以此类推\n```\n\n前面都是一些简易的操作，感觉不到xargs 到底是怎么处理管道出来的文件。现在我的一个需求是将所有的log文件复制到指定目录下。普通复制命令`cp xxx.log /var/log`。我们先忽略cp 命令有-r参数。先看看以下写法是否正确\n\n<!-- more -->\n\n```sh\nls *.log | xargs cp /var/log\n```\n\n你一看立马就觉得不对，cp 不是接受两个参数吗？一个文件，一个目标文件或路径。可是又不知道怎么去解决这个事。在我们上面的例子都真正没有去理解xargs，如`ls *.log | xargs rm -rf ` 为什么能好使？ls出来的文件通过管道传递给xargs 过滤，然后xargs 过滤出的文件默认追加到命令行的最后。但是在这个例子中，我们不想将xargs吐出来的放到命令行的最后。xargs的占位符就发挥作用了，将上面的命令修改\n\n ```sh\nls *.log | xargs -I {} cp {}  /var/log/\n ```\n\n通过`-I`参数指定大括号为占位符，cp后的大括号就是xargs 吐出来的文件名。这里不一定使用大括号，也可指定其他的符号。`-i`默认的占位符就是大括号\n\n```sh\nls *.log | xargs -i cp {} /var/log/\n```\n\nxargs还有一个-P的参数，是指定xargs同时处理多少个命令。但是感觉没什么效果。例子`ls *.log | xargs -P 8 -i cp {} /var/log/`\n\nxargs 的使用就讲到这里\n\n## jq\n\njq 命令并不是Linux系统自带的，所以我们需要格外安装。[下载的地址](https://stedolan.github.io/jq/download/)\n\njq 的官方说法是jq is like `sed` for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that `sed`, `awk`, `grep` and friends let you play with text。使用jq在Linux系统上去处理json是非常方便的。比如在终端上curl一个接口，返回一个json，这个json可能很长，我只想看其中部分数据，就可以用上jq了。\n\njq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。哈哈哈\n\n[ 官方教程](https://stedolan.github.io/jq/tutorial/)\n\n\n\n## 自己实践的例子\n\n前段时间有需要将两万张的照片去发起请求，然后处理curl返回的结果。利用了xargs和jq。将命令贴出来记录一下。\n\n```sh\nls TP | xargs -i -n1 curl -s -F img=@TP/{} http://127.0.0.1:9001/faceid/v1/liveness_cfg                                                                 | jq -c -r '[.liveness.mask,.liveness.replay,.liveness.graphics]' > TP.txt &\n```\n\nTP就是有两万张照片的文件夹，将请求的结果通过jq处理，然后输出到TP.txt文件 中","source":"_posts/xargs和jq.md","raw":"---\ntitle: xargs 和 jq\ndate: 2017-07-05 13:45:12\ntags: \n- shell\ncategories:\n- Linux\n---\n\n​\txargs是Linux系统上自带的命令，xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。jq 不是Linux系统自带的命令，需要自行安装。jq主要在Linux上解析json。\n\n## xargs\n\n​\t举一个例子，我们常用的一个命令`rm -rf *.log` 如果文件log文件太多我们会得到一个异常的信/bin/rm Argument list too long，也就是说rm能接受的参数是有限的。这时我们就可以利用xargs 过滤。\n\n```sh\nls *.log | xargs rm -rf \n```\n\nls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。\n\n**题外话：** Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：`rm -rf -xxxx.log`是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。可以通过在文件名前加两个减号解决。\n\n如`rm -rf -- -xxxx.log`\n\n​\txargs 的具体用法，还是一个文件夹中有一大堆文件，通过`ls`可以将文件多行输出。但是我想单行或者指定行数输出呢！通过给xargs指定-n 参数。\n\n```sh\nls *.log | xargs -n2 #-n2 就是指定两行输出，-n3就是三行输出，以此类推\n```\n\n前面都是一些简易的操作，感觉不到xargs 到底是怎么处理管道出来的文件。现在我的一个需求是将所有的log文件复制到指定目录下。普通复制命令`cp xxx.log /var/log`。我们先忽略cp 命令有-r参数。先看看以下写法是否正确\n\n<!-- more -->\n\n```sh\nls *.log | xargs cp /var/log\n```\n\n你一看立马就觉得不对，cp 不是接受两个参数吗？一个文件，一个目标文件或路径。可是又不知道怎么去解决这个事。在我们上面的例子都真正没有去理解xargs，如`ls *.log | xargs rm -rf ` 为什么能好使？ls出来的文件通过管道传递给xargs 过滤，然后xargs 过滤出的文件默认追加到命令行的最后。但是在这个例子中，我们不想将xargs吐出来的放到命令行的最后。xargs的占位符就发挥作用了，将上面的命令修改\n\n ```sh\nls *.log | xargs -I {} cp {}  /var/log/\n ```\n\n通过`-I`参数指定大括号为占位符，cp后的大括号就是xargs 吐出来的文件名。这里不一定使用大括号，也可指定其他的符号。`-i`默认的占位符就是大括号\n\n```sh\nls *.log | xargs -i cp {} /var/log/\n```\n\nxargs还有一个-P的参数，是指定xargs同时处理多少个命令。但是感觉没什么效果。例子`ls *.log | xargs -P 8 -i cp {} /var/log/`\n\nxargs 的使用就讲到这里\n\n## jq\n\njq 命令并不是Linux系统自带的，所以我们需要格外安装。[下载的地址](https://stedolan.github.io/jq/download/)\n\njq 的官方说法是jq is like `sed` for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that `sed`, `awk`, `grep` and friends let you play with text。使用jq在Linux系统上去处理json是非常方便的。比如在终端上curl一个接口，返回一个json，这个json可能很长，我只想看其中部分数据，就可以用上jq了。\n\njq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。哈哈哈\n\n[ 官方教程](https://stedolan.github.io/jq/tutorial/)\n\n\n\n## 自己实践的例子\n\n前段时间有需要将两万张的照片去发起请求，然后处理curl返回的结果。利用了xargs和jq。将命令贴出来记录一下。\n\n```sh\nls TP | xargs -i -n1 curl -s -F img=@TP/{} http://127.0.0.1:9001/faceid/v1/liveness_cfg                                                                 | jq -c -r '[.liveness.mask,.liveness.replay,.liveness.graphics]' > TP.txt &\n```\n\nTP就是有两万张照片的文件夹，将请求的结果通过jq处理，然后输出到TP.txt文件 中","slug":"xargs和jq","published":1,"updated":"2020-02-27T03:54:00.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0k0019mdymgifths4p","content":"<p>​    xargs是Linux系统上自带的命令，xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。jq 不是Linux系统自带的命令，需要自行安装。jq主要在Linux上解析json。</p>\n<h2 id=\"xargs\"><a href=\"#xargs\" class=\"headerlink\" title=\"xargs\"></a>xargs</h2><p>​    举一个例子，我们常用的一个命令<code>rm -rf *.log</code> 如果文件log文件太多我们会得到一个异常的信/bin/rm Argument list too long，也就是说rm能接受的参数是有限的。这时我们就可以利用xargs 过滤。</p>\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs rm -rf</code></pre>\n\n<p>ls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。</p>\n<p><strong>题外话：</strong> Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：<code>rm -rf -xxxx.log</code>是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。可以通过在文件名前加两个减号解决。</p>\n<p>如<code>rm -rf -- -xxxx.log</code></p>\n<p>​    xargs 的具体用法，还是一个文件夹中有一大堆文件，通过<code>ls</code>可以将文件多行输出。但是我想单行或者指定行数输出呢！通过给xargs指定-n 参数。</p>\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs -n2 <span class=\"hljs-comment\">#-n2 就是指定两行输出，-n3就是三行输出，以此类推</span></code></pre>\n\n<p>前面都是一些简易的操作，感觉不到xargs 到底是怎么处理管道出来的文件。现在我的一个需求是将所有的log文件复制到指定目录下。普通复制命令<code>cp xxx.log /var/log</code>。我们先忽略cp 命令有-r参数。先看看以下写法是否正确</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs cp /var/<span class=\"hljs-built_in\">log</span></code></pre>\n\n<p>你一看立马就觉得不对，cp 不是接受两个参数吗？一个文件，一个目标文件或路径。可是又不知道怎么去解决这个事。在我们上面的例子都真正没有去理解xargs，如<code>ls *.log | xargs rm -rf </code> 为什么能好使？ls出来的文件通过管道传递给xargs 过滤，然后xargs 过滤出的文件默认追加到命令行的最后。但是在这个例子中，我们不想将xargs吐出来的放到命令行的最后。xargs的占位符就发挥作用了，将上面的命令修改</p>\n <pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs -I &#123;&#125; cp &#123;&#125;  /var/<span class=\"hljs-built_in\">log</span>/</code></pre>\n\n<p>通过<code>-I</code>参数指定大括号为占位符，cp后的大括号就是xargs 吐出来的文件名。这里不一定使用大括号，也可指定其他的符号。<code>-i</code>默认的占位符就是大括号</p>\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs -i cp &#123;&#125; /var/<span class=\"hljs-built_in\">log</span>/</code></pre>\n\n<p>xargs还有一个-P的参数，是指定xargs同时处理多少个命令。但是感觉没什么效果。例子<code>ls *.log | xargs -P 8 -i cp &#123;&#125; /var/log/</code></p>\n<p>xargs 的使用就讲到这里</p>\n<h2 id=\"jq\"><a href=\"#jq\" class=\"headerlink\" title=\"jq\"></a>jq</h2><p>jq 命令并不是Linux系统自带的，所以我们需要格外安装。<a href=\"https://stedolan.github.io/jq/download/\">下载的地址</a></p>\n<p>jq 的官方说法是jq is like <code>sed</code> for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that <code>sed</code>, <code>awk</code>, <code>grep</code> and friends let you play with text。使用jq在Linux系统上去处理json是非常方便的。比如在终端上curl一个接口，返回一个json，这个json可能很长，我只想看其中部分数据，就可以用上jq了。</p>\n<p>jq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。哈哈哈</p>\n<p><a href=\"https://stedolan.github.io/jq/tutorial/\"> 官方教程</a></p>\n<h2 id=\"自己实践的例子\"><a href=\"#自己实践的例子\" class=\"headerlink\" title=\"自己实践的例子\"></a>自己实践的例子</h2><p>前段时间有需要将两万张的照片去发起请求，然后处理curl返回的结果。利用了xargs和jq。将命令贴出来记录一下。</p>\n<pre><code class=\"hljs sh\">ls TP | xargs -i -n1 curl -s -F img=@TP/&#123;&#125; http://127.0.0.1:9001/faceid/v1/liveness_cfg                                                                 | jq -c -r <span class=\"hljs-string\">&#x27;[.liveness.mask,.liveness.replay,.liveness.graphics]&#x27;</span> &gt; TP.txt &amp;</code></pre>\n\n<p>TP就是有两万张照片的文件夹，将请求的结果通过jq处理，然后输出到TP.txt文件 中</p>\n","site":{"data":{}},"excerpt":"<p>​    xargs是Linux系统上自带的命令，xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。jq 不是Linux系统自带的命令，需要自行安装。jq主要在Linux上解析json。</p>\n<h2 id=\"xargs\"><a href=\"#xargs\" class=\"headerlink\" title=\"xargs\"></a>xargs</h2><p>​    举一个例子，我们常用的一个命令<code>rm -rf *.log</code> 如果文件log文件太多我们会得到一个异常的信/bin/rm Argument list too long，也就是说rm能接受的参数是有限的。这时我们就可以利用xargs 过滤。</p>\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs rm -rf</code></pre>\n\n<p>ls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。</p>\n<p><strong>题外话：</strong> Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：<code>rm -rf -xxxx.log</code>是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。可以通过在文件名前加两个减号解决。</p>\n<p>如<code>rm -rf -- -xxxx.log</code></p>\n<p>​    xargs 的具体用法，还是一个文件夹中有一大堆文件，通过<code>ls</code>可以将文件多行输出。但是我想单行或者指定行数输出呢！通过给xargs指定-n 参数。</p>\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs -n2 <span class=\"hljs-comment\">#-n2 就是指定两行输出，-n3就是三行输出，以此类推</span></code></pre>\n\n<p>前面都是一些简易的操作，感觉不到xargs 到底是怎么处理管道出来的文件。现在我的一个需求是将所有的log文件复制到指定目录下。普通复制命令<code>cp xxx.log /var/log</code>。我们先忽略cp 命令有-r参数。先看看以下写法是否正确</p>","more":"<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs cp /var/<span class=\"hljs-built_in\">log</span></code></pre>\n\n<p>你一看立马就觉得不对，cp 不是接受两个参数吗？一个文件，一个目标文件或路径。可是又不知道怎么去解决这个事。在我们上面的例子都真正没有去理解xargs，如<code>ls *.log | xargs rm -rf </code> 为什么能好使？ls出来的文件通过管道传递给xargs 过滤，然后xargs 过滤出的文件默认追加到命令行的最后。但是在这个例子中，我们不想将xargs吐出来的放到命令行的最后。xargs的占位符就发挥作用了，将上面的命令修改</p>\n <pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs -I &#123;&#125; cp &#123;&#125;  /var/<span class=\"hljs-built_in\">log</span>/</code></pre>\n\n<p>通过<code>-I</code>参数指定大括号为占位符，cp后的大括号就是xargs 吐出来的文件名。这里不一定使用大括号，也可指定其他的符号。<code>-i</code>默认的占位符就是大括号</p>\n<pre><code class=\"hljs sh\">ls *.<span class=\"hljs-built_in\">log</span> | xargs -i cp &#123;&#125; /var/<span class=\"hljs-built_in\">log</span>/</code></pre>\n\n<p>xargs还有一个-P的参数，是指定xargs同时处理多少个命令。但是感觉没什么效果。例子<code>ls *.log | xargs -P 8 -i cp &#123;&#125; /var/log/</code></p>\n<p>xargs 的使用就讲到这里</p>\n<h2 id=\"jq\"><a href=\"#jq\" class=\"headerlink\" title=\"jq\"></a>jq</h2><p>jq 命令并不是Linux系统自带的，所以我们需要格外安装。<a href=\"https://stedolan.github.io/jq/download/\">下载的地址</a></p>\n<p>jq 的官方说法是jq is like <code>sed</code> for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that <code>sed</code>, <code>awk</code>, <code>grep</code> and friends let you play with text。使用jq在Linux系统上去处理json是非常方便的。比如在终端上curl一个接口，返回一个json，这个json可能很长，我只想看其中部分数据，就可以用上jq了。</p>\n<p>jq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。哈哈哈</p>\n<p><a href=\"https://stedolan.github.io/jq/tutorial/\"> 官方教程</a></p>\n<h2 id=\"自己实践的例子\"><a href=\"#自己实践的例子\" class=\"headerlink\" title=\"自己实践的例子\"></a>自己实践的例子</h2><p>前段时间有需要将两万张的照片去发起请求，然后处理curl返回的结果。利用了xargs和jq。将命令贴出来记录一下。</p>\n<pre><code class=\"hljs sh\">ls TP | xargs -i -n1 curl -s -F img=@TP/&#123;&#125; http://127.0.0.1:9001/faceid/v1/liveness_cfg                                                                 | jq -c -r <span class=\"hljs-string\">&#x27;[.liveness.mask,.liveness.replay,.liveness.graphics]&#x27;</span> &gt; TP.txt &amp;</code></pre>\n\n<p>TP就是有两万张照片的文件夹，将请求的结果通过jq处理，然后输出到TP.txt文件 中</p>"},{"title":"supervisor linux后台进程管理利器","date":"2017-04-28T03:24:12.000Z","_content":"\nsupervisor 是基于python的进程管理工具，比如进程意外退出了，可以自动将退出的进程拉起，重新运行。\n\n## install online\n\n- ubuntu 系统安装 apt-get install supervisor\n\n- 也可以通过pip install supervisor 但是需要手动启动\n\n  \n## install offline\n\n- 下载安装包和依赖包详见官网 [https://pypi.python.org/pypi/supervisor] 3.3.1版本\n\n- 解压安装tar.gz  然后cd 到目录中执行 python setup.py install\n\n- 创建配置文件\n\n- 执行`echo supervisord_conf > /etc/supervisor/supervisord.conf `创建配置文件\n\n- 创建supervisord 放在 init.d目录 下  **注：** prog_bin 为supervisors 可执行文件位置\n\n   <!-- more -->\n\n   ```ssh\n   #!/bin/sh\n   #\n   # /etc/rc.d/init.d/supervisord\n   #\n   # Supervisor is a client/server system that\n   # allows its users to monitor and control a\n   # number of processes on UNIX-like operating\n   # systems.\n   #\n   # chkconfig: - 64 36\n   # description: Supervisor Server\n   # processname: supervisord\n\n   # Source init functions\n   . /etc/rc.d/init.d/functions\n\n   prog=\"supervisord\"\n\n   prefix=\"/usr\"\n   exec_prefix=\"${prefix}\"\n   prog_bin=\"${exec_prefix}/bin/supervisord\"\n   PIDFILE=\"/var/run/$prog.pid\"\n\n   start()\n   {\n          echo -n $\"Starting $prog: \"\n          touch $PIDFILE\n          daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE\n          sleep 1\n          [ -f $PIDFILE ] && success $\"$prog startup\" || failure $\"$prog startup\"\n          echo\n   }\n   stop()\n   {\n          echo -n $\"Shutting down $prog: \"\n          [ -f $PIDFILE ] && killproc $prog || success $\"$prog shutdown\"\n          echo\n   }\n\n   case \"$1\" in\n\n    start)\n      start\n    ;;\n\n    stop)\n      stop\n    ;;\n\n    status)\n          status $prog\n    ;;\n\n    restart)\n      stop\n      start\n    ;;\n\n    *)\n      echo \"Usage: $0 {start|stop|restart|status}\"\n    ;;\n\n   esac\n   ```\n\n- 修改指定要运行程序配置文件\n\n   编辑supervisor.conf文件中的\n\n   ```\n   [include]\n   files = /etc/supervisord.conf.d/*.conf\n   ```\n\n ​\n\n## how to use\n\n在etc/supervisor.conf.d 目录下创建每个进程对应的配置文件 如：work.conf\n具体配置\n\n```shell\ndirectory= /opt/faceid/worker#工程文件目录\ncommand= /opt/faceid/worker/start.sh#启动命令\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=1#启动时间\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_logfile=å/var/log/megvii/%(program_name)s.log\t\n```\n\n## common command\n\n- supervisorctl status 查看各个进程的状态\n- supervisorctl reload 重启supervisor 下的所有进程\n- supervisorctl stop name 停止指定进程\n- supervisorctl start name 启动指定进程\n- supervisorctl restart all  重启supervisor 下的所有进程\n\n\n## FAQ\n\n- Error: Another program is already listening on a port\n\n  ```shell\n  find / -name supervisor.sock\n  unlink /***/supervisor.sock\n  ```\n\n- 文件找不到\n\n   `unix:///tmp/supervisor.sock no such file`\n\n  编辑文件/etc/supervisord.conf  中的\n\n  ```shell\n  file = /tmp/supervisor.sock ;改成file = /var/run/supervisor.sock\n  ```\n  \n  然后执行\n  \n  ```shell\n  touch /var/run/supervisor.sock\n  service supervisord restart\n  ```\n\n-  ERROR (spawn error)\n\n  确认脚本文件能够正常使用\n\n- error while loading shared libraries: libpython2.7.so.1.0\n\n  找到libpython2.7.so.10点位置\n\n  ```ssh\n  [root@testlm01v ~]# locate libpython2.7.so.1.0\n  /usr/local/Python-2.7.11/libpython2.7.so.1.0\n  /usr/local/lib/libpython2.7.so.1.0\n  ```\n\n  把找到的位置复制到/etc/ld.so.conf.d/python.conf中如\n\n  ```\n  [root@testlm01v /etc/ld.so.conf.d]# cat python.conf \n  /usr/local/lib\n  ```\n  \n-  普通用户权限\n\n   安装需要root用户，如果维护通过非root用户，可以如下修改 \n\n   - 修改配置文件/etc/supervisord.conf中[unix_http_server] ;chown=nobody:nogroup 去掉;，修改为相应的user:group （也可以改前面的chmod为777） \n   - 修改/etc/supervisord.conf.d权限，让相应用户可以增删改相应的配置文件\n\n","source":"_posts/supervisor 是基于python的进程管理工具.md","raw":"---\ntitle: supervisor linux后台进程管理利器\ndate: 2017-04-28 11:24:12\ntags: \n- Python\n- Linux\ncategories:\n- 开源工具\n---\n\nsupervisor 是基于python的进程管理工具，比如进程意外退出了，可以自动将退出的进程拉起，重新运行。\n\n## install online\n\n- ubuntu 系统安装 apt-get install supervisor\n\n- 也可以通过pip install supervisor 但是需要手动启动\n\n  \n## install offline\n\n- 下载安装包和依赖包详见官网 [https://pypi.python.org/pypi/supervisor] 3.3.1版本\n\n- 解压安装tar.gz  然后cd 到目录中执行 python setup.py install\n\n- 创建配置文件\n\n- 执行`echo supervisord_conf > /etc/supervisor/supervisord.conf `创建配置文件\n\n- 创建supervisord 放在 init.d目录 下  **注：** prog_bin 为supervisors 可执行文件位置\n\n   <!-- more -->\n\n   ```ssh\n   #!/bin/sh\n   #\n   # /etc/rc.d/init.d/supervisord\n   #\n   # Supervisor is a client/server system that\n   # allows its users to monitor and control a\n   # number of processes on UNIX-like operating\n   # systems.\n   #\n   # chkconfig: - 64 36\n   # description: Supervisor Server\n   # processname: supervisord\n\n   # Source init functions\n   . /etc/rc.d/init.d/functions\n\n   prog=\"supervisord\"\n\n   prefix=\"/usr\"\n   exec_prefix=\"${prefix}\"\n   prog_bin=\"${exec_prefix}/bin/supervisord\"\n   PIDFILE=\"/var/run/$prog.pid\"\n\n   start()\n   {\n          echo -n $\"Starting $prog: \"\n          touch $PIDFILE\n          daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE\n          sleep 1\n          [ -f $PIDFILE ] && success $\"$prog startup\" || failure $\"$prog startup\"\n          echo\n   }\n   stop()\n   {\n          echo -n $\"Shutting down $prog: \"\n          [ -f $PIDFILE ] && killproc $prog || success $\"$prog shutdown\"\n          echo\n   }\n\n   case \"$1\" in\n\n    start)\n      start\n    ;;\n\n    stop)\n      stop\n    ;;\n\n    status)\n          status $prog\n    ;;\n\n    restart)\n      stop\n      start\n    ;;\n\n    *)\n      echo \"Usage: $0 {start|stop|restart|status}\"\n    ;;\n\n   esac\n   ```\n\n- 修改指定要运行程序配置文件\n\n   编辑supervisor.conf文件中的\n\n   ```\n   [include]\n   files = /etc/supervisord.conf.d/*.conf\n   ```\n\n ​\n\n## how to use\n\n在etc/supervisor.conf.d 目录下创建每个进程对应的配置文件 如：work.conf\n具体配置\n\n```shell\ndirectory= /opt/faceid/worker#工程文件目录\ncommand= /opt/faceid/worker/start.sh#启动命令\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=1#启动时间\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_logfile=å/var/log/megvii/%(program_name)s.log\t\n```\n\n## common command\n\n- supervisorctl status 查看各个进程的状态\n- supervisorctl reload 重启supervisor 下的所有进程\n- supervisorctl stop name 停止指定进程\n- supervisorctl start name 启动指定进程\n- supervisorctl restart all  重启supervisor 下的所有进程\n\n\n## FAQ\n\n- Error: Another program is already listening on a port\n\n  ```shell\n  find / -name supervisor.sock\n  unlink /***/supervisor.sock\n  ```\n\n- 文件找不到\n\n   `unix:///tmp/supervisor.sock no such file`\n\n  编辑文件/etc/supervisord.conf  中的\n\n  ```shell\n  file = /tmp/supervisor.sock ;改成file = /var/run/supervisor.sock\n  ```\n  \n  然后执行\n  \n  ```shell\n  touch /var/run/supervisor.sock\n  service supervisord restart\n  ```\n\n-  ERROR (spawn error)\n\n  确认脚本文件能够正常使用\n\n- error while loading shared libraries: libpython2.7.so.1.0\n\n  找到libpython2.7.so.10点位置\n\n  ```ssh\n  [root@testlm01v ~]# locate libpython2.7.so.1.0\n  /usr/local/Python-2.7.11/libpython2.7.so.1.0\n  /usr/local/lib/libpython2.7.so.1.0\n  ```\n\n  把找到的位置复制到/etc/ld.so.conf.d/python.conf中如\n\n  ```\n  [root@testlm01v /etc/ld.so.conf.d]# cat python.conf \n  /usr/local/lib\n  ```\n  \n-  普通用户权限\n\n   安装需要root用户，如果维护通过非root用户，可以如下修改 \n\n   - 修改配置文件/etc/supervisord.conf中[unix_http_server] ;chown=nobody:nogroup 去掉;，修改为相应的user:group （也可以改前面的chmod为777） \n   - 修改/etc/supervisord.conf.d权限，让相应用户可以增删改相应的配置文件\n\n","slug":"supervisor 是基于python的进程管理工具","published":1,"updated":"2020-03-23T09:49:03.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0l001bmdymgxb63h3o","content":"<p>supervisor 是基于python的进程管理工具，比如进程意外退出了，可以自动将退出的进程拉起，重新运行。</p>\n<h2 id=\"install-online\"><a href=\"#install-online\" class=\"headerlink\" title=\"install online\"></a>install online</h2><ul>\n<li><p>ubuntu 系统安装 apt-get install supervisor</p>\n</li>\n<li><p>也可以通过pip install supervisor 但是需要手动启动</p>\n</li>\n</ul>\n<h2 id=\"install-offline\"><a href=\"#install-offline\" class=\"headerlink\" title=\"install offline\"></a>install offline</h2><ul>\n<li><p>下载安装包和依赖包详见官网 [<a href=\"https://pypi.python.org/pypi/supervisor]\">https://pypi.python.org/pypi/supervisor]</a> 3.3.1版本</p>\n</li>\n<li><p>解压安装tar.gz  然后cd 到目录中执行 python setup.py install</p>\n</li>\n<li><p>创建配置文件</p>\n</li>\n<li><p>执行<code>echo supervisord_conf &gt; /etc/supervisor/supervisord.conf </code>创建配置文件</p>\n</li>\n<li><p>创建supervisord 放在 init.d目录 下  <strong>注：</strong> prog_bin 为supervisors 可执行文件位置</p>\n <a id=\"more\"></a>\n\n <pre><code class=\"hljs ssh\">#!&#x2F;bin&#x2F;sh\n#\n# &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;supervisord\n#\n# Supervisor is a client&#x2F;server system that\n# allows its users to monitor and control a\n# number of processes on UNIX-like operating\n# systems.\n#\n# chkconfig: - 64 36\n# description: Supervisor Server\n# processname: supervisord\n\n# Source init functions\n. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions\n\nprog&#x3D;&quot;supervisord&quot;\n\nprefix&#x3D;&quot;&#x2F;usr&quot;\nexec_prefix&#x3D;&quot;$&#123;prefix&#125;&quot;\nprog_bin&#x3D;&quot;$&#123;exec_prefix&#125;&#x2F;bin&#x2F;supervisord&quot;\nPIDFILE&#x3D;&quot;&#x2F;var&#x2F;run&#x2F;$prog.pid&quot;\n\nstart()\n&#123;\n       echo -n $&quot;Starting $prog: &quot;\n       touch $PIDFILE\n       daemon $prog_bin -c &#x2F;etc&#x2F;supervisord.conf --pidfile $PIDFILE\n       sleep 1\n       [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;\n       echo\n&#125;\nstop()\n&#123;\n       echo -n $&quot;Shutting down $prog: &quot;\n       [ -f $PIDFILE ] &amp;&amp; killproc $prog || success $&quot;$prog shutdown&quot;\n       echo\n&#125;\n\ncase &quot;$1&quot; in\n\n start)\n   start\n ;;\n\n stop)\n   stop\n ;;\n\n status)\n       status $prog\n ;;\n\n restart)\n   stop\n   start\n ;;\n\n *)\n   echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;\n ;;\n\nesac</code></pre>\n</li>\n<li><p>修改指定要运行程序配置文件</p>\n<p> 编辑supervisor.conf文件中的</p>\n <pre><code class=\"hljs gradle\">[<span class=\"hljs-keyword\">include</span>]\nfiles = <span class=\"hljs-regexp\">/etc/</span>supervisord.conf.d<span class=\"hljs-comment\">/*.conf</span></code></pre>\n\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"how-to-use\"><a href=\"#how-to-use\" class=\"headerlink\" title=\"how to use\"></a>how to use</h2><p>在etc/supervisor.conf.d 目录下创建每个进程对应的配置文件 如：work.conf<br>具体配置</p>\n<pre><code class=\"hljs shell\">directory= /opt/faceid/worker#工程文件目录\ncommand= /opt/faceid/worker/start.sh#启动命令\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=1#启动时间\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_logfile=å/var/log/megvii/%(program_name)s.log</code></pre>\n\n<h2 id=\"common-command\"><a href=\"#common-command\" class=\"headerlink\" title=\"common command\"></a>common command</h2><ul>\n<li>supervisorctl status 查看各个进程的状态</li>\n<li>supervisorctl reload 重启supervisor 下的所有进程</li>\n<li>supervisorctl stop name 停止指定进程</li>\n<li>supervisorctl start name 启动指定进程</li>\n<li>supervisorctl restart all  重启supervisor 下的所有进程</li>\n</ul>\n<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><ul>\n<li><p>Error: Another program is already listening on a port</p>\n<pre><code class=\"hljs shell\">find / -name supervisor.sock\nunlink /***/supervisor.sock</code></pre>\n</li>\n<li><p>文件找不到</p>\n<p> <code>unix:///tmp/supervisor.sock no such file</code></p>\n<p>编辑文件/etc/supervisord.conf  中的</p>\n<pre><code class=\"hljs shell\">file = /tmp/supervisor.sock ;改成file = /var/run/supervisor.sock</code></pre>\n\n<p>然后执行</p>\n<pre><code class=\"hljs shell\">touch /var/run/supervisor.sock\nservice supervisord restart</code></pre>\n</li>\n<li><p>ERROR (spawn error)</p>\n<p>确认脚本文件能够正常使用</p>\n</li>\n<li><p>error while loading shared libraries: libpython2.7.so.1.0</p>\n<p>找到libpython2.7.so.10点位置</p>\n<pre><code class=\"hljs ssh\">[root@testlm01v ~]# locate libpython2.7.so.1.0\n&#x2F;usr&#x2F;local&#x2F;Python-2.7.11&#x2F;libpython2.7.so.1.0\n&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libpython2.7.so.1.0</code></pre>\n\n<p>把找到的位置复制到/etc/ld.so.conf.d/python.conf中如</p>\n<pre><code class=\"hljs awk\">[root@testlm01v <span class=\"hljs-regexp\">/etc/</span>ld.so.conf.d]<span class=\"hljs-comment\"># cat python.conf </span>\n<span class=\"hljs-regexp\">/usr/</span>local/lib</code></pre>\n</li>\n<li><p>普通用户权限</p>\n<p>安装需要root用户，如果维护通过非root用户，可以如下修改 </p>\n<ul>\n<li>修改配置文件/etc/supervisord.conf中[unix_http_server] ;chown=nobody:nogroup 去掉;，修改为相应的user:group （也可以改前面的chmod为777） </li>\n<li>修改/etc/supervisord.conf.d权限，让相应用户可以增删改相应的配置文件</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>supervisor 是基于python的进程管理工具，比如进程意外退出了，可以自动将退出的进程拉起，重新运行。</p>\n<h2 id=\"install-online\"><a href=\"#install-online\" class=\"headerlink\" title=\"install online\"></a>install online</h2><ul>\n<li><p>ubuntu 系统安装 apt-get install supervisor</p>\n</li>\n<li><p>也可以通过pip install supervisor 但是需要手动启动</p>\n</li>\n</ul>\n<h2 id=\"install-offline\"><a href=\"#install-offline\" class=\"headerlink\" title=\"install offline\"></a>install offline</h2><ul>\n<li><p>下载安装包和依赖包详见官网 [<a href=\"https://pypi.python.org/pypi/supervisor]\">https://pypi.python.org/pypi/supervisor]</a> 3.3.1版本</p>\n</li>\n<li><p>解压安装tar.gz  然后cd 到目录中执行 python setup.py install</p>\n</li>\n<li><p>创建配置文件</p>\n</li>\n<li><p>执行<code>echo supervisord_conf &gt; /etc/supervisor/supervisord.conf </code>创建配置文件</p>\n</li>\n<li><p>创建supervisord 放在 init.d目录 下  <strong>注：</strong> prog_bin 为supervisors 可执行文件位置</p>","more":"<pre><code class=\"hljs ssh\">#!&#x2F;bin&#x2F;sh\n#\n# &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;supervisord\n#\n# Supervisor is a client&#x2F;server system that\n# allows its users to monitor and control a\n# number of processes on UNIX-like operating\n# systems.\n#\n# chkconfig: - 64 36\n# description: Supervisor Server\n# processname: supervisord\n\n# Source init functions\n. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions\n\nprog&#x3D;&quot;supervisord&quot;\n\nprefix&#x3D;&quot;&#x2F;usr&quot;\nexec_prefix&#x3D;&quot;$&#123;prefix&#125;&quot;\nprog_bin&#x3D;&quot;$&#123;exec_prefix&#125;&#x2F;bin&#x2F;supervisord&quot;\nPIDFILE&#x3D;&quot;&#x2F;var&#x2F;run&#x2F;$prog.pid&quot;\n\nstart()\n&#123;\n       echo -n $&quot;Starting $prog: &quot;\n       touch $PIDFILE\n       daemon $prog_bin -c &#x2F;etc&#x2F;supervisord.conf --pidfile $PIDFILE\n       sleep 1\n       [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;\n       echo\n&#125;\nstop()\n&#123;\n       echo -n $&quot;Shutting down $prog: &quot;\n       [ -f $PIDFILE ] &amp;&amp; killproc $prog || success $&quot;$prog shutdown&quot;\n       echo\n&#125;\n\ncase &quot;$1&quot; in\n\n start)\n   start\n ;;\n\n stop)\n   stop\n ;;\n\n status)\n       status $prog\n ;;\n\n restart)\n   stop\n   start\n ;;\n\n *)\n   echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;\n ;;\n\nesac</code></pre>\n</li>\n<li><p>修改指定要运行程序配置文件</p>\n<p> 编辑supervisor.conf文件中的</p>\n <pre><code class=\"hljs gradle\">[<span class=\"hljs-keyword\">include</span>]\nfiles = <span class=\"hljs-regexp\">/etc/</span>supervisord.conf.d<span class=\"hljs-comment\">/*.conf</span></code></pre>\n\n<p>​</p>\n</li>\n</ul>\n<h2 id=\"how-to-use\"><a href=\"#how-to-use\" class=\"headerlink\" title=\"how to use\"></a>how to use</h2><p>在etc/supervisor.conf.d 目录下创建每个进程对应的配置文件 如：work.conf<br>具体配置</p>\n<pre><code class=\"hljs shell\">directory= /opt/faceid/worker#工程文件目录\ncommand= /opt/faceid/worker/start.sh#启动命令\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=1#启动时间\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_logfile=å/var/log/megvii/%(program_name)s.log</code></pre>\n\n<h2 id=\"common-command\"><a href=\"#common-command\" class=\"headerlink\" title=\"common command\"></a>common command</h2><ul>\n<li>supervisorctl status 查看各个进程的状态</li>\n<li>supervisorctl reload 重启supervisor 下的所有进程</li>\n<li>supervisorctl stop name 停止指定进程</li>\n<li>supervisorctl start name 启动指定进程</li>\n<li>supervisorctl restart all  重启supervisor 下的所有进程</li>\n</ul>\n<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><ul>\n<li><p>Error: Another program is already listening on a port</p>\n<pre><code class=\"hljs shell\">find / -name supervisor.sock\nunlink /***/supervisor.sock</code></pre>\n</li>\n<li><p>文件找不到</p>\n<p> <code>unix:///tmp/supervisor.sock no such file</code></p>\n<p>编辑文件/etc/supervisord.conf  中的</p>\n<pre><code class=\"hljs shell\">file = /tmp/supervisor.sock ;改成file = /var/run/supervisor.sock</code></pre>\n\n<p>然后执行</p>\n<pre><code class=\"hljs shell\">touch /var/run/supervisor.sock\nservice supervisord restart</code></pre>\n</li>\n<li><p>ERROR (spawn error)</p>\n<p>确认脚本文件能够正常使用</p>\n</li>\n<li><p>error while loading shared libraries: libpython2.7.so.1.0</p>\n<p>找到libpython2.7.so.10点位置</p>\n<pre><code class=\"hljs ssh\">[root@testlm01v ~]# locate libpython2.7.so.1.0\n&#x2F;usr&#x2F;local&#x2F;Python-2.7.11&#x2F;libpython2.7.so.1.0\n&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libpython2.7.so.1.0</code></pre>\n\n<p>把找到的位置复制到/etc/ld.so.conf.d/python.conf中如</p>\n<pre><code class=\"hljs awk\">[root@testlm01v <span class=\"hljs-regexp\">/etc/</span>ld.so.conf.d]<span class=\"hljs-comment\"># cat python.conf </span>\n<span class=\"hljs-regexp\">/usr/</span>local/lib</code></pre>\n</li>\n<li><p>普通用户权限</p>\n<p>安装需要root用户，如果维护通过非root用户，可以如下修改 </p>\n<ul>\n<li>修改配置文件/etc/supervisord.conf中[unix_http_server] ;chown=nobody:nogroup 去掉;，修改为相应的user:group （也可以改前面的chmod为777） </li>\n<li>修改/etc/supervisord.conf.d权限，让相应用户可以增删改相应的配置文件</li>\n</ul>\n</li>\n</ul>"},{"title":"传统POS流程及名词解释","date":"2020-10-19T09:20:12.000Z","index_img":["/images/other/banner.png"],"_content":"\n### 传统POS流程及名词解释\n\n####  签到流程\n\nPOS机签到只要有两个目的：\n\n1. 链接主机证明该POS机设备是合法的\n2. 下载最新的工作密钥\n\n签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。\n\n\n\n```mermaid\ngraph TD\nEE{签到}--fail-->TT(退出应用)\nEE--success-->A{参数下载}--fail-->TT(退出应用)\nA--success-->B{AID参数下载}--fail-->TT(退出应用)\nB--success-->C{下载CA公钥}--fail-->TT(退出应用)\nC--success-->E(交易流程)\n    \n```\n\n#### 交易流程\n\n交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。\n\n名称解释：\n\n1. 消费：\n\n   包括正常刷卡/挥卡/插卡消费\n\n2. 消费撤销：\n\n   因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，**消费撤销必须是撤销消费所用POS机的当日当批次的消费交易**。\n\n3. 消费退货：\n\n   和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是\n\n   - 退货不要求当日当批次的消费\n   - 退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款\n\n4. 结算：\n\n   一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。\n\n5. 预授权：\n\n   就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点\n\n   - 预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已\n   - 必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码\n   - 预授权的小票需要客户签名\n   - 必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。\n   - 预授权有效期一般为30天（含），超过时间资金将自动解冻。\n   - 交易凭证上标有“预授权”字样。\n\n6. 预授权撤销：\n\n   预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。\n\n7. 预授权完成：\n\n   是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。\n\n8. 预授权完成撤销：\n\n   预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。\n\n```mermaid\ngraph TD\nEE(交易流程)-->A{消费}\nA-->D(撤销)\nA-->E(退货)\nD-->Y(结算)\nE-->Y(结算)\nEE-->B{预授权}\nB-->F(预授权撤销)\nF-->Y(结算)\nB-->G(预授权完成)\nG-->H(预授权完成撤销)\nH-->Y(结算)\nEE-->C(余额查询)\nC-->Y(结算)\nY-->Z(签退)\n    \n```\n\n#### 消费冲正流程\n\n名次解释：\n\n1. 冲正\n\n   当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。\n\n```mermaid\ngraph TD\nA(消费) --> B{是否有上一笔<br>的消费记录}\nB -->|是|C(请求冲正)\nC --> D{冲正成功 或<br>超过最大冲正次数}\nD --> |是|E(清除冲正记录)\nE --> F(结束)\nD --> |否|C\nB --> |否|G(保存此次消费记录)\nG --> K(请求交易)\nK --> H{响应交易}\nH --> |交易成功|I(交易成功)\nI --> L(清除此次消费记录)\nL --> F\nH --> |交易失败|J(交易失败)\nJ --> M(不清除本次消费记录<br>下次消费时冲正)\nM --> F\n```\n\n","source":"_posts/传统POS流程及名词解释.md","raw":"---\ntitle: 传统POS流程及名词解释\ndate: 2020-10-19 17:20:12\nindex_img:\n- /images/other/banner.png\ntags: \n- 随笔\ncategories:\n- 随笔\n---\n\n### 传统POS流程及名词解释\n\n####  签到流程\n\nPOS机签到只要有两个目的：\n\n1. 链接主机证明该POS机设备是合法的\n2. 下载最新的工作密钥\n\n签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。\n\n\n\n```mermaid\ngraph TD\nEE{签到}--fail-->TT(退出应用)\nEE--success-->A{参数下载}--fail-->TT(退出应用)\nA--success-->B{AID参数下载}--fail-->TT(退出应用)\nB--success-->C{下载CA公钥}--fail-->TT(退出应用)\nC--success-->E(交易流程)\n    \n```\n\n#### 交易流程\n\n交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。\n\n名称解释：\n\n1. 消费：\n\n   包括正常刷卡/挥卡/插卡消费\n\n2. 消费撤销：\n\n   因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，**消费撤销必须是撤销消费所用POS机的当日当批次的消费交易**。\n\n3. 消费退货：\n\n   和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是\n\n   - 退货不要求当日当批次的消费\n   - 退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款\n\n4. 结算：\n\n   一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。\n\n5. 预授权：\n\n   就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点\n\n   - 预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已\n   - 必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码\n   - 预授权的小票需要客户签名\n   - 必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。\n   - 预授权有效期一般为30天（含），超过时间资金将自动解冻。\n   - 交易凭证上标有“预授权”字样。\n\n6. 预授权撤销：\n\n   预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。\n\n7. 预授权完成：\n\n   是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。\n\n8. 预授权完成撤销：\n\n   预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。\n\n```mermaid\ngraph TD\nEE(交易流程)-->A{消费}\nA-->D(撤销)\nA-->E(退货)\nD-->Y(结算)\nE-->Y(结算)\nEE-->B{预授权}\nB-->F(预授权撤销)\nF-->Y(结算)\nB-->G(预授权完成)\nG-->H(预授权完成撤销)\nH-->Y(结算)\nEE-->C(余额查询)\nC-->Y(结算)\nY-->Z(签退)\n    \n```\n\n#### 消费冲正流程\n\n名次解释：\n\n1. 冲正\n\n   当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。\n\n```mermaid\ngraph TD\nA(消费) --> B{是否有上一笔<br>的消费记录}\nB -->|是|C(请求冲正)\nC --> D{冲正成功 或<br>超过最大冲正次数}\nD --> |是|E(清除冲正记录)\nE --> F(结束)\nD --> |否|C\nB --> |否|G(保存此次消费记录)\nG --> K(请求交易)\nK --> H{响应交易}\nH --> |交易成功|I(交易成功)\nI --> L(清除此次消费记录)\nL --> F\nH --> |交易失败|J(交易失败)\nJ --> M(不清除本次消费记录<br>下次消费时冲正)\nM --> F\n```\n\n","slug":"传统POS流程及名词解释","published":1,"updated":"2020-10-19T10:54:51.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0m001fmdymhkc08vvf","content":"<h3 id=\"传统POS流程及名词解释\"><a href=\"#传统POS流程及名词解释\" class=\"headerlink\" title=\"传统POS流程及名词解释\"></a>传统POS流程及名词解释</h3><h4 id=\"签到流程\"><a href=\"#签到流程\" class=\"headerlink\" title=\"签到流程\"></a>签到流程</h4><p>POS机签到只要有两个目的：</p>\n<ol>\n<li>链接主机证明该POS机设备是合法的</li>\n<li>下载最新的工作密钥</li>\n</ol>\n<p>签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。</p>\n<pre><code class=\"hljs mermaid\">graph TD\nEE&#123;签到&#125;--fail--&gt;TT(退出应用)\nEE--success--&gt;A&#123;参数下载&#125;--fail--&gt;TT(退出应用)\nA--success--&gt;B&#123;AID参数下载&#125;--fail--&gt;TT(退出应用)\nB--success--&gt;C&#123;下载CA公钥&#125;--fail--&gt;TT(退出应用)\nC--success--&gt;E(交易流程)</code></pre>\n\n<h4 id=\"交易流程\"><a href=\"#交易流程\" class=\"headerlink\" title=\"交易流程\"></a>交易流程</h4><p>交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。</p>\n<p>名称解释：</p>\n<ol>\n<li><p>消费：</p>\n<p>包括正常刷卡/挥卡/插卡消费</p>\n</li>\n<li><p>消费撤销：</p>\n<p>因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，<strong>消费撤销必须是撤销消费所用POS机的当日当批次的消费交易</strong>。</p>\n</li>\n<li><p>消费退货：</p>\n<p>和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是</p>\n<ul>\n<li>退货不要求当日当批次的消费</li>\n<li>退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款</li>\n</ul>\n</li>\n<li><p>结算：</p>\n<p>一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。</p>\n</li>\n<li><p>预授权：</p>\n<p>就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点</p>\n<ul>\n<li>预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已</li>\n<li>必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码</li>\n<li>预授权的小票需要客户签名</li>\n<li>必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。</li>\n<li>预授权有效期一般为30天（含），超过时间资金将自动解冻。</li>\n<li>交易凭证上标有“预授权”字样。</li>\n</ul>\n</li>\n<li><p>预授权撤销：</p>\n<p>预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。</p>\n</li>\n<li><p>预授权完成：</p>\n<p>是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。</p>\n</li>\n<li><p>预授权完成撤销：</p>\n<p>预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nEE(交易流程)--&gt;A&#123;消费&#125;\nA--&gt;D(撤销)\nA--&gt;E(退货)\nD--&gt;Y(结算)\nE--&gt;Y(结算)\nEE--&gt;B&#123;预授权&#125;\nB--&gt;F(预授权撤销)\nF--&gt;Y(结算)\nB--&gt;G(预授权完成)\nG--&gt;H(预授权完成撤销)\nH--&gt;Y(结算)\nEE--&gt;C(余额查询)\nC--&gt;Y(结算)\nY--&gt;Z(签退)</code></pre>\n\n<h4 id=\"消费冲正流程\"><a href=\"#消费冲正流程\" class=\"headerlink\" title=\"消费冲正流程\"></a>消费冲正流程</h4><p>名次解释：</p>\n<ol>\n<li><p>冲正</p>\n<p>当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nA(消费) --&gt; B&#123;是否有上一笔&lt;br&gt;的消费记录&#125;\nB --&gt;|是|C(请求冲正)\nC --&gt; D&#123;冲正成功 或&lt;br&gt;超过最大冲正次数&#125;\nD --&gt; |是|E(清除冲正记录)\nE --&gt; F(结束)\nD --&gt; |否|C\nB --&gt; |否|G(保存此次消费记录)\nG --&gt; K(请求交易)\nK --&gt; H&#123;响应交易&#125;\nH --&gt; |交易成功|I(交易成功)\nI --&gt; L(清除此次消费记录)\nL --&gt; F\nH --&gt; |交易失败|J(交易失败)\nJ --&gt; M(不清除本次消费记录&lt;br&gt;下次消费时冲正)\nM --&gt; F</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"传统POS流程及名词解释\"><a href=\"#传统POS流程及名词解释\" class=\"headerlink\" title=\"传统POS流程及名词解释\"></a>传统POS流程及名词解释</h3><h4 id=\"签到流程\"><a href=\"#签到流程\" class=\"headerlink\" title=\"签到流程\"></a>签到流程</h4><p>POS机签到只要有两个目的：</p>\n<ol>\n<li>链接主机证明该POS机设备是合法的</li>\n<li>下载最新的工作密钥</li>\n</ol>\n<p>签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。</p>\n<pre><code class=\"hljs mermaid\">graph TD\nEE&#123;签到&#125;--fail--&gt;TT(退出应用)\nEE--success--&gt;A&#123;参数下载&#125;--fail--&gt;TT(退出应用)\nA--success--&gt;B&#123;AID参数下载&#125;--fail--&gt;TT(退出应用)\nB--success--&gt;C&#123;下载CA公钥&#125;--fail--&gt;TT(退出应用)\nC--success--&gt;E(交易流程)</code></pre>\n\n<h4 id=\"交易流程\"><a href=\"#交易流程\" class=\"headerlink\" title=\"交易流程\"></a>交易流程</h4><p>交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。</p>\n<p>名称解释：</p>\n<ol>\n<li><p>消费：</p>\n<p>包括正常刷卡/挥卡/插卡消费</p>\n</li>\n<li><p>消费撤销：</p>\n<p>因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，<strong>消费撤销必须是撤销消费所用POS机的当日当批次的消费交易</strong>。</p>\n</li>\n<li><p>消费退货：</p>\n<p>和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是</p>\n<ul>\n<li>退货不要求当日当批次的消费</li>\n<li>退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款</li>\n</ul>\n</li>\n<li><p>结算：</p>\n<p>一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。</p>\n</li>\n<li><p>预授权：</p>\n<p>就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点</p>\n<ul>\n<li>预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已</li>\n<li>必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码</li>\n<li>预授权的小票需要客户签名</li>\n<li>必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。</li>\n<li>预授权有效期一般为30天（含），超过时间资金将自动解冻。</li>\n<li>交易凭证上标有“预授权”字样。</li>\n</ul>\n</li>\n<li><p>预授权撤销：</p>\n<p>预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。</p>\n</li>\n<li><p>预授权完成：</p>\n<p>是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。</p>\n</li>\n<li><p>预授权完成撤销：</p>\n<p>预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nEE(交易流程)--&gt;A&#123;消费&#125;\nA--&gt;D(撤销)\nA--&gt;E(退货)\nD--&gt;Y(结算)\nE--&gt;Y(结算)\nEE--&gt;B&#123;预授权&#125;\nB--&gt;F(预授权撤销)\nF--&gt;Y(结算)\nB--&gt;G(预授权完成)\nG--&gt;H(预授权完成撤销)\nH--&gt;Y(结算)\nEE--&gt;C(余额查询)\nC--&gt;Y(结算)\nY--&gt;Z(签退)</code></pre>\n\n<h4 id=\"消费冲正流程\"><a href=\"#消费冲正流程\" class=\"headerlink\" title=\"消费冲正流程\"></a>消费冲正流程</h4><p>名次解释：</p>\n<ol>\n<li><p>冲正</p>\n<p>当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nA(消费) --&gt; B&#123;是否有上一笔&lt;br&gt;的消费记录&#125;\nB --&gt;|是|C(请求冲正)\nC --&gt; D&#123;冲正成功 或&lt;br&gt;超过最大冲正次数&#125;\nD --&gt; |是|E(清除冲正记录)\nE --&gt; F(结束)\nD --&gt; |否|C\nB --&gt; |否|G(保存此次消费记录)\nG --&gt; K(请求交易)\nK --&gt; H&#123;响应交易&#125;\nH --&gt; |交易成功|I(交易成功)\nI --&gt; L(清除此次消费记录)\nL --&gt; F\nH --&gt; |交易失败|J(交易失败)\nJ --&gt; M(不清除本次消费记录&lt;br&gt;下次消费时冲正)\nM --&gt; F</code></pre>\n\n"},{"title":"shell 脚本中读取参数值","date":"2017-05-25T03:14:12.000Z","_content":"\nshell 脚本中读取参数值\n\n通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了\n\n## 根据参数位置直接获取\n\n1. 先定义一个脚本test.sh，打印位置参数\n\n   ```ssh\n   #!/bin/bash\n\n   echo $1\n   echo $2\n   ```\n\n2. 执行test.sh脚本\n\n   ```ssh\n   ./test.sh haha hehehe\n   ```\n\n   执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。\n\n   <!-- more -->\n\n## 指定key 获取参数\n\n1. 一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义\n\n   ```ssh\n   #!/bin/bash\n\n   #先定义接收各个参数值的变量\n   IP_VALUE=\"\"; NODE_VALUE=\"\";VIP_VALUE=\"\";\n\n   while true;do \n   \tif [ ! $2 ]; then break; fi\n   \tcase $1 in\n   \t\t-i|--ip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")IP_VALUE=\"\";shift 2;;\n   \t\t\t*)IP_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-n|--node)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-v|--vip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t --) shift ;break ;;\n   \t\t *) break;;\n   \t\tesac\n   done\n\n   if [ -z \"${IP_VALUE}\" ];    then echo \"error: ip is not found.\";             exit 1; fi\n   if [ -z \"${NODE_VALUE}\" ];  then echo \"error: node is not found.\";           exit 1; fi\n   if [ -z \"${VIP_VALUE}\" ];   then echo \"error: vip is not found.\";            exit 1; fi\n   ```\n\n   - 通过while 循环参数的$1 和$2 取key 和 value。\n   - case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:`./test.sh -v kkk -n bbbb` 读取到如果执行了 shift 2,它就会把-v kkk 给扔了\n   - 底下的if 是判断有没有读取到想要的值\n\n2. 其他的方式去根据key获取参数\n\n   - 一个是getopts 但是getopts不支持长选项，具体可以参考[getopts命令行参数处理](http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html)\n   - 另一个是getopt，[shell中使用getopts 和 getopt](http://blog.csdn.net/wh211212/article/details/53750366)\n\n个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！","source":"_posts/shell 脚本中读取参数值.md","raw":"---\ntitle: shell 脚本中读取参数值\ndate: 2017-05-25 11:14:12\ntags: \n- shell\ncategories:\n- Linux\n---\n\nshell 脚本中读取参数值\n\n通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了\n\n## 根据参数位置直接获取\n\n1. 先定义一个脚本test.sh，打印位置参数\n\n   ```ssh\n   #!/bin/bash\n\n   echo $1\n   echo $2\n   ```\n\n2. 执行test.sh脚本\n\n   ```ssh\n   ./test.sh haha hehehe\n   ```\n\n   执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。\n\n   <!-- more -->\n\n## 指定key 获取参数\n\n1. 一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义\n\n   ```ssh\n   #!/bin/bash\n\n   #先定义接收各个参数值的变量\n   IP_VALUE=\"\"; NODE_VALUE=\"\";VIP_VALUE=\"\";\n\n   while true;do \n   \tif [ ! $2 ]; then break; fi\n   \tcase $1 in\n   \t\t-i|--ip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")IP_VALUE=\"\";shift 2;;\n   \t\t\t*)IP_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-n|--node)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-v|--vip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t --) shift ;break ;;\n   \t\t *) break;;\n   \t\tesac\n   done\n\n   if [ -z \"${IP_VALUE}\" ];    then echo \"error: ip is not found.\";             exit 1; fi\n   if [ -z \"${NODE_VALUE}\" ];  then echo \"error: node is not found.\";           exit 1; fi\n   if [ -z \"${VIP_VALUE}\" ];   then echo \"error: vip is not found.\";            exit 1; fi\n   ```\n\n   - 通过while 循环参数的$1 和$2 取key 和 value。\n   - case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:`./test.sh -v kkk -n bbbb` 读取到如果执行了 shift 2,它就会把-v kkk 给扔了\n   - 底下的if 是判断有没有读取到想要的值\n\n2. 其他的方式去根据key获取参数\n\n   - 一个是getopts 但是getopts不支持长选项，具体可以参考[getopts命令行参数处理](http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html)\n   - 另一个是getopt，[shell中使用getopts 和 getopt](http://blog.csdn.net/wh211212/article/details/53750366)\n\n个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！","slug":"shell 脚本中读取参数值","published":1,"updated":"2020-02-27T03:49:30.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0m001hmdymhn7z9zpe","content":"<p>shell 脚本中读取参数值</p>\n<p>通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了</p>\n<h2 id=\"根据参数位置直接获取\"><a href=\"#根据参数位置直接获取\" class=\"headerlink\" title=\"根据参数位置直接获取\"></a>根据参数位置直接获取</h2><ol>\n<li><p>先定义一个脚本test.sh，打印位置参数</p>\n<pre><code class=\"hljs ssh\">#!&#x2F;bin&#x2F;bash\n\necho $1\necho $2</code></pre>\n</li>\n<li><p>执行test.sh脚本</p>\n<pre><code class=\"hljs ssh\">.&#x2F;test.sh haha hehehe</code></pre>\n\n<p>执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。</p>\n<a id=\"more\"></a>\n\n</li>\n</ol>\n<h2 id=\"指定key-获取参数\"><a href=\"#指定key-获取参数\" class=\"headerlink\" title=\"指定key 获取参数\"></a>指定key 获取参数</h2><ol>\n<li><p>一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义</p>\n<pre><code class=\"hljs ssh\">#!&#x2F;bin&#x2F;bash\n\n#先定义接收各个参数值的变量\nIP_VALUE&#x3D;&quot;&quot;; NODE_VALUE&#x3D;&quot;&quot;;VIP_VALUE&#x3D;&quot;&quot;;\n\nwhile true;do \n\tif [ ! $2 ]; then break; fi\n\tcase $1 in\n\t\t-i|--ip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)IP_VALUE&#x3D;&quot;&quot;;shift 2;;\n\t\t\t*)IP_VALUE&#x3D;$2;shift 2;;\n\t\t\tesac;;\n\t\t-n|--node)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE&#x3D;&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE&#x3D;$2;shift 2;;\n\t\t\tesac;;\n\t\t-v|--vip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE&#x3D;&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE&#x3D;$2;shift 2;;\n\t\t\tesac;;\n\t\t --) shift ;break ;;\n\t\t *) break;;\n\t\tesac\ndone\n\nif [ -z &quot;$&#123;IP_VALUE&#125;&quot; ];    then echo &quot;error: ip is not found.&quot;;             exit 1; fi\nif [ -z &quot;$&#123;NODE_VALUE&#125;&quot; ];  then echo &quot;error: node is not found.&quot;;           exit 1; fi\nif [ -z &quot;$&#123;VIP_VALUE&#125;&quot; ];   then echo &quot;error: vip is not found.&quot;;            exit 1; fi</code></pre>\n\n<ul>\n<li>通过while 循环参数的$1 和$2 取key 和 value。</li>\n<li>case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:<code>./test.sh -v kkk -n bbbb</code> 读取到如果执行了 shift 2,它就会把-v kkk 给扔了</li>\n<li>底下的if 是判断有没有读取到想要的值</li>\n</ul>\n</li>\n<li><p>其他的方式去根据key获取参数</p>\n<ul>\n<li>一个是getopts 但是getopts不支持长选项，具体可以参考<a href=\"http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html\">getopts命令行参数处理</a></li>\n<li>另一个是getopt，<a href=\"http://blog.csdn.net/wh211212/article/details/53750366\">shell中使用getopts 和 getopt</a></li>\n</ul>\n</li>\n</ol>\n<p>个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！</p>\n","site":{"data":{}},"excerpt":"<p>shell 脚本中读取参数值</p>\n<p>通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了</p>\n<h2 id=\"根据参数位置直接获取\"><a href=\"#根据参数位置直接获取\" class=\"headerlink\" title=\"根据参数位置直接获取\"></a>根据参数位置直接获取</h2><ol>\n<li><p>先定义一个脚本test.sh，打印位置参数</p>\n<pre><code class=\"hljs ssh\">#!&#x2F;bin&#x2F;bash\n\necho $1\necho $2</code></pre>\n</li>\n<li><p>执行test.sh脚本</p>\n<pre><code class=\"hljs ssh\">.&#x2F;test.sh haha hehehe</code></pre>\n\n<p>执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。</p>","more":"</li>\n</ol>\n<h2 id=\"指定key-获取参数\"><a href=\"#指定key-获取参数\" class=\"headerlink\" title=\"指定key 获取参数\"></a>指定key 获取参数</h2><ol>\n<li><p>一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义</p>\n<pre><code class=\"hljs ssh\">#!&#x2F;bin&#x2F;bash\n\n#先定义接收各个参数值的变量\nIP_VALUE&#x3D;&quot;&quot;; NODE_VALUE&#x3D;&quot;&quot;;VIP_VALUE&#x3D;&quot;&quot;;\n\nwhile true;do \n\tif [ ! $2 ]; then break; fi\n\tcase $1 in\n\t\t-i|--ip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)IP_VALUE&#x3D;&quot;&quot;;shift 2;;\n\t\t\t*)IP_VALUE&#x3D;$2;shift 2;;\n\t\t\tesac;;\n\t\t-n|--node)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE&#x3D;&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE&#x3D;$2;shift 2;;\n\t\t\tesac;;\n\t\t-v|--vip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE&#x3D;&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE&#x3D;$2;shift 2;;\n\t\t\tesac;;\n\t\t --) shift ;break ;;\n\t\t *) break;;\n\t\tesac\ndone\n\nif [ -z &quot;$&#123;IP_VALUE&#125;&quot; ];    then echo &quot;error: ip is not found.&quot;;             exit 1; fi\nif [ -z &quot;$&#123;NODE_VALUE&#125;&quot; ];  then echo &quot;error: node is not found.&quot;;           exit 1; fi\nif [ -z &quot;$&#123;VIP_VALUE&#125;&quot; ];   then echo &quot;error: vip is not found.&quot;;            exit 1; fi</code></pre>\n\n<ul>\n<li>通过while 循环参数的$1 和$2 取key 和 value。</li>\n<li>case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:<code>./test.sh -v kkk -n bbbb</code> 读取到如果执行了 shift 2,它就会把-v kkk 给扔了</li>\n<li>底下的if 是判断有没有读取到想要的值</li>\n</ul>\n</li>\n<li><p>其他的方式去根据key获取参数</p>\n<ul>\n<li>一个是getopts 但是getopts不支持长选项，具体可以参考<a href=\"http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html\">getopts命令行参数处理</a></li>\n<li>另一个是getopt，<a href=\"http://blog.csdn.net/wh211212/article/details/53750366\">shell中使用getopts 和 getopt</a></li>\n</ul>\n</li>\n</ol>\n<p>个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！</p>"},{"title":"公众号开发前端","date":"2017-06-19T03:33:30.000Z","_content":"\n上一篇讲了微信公众号后端的开发，这一篇是讲讲前端页面的开发。前端的技术栈用的是react。这里介绍了在开发过程中遇到的一些问题。以及一些知识点的介绍\n\n以下步骤的前提是你已经安装了node，才能继续往下走。\n\n## 创建一个node工程\n\n​\t初始化一个工程，并进行一些基本信息填写。执行`npm init`，根据提示填写信息，最后会生成一个package.json 文件。这样一个node工程初始化完成了。以下package.json 文件是我修改过的，默认生成的文件和这个是有差异的。主要讲解几个字段，main:表示入口文件，scripts：主要是脚本命令，执行npm start 的时候，它会执行scripts 下start 后的命令，dependencies：是工程依赖的一些库，devDependencies：主要是开发的时候使用的一些库，生产的时候不需要使用。\n\n<!-- more -->\n\n```json\n{\n  \"name\": \"doudou-client\",\n  \"version\": \"1.0.0\",\n  \"description\": \"wechat public\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080\",\n    \"dev\": \"webpack -d --watch\"\n  },\n  \"author\": \"cocoon\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \n  },\n  \"devDependencies\": {\n    \"webpack\": \"^1.12.2\",\n    \"webpack-dev-server\": \"^1.12.1\"\n  }\n}\n```\n\n​\t有一个package.json  文件还不能使用，接下来是编写app.js文件，也就是入口文件，我们就简易的写一个demo文件吧！我们要使用react进行开发我们就得安装reactjs 相关的依赖，执行以下命令来添加reactjs 依赖的库,和开发时使用的一些开发库。如：webpack\n\n ```sh\nnpm install --save react react-dom\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\nnpm install --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-react\nnpm install --save-dev webpack webpack-dev-server\n ```\n\n创建一个app.js文件\n\n```jsx\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nclass App extends Component {\n    render() {\n           return (\n               <div>hello wechat test</div>\n           );\n       }\n}\nReactDOM.render((\n       <App/>\n), document.getElementById('container'));\n```\n\n​\t除了js文件之外，我们还需要一个 html文件，来加载这些js文件。\n\n```html\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n    <link rel=\"stylesheet\" href=\"src/css/fontAwesome/css/font-awesome.min.css\">\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css\" />\n\n    <title>微信公众号网页</title>\n    <script>\n        function setHeight() {\n            console.log(screen.height)\n            document.body.style.height = screen.height + 'px';\n        }\n    </script>\n</head>\n<body style=\"width: 100%;\" onload=\"setHeight()\">\n<div id=\"container\" id=\"container\" style=\"height: 100%\"></div>\n<script src=\"./assets/vendor.bundle.js\"></script>\n<script src=\"./assets/bundle.js\"></script>\n</body>\n</html>\n```\n\n​\t发现我们的html页面中并没有加载app.js文件，是因为我们通过webpack 来打包js文件，css文件，图片等。html页面加载的是我们打包之后的文件。所以我们在工程目录下创建一个webpack.config.js文件，来配置webpack一些打包的配置项\n\n```js\nvar webpack = require('webpack');\nvar path = require('path');\nvar autoprefixer = require('autoprefixer');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');\nvar OpenBrowserPlugin = require('open-browser-webpack-plugin');\n\nmodule.exports = {\n    entry: {\n        js: ['./app.js'],\n        vendor: ['react', 'classnames', 'react-router', 'react-dom', 'react-addons-css-transition-group']\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: './bundle.js'\n    },\n    devServer:{\n        proxy:{\n            '/api':{\n                target:'http://localhost:5000',\n                secure: false,\n                changeOrigin: true,\n                pathRewrite: {'^/api': ''}\n            }\n        },\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.js[x]?$/,\n                exclude: /node_modules/,\n                loader: 'babel',\n                query: {\n                    cacheDirectory: true,\n                    presets: ['es2015', 'react']\n                }\n            }, {\n                test: /\\.less$/,\n                loader: 'style!css!postcss!less'\n            }, {\n                test: /\\.css/,\n                loader: ExtractTextPlugin.extract('style', 'css', 'postcss')\n            }, {\n                test: /\\.(png|jpg|svg)$/,\n                loader: 'url?limit=25000'\n            }\n        ]\n    },\n    postcss: [autoprefixer],\n    plugins: [\n        new webpack.DefinePlugin({\n            DEBUG: process.env.NODE_ENV !== 'production'\n        }),\n        new ExtractTextPlugin('weui.min.css'),\n        new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js'),\n        \n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, './index.html')\n        }),\n    ]\n};\n\n```\n\n​\t更多的webpack学习，请移步[webpack学习入门](https://zhaoda.gitbooks.io/webpack/content/)\n\n\n\n整个工程demo在GitHub上[wechat_public_template](https://github.com/Cocoon-break/wechat_public_template)\n\n## 常规问题\n\n- 网页无法适应全屏？\n\n  在开发过程中发现body标签高度始终无法全屏，及时设置高度为100%，也无法生效。\n\n   ```html\n  <!--1.添加移动适配设置 -->\n  <meta name=\"viewport\"\n            content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n\n  <!--2.添加js动态的把body高度设置为，设备屏高-->\n  <script>\n          function setHeight() {\n              document.body.style.height = screen.height + 'px';\n          }\n  </script>\n\n  <!--3.在body onload 时执行js-->\n  <body style=\"width: 100%;\" onload=\"setHeight()\"></body>\n   ```\n\n  \n\n## 开源库使用时遇到的问题\n\n- 在使用react-weui 发现样式无法生效\n\n  ```js\n  import 'react-weui/lib/react-weui.min.css';//导入对应样式文件\n  ```\n\n- 在使用fontawesome 时，发现图标无法显示\n\n   ```html\n   <!--在html中把样式文件加上-->\n   <link rel=\"stylesheet\" href=\"src/css/fontAwesome/css/font-awesome.min.css\">\n   ```\n\n- 开发时想通过fetch直接请求服务端接口，解决跨域问题\n\n  ```js\n  //package.json 使用webpack-dev-server 启动开发环境，重点是-d\n  \"scripts\":{\n    \"start\": \"webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080\",\n  }\n\n  //webpack.config.js 配置代理\n    module.exports = {\n      //其他配置省略\n      devServer:{\n          proxy:{\n              '/api':{\n                  target:'http://localhost:5000',\n                  secure: false,\n                  changeOrigin: true,\n                  pathRewrite: {'^/api': ''}\n              }\n          },\n      },\n    }\n    \n  //使用时代码\n    fetch('/api/show_operation/1')\n              .then(response=>response.json())\n              .then(result=>console.log(result))\n    \n  //说明：通过proxy配置可以最终发出的请求路径为http://localhost:500/show_operation/1\n  ```\n\n  \n\n","source":"_posts/公众号web开发过程记录.md","raw":"---\ntitle: 公众号开发前端\ndate: 2017-06-19 11:33:30\ntags: \n- react web\ncategories:\n- 前端\n---\n\n上一篇讲了微信公众号后端的开发，这一篇是讲讲前端页面的开发。前端的技术栈用的是react。这里介绍了在开发过程中遇到的一些问题。以及一些知识点的介绍\n\n以下步骤的前提是你已经安装了node，才能继续往下走。\n\n## 创建一个node工程\n\n​\t初始化一个工程，并进行一些基本信息填写。执行`npm init`，根据提示填写信息，最后会生成一个package.json 文件。这样一个node工程初始化完成了。以下package.json 文件是我修改过的，默认生成的文件和这个是有差异的。主要讲解几个字段，main:表示入口文件，scripts：主要是脚本命令，执行npm start 的时候，它会执行scripts 下start 后的命令，dependencies：是工程依赖的一些库，devDependencies：主要是开发的时候使用的一些库，生产的时候不需要使用。\n\n<!-- more -->\n\n```json\n{\n  \"name\": \"doudou-client\",\n  \"version\": \"1.0.0\",\n  \"description\": \"wechat public\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080\",\n    \"dev\": \"webpack -d --watch\"\n  },\n  \"author\": \"cocoon\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \n  },\n  \"devDependencies\": {\n    \"webpack\": \"^1.12.2\",\n    \"webpack-dev-server\": \"^1.12.1\"\n  }\n}\n```\n\n​\t有一个package.json  文件还不能使用，接下来是编写app.js文件，也就是入口文件，我们就简易的写一个demo文件吧！我们要使用react进行开发我们就得安装reactjs 相关的依赖，执行以下命令来添加reactjs 依赖的库,和开发时使用的一些开发库。如：webpack\n\n ```sh\nnpm install --save react react-dom\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\nnpm install --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-react\nnpm install --save-dev webpack webpack-dev-server\n ```\n\n创建一个app.js文件\n\n```jsx\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nclass App extends Component {\n    render() {\n           return (\n               <div>hello wechat test</div>\n           );\n       }\n}\nReactDOM.render((\n       <App/>\n), document.getElementById('container'));\n```\n\n​\t除了js文件之外，我们还需要一个 html文件，来加载这些js文件。\n\n```html\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n    <link rel=\"stylesheet\" href=\"src/css/fontAwesome/css/font-awesome.min.css\">\n\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css\" />\n\n    <title>微信公众号网页</title>\n    <script>\n        function setHeight() {\n            console.log(screen.height)\n            document.body.style.height = screen.height + 'px';\n        }\n    </script>\n</head>\n<body style=\"width: 100%;\" onload=\"setHeight()\">\n<div id=\"container\" id=\"container\" style=\"height: 100%\"></div>\n<script src=\"./assets/vendor.bundle.js\"></script>\n<script src=\"./assets/bundle.js\"></script>\n</body>\n</html>\n```\n\n​\t发现我们的html页面中并没有加载app.js文件，是因为我们通过webpack 来打包js文件，css文件，图片等。html页面加载的是我们打包之后的文件。所以我们在工程目录下创建一个webpack.config.js文件，来配置webpack一些打包的配置项\n\n```js\nvar webpack = require('webpack');\nvar path = require('path');\nvar autoprefixer = require('autoprefixer');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');\nvar OpenBrowserPlugin = require('open-browser-webpack-plugin');\n\nmodule.exports = {\n    entry: {\n        js: ['./app.js'],\n        vendor: ['react', 'classnames', 'react-router', 'react-dom', 'react-addons-css-transition-group']\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: './bundle.js'\n    },\n    devServer:{\n        proxy:{\n            '/api':{\n                target:'http://localhost:5000',\n                secure: false,\n                changeOrigin: true,\n                pathRewrite: {'^/api': ''}\n            }\n        },\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.js[x]?$/,\n                exclude: /node_modules/,\n                loader: 'babel',\n                query: {\n                    cacheDirectory: true,\n                    presets: ['es2015', 'react']\n                }\n            }, {\n                test: /\\.less$/,\n                loader: 'style!css!postcss!less'\n            }, {\n                test: /\\.css/,\n                loader: ExtractTextPlugin.extract('style', 'css', 'postcss')\n            }, {\n                test: /\\.(png|jpg|svg)$/,\n                loader: 'url?limit=25000'\n            }\n        ]\n    },\n    postcss: [autoprefixer],\n    plugins: [\n        new webpack.DefinePlugin({\n            DEBUG: process.env.NODE_ENV !== 'production'\n        }),\n        new ExtractTextPlugin('weui.min.css'),\n        new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js'),\n        \n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, './index.html')\n        }),\n    ]\n};\n\n```\n\n​\t更多的webpack学习，请移步[webpack学习入门](https://zhaoda.gitbooks.io/webpack/content/)\n\n\n\n整个工程demo在GitHub上[wechat_public_template](https://github.com/Cocoon-break/wechat_public_template)\n\n## 常规问题\n\n- 网页无法适应全屏？\n\n  在开发过程中发现body标签高度始终无法全屏，及时设置高度为100%，也无法生效。\n\n   ```html\n  <!--1.添加移动适配设置 -->\n  <meta name=\"viewport\"\n            content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n\n  <!--2.添加js动态的把body高度设置为，设备屏高-->\n  <script>\n          function setHeight() {\n              document.body.style.height = screen.height + 'px';\n          }\n  </script>\n\n  <!--3.在body onload 时执行js-->\n  <body style=\"width: 100%;\" onload=\"setHeight()\"></body>\n   ```\n\n  \n\n## 开源库使用时遇到的问题\n\n- 在使用react-weui 发现样式无法生效\n\n  ```js\n  import 'react-weui/lib/react-weui.min.css';//导入对应样式文件\n  ```\n\n- 在使用fontawesome 时，发现图标无法显示\n\n   ```html\n   <!--在html中把样式文件加上-->\n   <link rel=\"stylesheet\" href=\"src/css/fontAwesome/css/font-awesome.min.css\">\n   ```\n\n- 开发时想通过fetch直接请求服务端接口，解决跨域问题\n\n  ```js\n  //package.json 使用webpack-dev-server 启动开发环境，重点是-d\n  \"scripts\":{\n    \"start\": \"webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080\",\n  }\n\n  //webpack.config.js 配置代理\n    module.exports = {\n      //其他配置省略\n      devServer:{\n          proxy:{\n              '/api':{\n                  target:'http://localhost:5000',\n                  secure: false,\n                  changeOrigin: true,\n                  pathRewrite: {'^/api': ''}\n              }\n          },\n      },\n    }\n    \n  //使用时代码\n    fetch('/api/show_operation/1')\n              .then(response=>response.json())\n              .then(result=>console.log(result))\n    \n  //说明：通过proxy配置可以最终发出的请求路径为http://localhost:500/show_operation/1\n  ```\n\n  \n\n","slug":"公众号web开发过程记录","published":1,"updated":"2020-02-27T03:48:22.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0n001jmdymbml10z3d","content":"<p>上一篇讲了微信公众号后端的开发，这一篇是讲讲前端页面的开发。前端的技术栈用的是react。这里介绍了在开发过程中遇到的一些问题。以及一些知识点的介绍</p>\n<p>以下步骤的前提是你已经安装了node，才能继续往下走。</p>\n<h2 id=\"创建一个node工程\"><a href=\"#创建一个node工程\" class=\"headerlink\" title=\"创建一个node工程\"></a>创建一个node工程</h2><p>​    初始化一个工程，并进行一些基本信息填写。执行<code>npm init</code>，根据提示填写信息，最后会生成一个package.json 文件。这样一个node工程初始化完成了。以下package.json 文件是我修改过的，默认生成的文件和这个是有差异的。主要讲解几个字段，main:表示入口文件，scripts：主要是脚本命令，执行npm start 的时候，它会执行scripts 下start 后的命令，dependencies：是工程依赖的一些库，devDependencies：主要是开发的时候使用的一些库，生产的时候不需要使用。</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;doudou-client&quot;</span>,\n  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,\n  <span class=\"hljs-attr\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;wechat public&quot;</span>,\n  <span class=\"hljs-attr\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;app.js&quot;</span>,\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: &#123;\n    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span>,\n    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;</span>,\n    <span class=\"hljs-attr\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;webpack -d --watch&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">&quot;author&quot;</span>: <span class=\"hljs-string\">&quot;cocoon&quot;</span>,\n  <span class=\"hljs-attr\">&quot;license&quot;</span>: <span class=\"hljs-string\">&quot;ISC&quot;</span>,\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: &#123;\n    \n  &#125;,\n  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: &#123;\n    <span class=\"hljs-attr\">&quot;webpack&quot;</span>: <span class=\"hljs-string\">&quot;^1.12.2&quot;</span>,\n    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span>: <span class=\"hljs-string\">&quot;^1.12.1&quot;</span>\n  &#125;\n&#125;</code></pre>\n\n<p>​    有一个package.json  文件还不能使用，接下来是编写app.js文件，也就是入口文件，我们就简易的写一个demo文件吧！我们要使用react进行开发我们就得安装reactjs 相关的依赖，执行以下命令来添加reactjs 依赖的库,和开发时使用的一些开发库。如：webpack</p>\n <pre><code class=\"hljs sh\">npm install --save react react-dom\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\nnpm install --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-react\nnpm install --save-dev webpack webpack-dev-server</code></pre>\n\n<p>创建一个app.js文件</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n           <span class=\"hljs-keyword\">return</span> (\n               &lt;div&gt;hello wechat test&lt;/div&gt;\n           );\n       &#125;\n&#125;\nReactDOM.render((\n       &lt;App/&gt;\n), <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;container&#x27;</span>));</code></pre>\n\n<p>​    除了js文件之外，我们还需要一个 html文件，来加载这些js文件。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span>\n<span class=\"hljs-tag\">          <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>微信公众号网页<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setHeight</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">console</span>.log(screen.height)</span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">document</span>.body.style.height = screen.height + <span class=\"hljs-string\">&#x27;px&#x27;</span>;</span>\n        &#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;width: 100%;&quot;</span> <span class=\"hljs-attr\">onload</span>=<span class=\"hljs-string\">&quot;setHeight()&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;height: 100%&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./assets/vendor.bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./assets/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n\n<p>​    发现我们的html页面中并没有加载app.js文件，是因为我们通过webpack 来打包js文件，css文件，图片等。html页面加载的是我们打包之后的文件。所以我们在工程目录下创建一个webpack.config.js文件，来配置webpack一些打包的配置项</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> autoprefixer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;autoprefixer&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> ExtractTextPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;extract-text-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> OpenBrowserPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;open-browser-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-built_in\">module</span>.exports = &#123;\n    entry: &#123;\n        js: [<span class=\"hljs-string\">&#x27;./app.js&#x27;</span>],\n        vendor: [<span class=\"hljs-string\">&#x27;react&#x27;</span>, <span class=\"hljs-string\">&#x27;classnames&#x27;</span>, <span class=\"hljs-string\">&#x27;react-router&#x27;</span>, <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>, <span class=\"hljs-string\">&#x27;react-addons-css-transition-group&#x27;</span>]\n    &#125;,\n    output: &#123;\n        path: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n        filename: <span class=\"hljs-string\">&#x27;./bundle.js&#x27;</span>\n    &#125;,\n    devServer:&#123;\n        proxy:&#123;\n            <span class=\"hljs-string\">&#x27;/api&#x27;</span>:&#123;\n                target:<span class=\"hljs-string\">&#x27;http://localhost:5000&#x27;</span>,\n                secure: <span class=\"hljs-literal\">false</span>,\n                changeOrigin: <span class=\"hljs-literal\">true</span>,\n                pathRewrite: &#123;<span class=\"hljs-string\">&#x27;^/api&#x27;</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>&#125;\n            &#125;\n        &#125;,\n    &#125;,\n    <span class=\"hljs-built_in\">module</span>: &#123;\n        loaders: [\n            &#123;\n                test: <span class=\"hljs-regexp\">/\\.js[x]?$/</span>,\n                exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n                loader: <span class=\"hljs-string\">&#x27;babel&#x27;</span>,\n                query: &#123;\n                    cacheDirectory: <span class=\"hljs-literal\">true</span>,\n                    presets: [<span class=\"hljs-string\">&#x27;es2015&#x27;</span>, <span class=\"hljs-string\">&#x27;react&#x27;</span>]\n                &#125;\n            &#125;, &#123;\n                test: <span class=\"hljs-regexp\">/\\.less$/</span>,\n                loader: <span class=\"hljs-string\">&#x27;style!css!postcss!less&#x27;</span>\n            &#125;, &#123;\n                test: <span class=\"hljs-regexp\">/\\.css/</span>,\n                loader: ExtractTextPlugin.extract(<span class=\"hljs-string\">&#x27;style&#x27;</span>, <span class=\"hljs-string\">&#x27;css&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss&#x27;</span>)\n            &#125;, &#123;\n                test: <span class=\"hljs-regexp\">/\\.(png|jpg|svg)$/</span>,\n                loader: <span class=\"hljs-string\">&#x27;url?limit=25000&#x27;</span>\n            &#125;\n        ]\n    &#125;,\n    postcss: [autoprefixer],\n    plugins: [\n        <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin(&#123;\n            DEBUG: process.env.NODE_ENV !== <span class=\"hljs-string\">&#x27;production&#x27;</span>\n        &#125;),\n        <span class=\"hljs-keyword\">new</span> ExtractTextPlugin(<span class=\"hljs-string\">&#x27;weui.min.css&#x27;</span>),\n        <span class=\"hljs-keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"hljs-string\">&#x27;vendor&#x27;</span>, <span class=\"hljs-string\">&#x27;vendor.bundle.js&#x27;</span>),\n        \n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin(&#123;\n            template: path.join(__dirname, <span class=\"hljs-string\">&#x27;./index.html&#x27;</span>)\n        &#125;),\n    ]\n&#125;;\n</code></pre>\n\n<p>​    更多的webpack学习，请移步<a href=\"https://zhaoda.gitbooks.io/webpack/content/\">webpack学习入门</a></p>\n<p>整个工程demo在GitHub上<a href=\"https://github.com/Cocoon-break/wechat_public_template\">wechat_public_template</a></p>\n<h2 id=\"常规问题\"><a href=\"#常规问题\" class=\"headerlink\" title=\"常规问题\"></a>常规问题</h2><ul>\n<li><p>网页无法适应全屏？</p>\n<p>在开发过程中发现body标签高度始终无法全屏，及时设置高度为100%，也无法生效。</p>\n <pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--1.添加移动适配设置 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span>\n<span class=\"hljs-tag\">          <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--2.添加js动态的把body高度设置为，设备屏高--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setHeight</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">document</span>.body.style.height = screen.height + <span class=\"hljs-string\">&#x27;px&#x27;</span>;</span>\n        &#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--3.在body onload 时执行js--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;width: 100%;&quot;</span> <span class=\"hljs-attr\">onload</span>=<span class=\"hljs-string\">&quot;setHeight()&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span></code></pre>\n\n\n\n</li>\n</ul>\n<h2 id=\"开源库使用时遇到的问题\"><a href=\"#开源库使用时遇到的问题\" class=\"headerlink\" title=\"开源库使用时遇到的问题\"></a>开源库使用时遇到的问题</h2><ul>\n<li><p>在使用react-weui 发现样式无法生效</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;react-weui/lib/react-weui.min.css&#x27;</span>;<span class=\"hljs-comment\">//导入对应样式文件</span></code></pre>\n</li>\n<li><p>在使用fontawesome 时，发现图标无法显示</p>\n <pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--在html中把样式文件加上--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;</span>&gt;</span></code></pre>\n</li>\n<li><p>开发时想通过fetch直接请求服务端接口，解决跨域问题</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">//package.json 使用webpack-dev-server 启动开发环境，重点是-d</span>\n<span class=\"hljs-string\">&quot;scripts&quot;</span>:&#123;\n  <span class=\"hljs-string\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;</span>,\n&#125;\n\n<span class=\"hljs-comment\">//webpack.config.js 配置代理</span>\n  <span class=\"hljs-built_in\">module</span>.exports = &#123;\n    <span class=\"hljs-comment\">//其他配置省略</span>\n    devServer:&#123;\n        proxy:&#123;\n            <span class=\"hljs-string\">&#x27;/api&#x27;</span>:&#123;\n                target:<span class=\"hljs-string\">&#x27;http://localhost:5000&#x27;</span>,\n                secure: <span class=\"hljs-literal\">false</span>,\n                changeOrigin: <span class=\"hljs-literal\">true</span>,\n                pathRewrite: &#123;<span class=\"hljs-string\">&#x27;^/api&#x27;</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>&#125;\n            &#125;\n        &#125;,\n    &#125;,\n  &#125;\n  \n<span class=\"hljs-comment\">//使用时代码</span>\n  fetch(<span class=\"hljs-string\">&#x27;/api/show_operation/1&#x27;</span>)\n            .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span>=&gt;</span>response.json())\n            .then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result))\n  \n<span class=\"hljs-comment\">//说明：通过proxy配置可以最终发出的请求路径为http://localhost:500/show_operation/1</span></code></pre>\n\n\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>上一篇讲了微信公众号后端的开发，这一篇是讲讲前端页面的开发。前端的技术栈用的是react。这里介绍了在开发过程中遇到的一些问题。以及一些知识点的介绍</p>\n<p>以下步骤的前提是你已经安装了node，才能继续往下走。</p>\n<h2 id=\"创建一个node工程\"><a href=\"#创建一个node工程\" class=\"headerlink\" title=\"创建一个node工程\"></a>创建一个node工程</h2><p>​    初始化一个工程，并进行一些基本信息填写。执行<code>npm init</code>，根据提示填写信息，最后会生成一个package.json 文件。这样一个node工程初始化完成了。以下package.json 文件是我修改过的，默认生成的文件和这个是有差异的。主要讲解几个字段，main:表示入口文件，scripts：主要是脚本命令，执行npm start 的时候，它会执行scripts 下start 后的命令，dependencies：是工程依赖的一些库，devDependencies：主要是开发的时候使用的一些库，生产的时候不需要使用。</p>","more":"<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;doudou-client&quot;</span>,\n  <span class=\"hljs-attr\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,\n  <span class=\"hljs-attr\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;wechat public&quot;</span>,\n  <span class=\"hljs-attr\">&quot;main&quot;</span>: <span class=\"hljs-string\">&quot;app.js&quot;</span>,\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span>: &#123;\n    <span class=\"hljs-attr\">&quot;test&quot;</span>: <span class=\"hljs-string\">&quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span>,\n    <span class=\"hljs-attr\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;</span>,\n    <span class=\"hljs-attr\">&quot;dev&quot;</span>: <span class=\"hljs-string\">&quot;webpack -d --watch&quot;</span>\n  &#125;,\n  <span class=\"hljs-attr\">&quot;author&quot;</span>: <span class=\"hljs-string\">&quot;cocoon&quot;</span>,\n  <span class=\"hljs-attr\">&quot;license&quot;</span>: <span class=\"hljs-string\">&quot;ISC&quot;</span>,\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span>: &#123;\n    \n  &#125;,\n  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span>: &#123;\n    <span class=\"hljs-attr\">&quot;webpack&quot;</span>: <span class=\"hljs-string\">&quot;^1.12.2&quot;</span>,\n    <span class=\"hljs-attr\">&quot;webpack-dev-server&quot;</span>: <span class=\"hljs-string\">&quot;^1.12.1&quot;</span>\n  &#125;\n&#125;</code></pre>\n\n<p>​    有一个package.json  文件还不能使用，接下来是编写app.js文件，也就是入口文件，我们就简易的写一个demo文件吧！我们要使用react进行开发我们就得安装reactjs 相关的依赖，执行以下命令来添加reactjs 依赖的库,和开发时使用的一些开发库。如：webpack</p>\n <pre><code class=\"hljs sh\">npm install --save react react-dom\nnpm install --save-dev css-loader\nnpm install --save-dev style-loader\nnpm install --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-react\nnpm install --save-dev webpack webpack-dev-server</code></pre>\n\n<p>创建一个app.js文件</p>\n<pre><code class=\"hljs jsx\"><span class=\"hljs-keyword\">import</span> React, &#123; Component &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n           <span class=\"hljs-keyword\">return</span> (\n               &lt;div&gt;hello wechat test&lt;/div&gt;\n           );\n       &#125;\n&#125;\nReactDOM.render((\n       &lt;App/&gt;\n), <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;container&#x27;</span>));</code></pre>\n\n<p>​    除了js文件之外，我们还需要一个 html文件，来加载这些js文件。</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-meta-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span>\n<span class=\"hljs-tag\">          <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick.min.css&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/css&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.6.0/slick-theme.min.css&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>微信公众号网页<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setHeight</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">console</span>.log(screen.height)</span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">document</span>.body.style.height = screen.height + <span class=\"hljs-string\">&#x27;px&#x27;</span>;</span>\n        &#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;width: 100%;&quot;</span> <span class=\"hljs-attr\">onload</span>=<span class=\"hljs-string\">&quot;setHeight()&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;container&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;height: 100%&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./assets/vendor.bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./assets/bundle.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></code></pre>\n\n<p>​    发现我们的html页面中并没有加载app.js文件，是因为我们通过webpack 来打包js文件，css文件，图片等。html页面加载的是我们打包之后的文件。所以我们在工程目录下创建一个webpack.config.js文件，来配置webpack一些打包的配置项</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;webpack&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> autoprefixer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;autoprefixer&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;html-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> ExtractTextPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;extract-text-webpack-plugin&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> OpenBrowserPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;open-browser-webpack-plugin&#x27;</span>);\n\n<span class=\"hljs-built_in\">module</span>.exports = &#123;\n    entry: &#123;\n        js: [<span class=\"hljs-string\">&#x27;./app.js&#x27;</span>],\n        vendor: [<span class=\"hljs-string\">&#x27;react&#x27;</span>, <span class=\"hljs-string\">&#x27;classnames&#x27;</span>, <span class=\"hljs-string\">&#x27;react-router&#x27;</span>, <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>, <span class=\"hljs-string\">&#x27;react-addons-css-transition-group&#x27;</span>]\n    &#125;,\n    output: &#123;\n        path: path.resolve(__dirname, <span class=\"hljs-string\">&#x27;dist&#x27;</span>),\n        filename: <span class=\"hljs-string\">&#x27;./bundle.js&#x27;</span>\n    &#125;,\n    devServer:&#123;\n        proxy:&#123;\n            <span class=\"hljs-string\">&#x27;/api&#x27;</span>:&#123;\n                target:<span class=\"hljs-string\">&#x27;http://localhost:5000&#x27;</span>,\n                secure: <span class=\"hljs-literal\">false</span>,\n                changeOrigin: <span class=\"hljs-literal\">true</span>,\n                pathRewrite: &#123;<span class=\"hljs-string\">&#x27;^/api&#x27;</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>&#125;\n            &#125;\n        &#125;,\n    &#125;,\n    <span class=\"hljs-built_in\">module</span>: &#123;\n        loaders: [\n            &#123;\n                test: <span class=\"hljs-regexp\">/\\.js[x]?$/</span>,\n                exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n                loader: <span class=\"hljs-string\">&#x27;babel&#x27;</span>,\n                query: &#123;\n                    cacheDirectory: <span class=\"hljs-literal\">true</span>,\n                    presets: [<span class=\"hljs-string\">&#x27;es2015&#x27;</span>, <span class=\"hljs-string\">&#x27;react&#x27;</span>]\n                &#125;\n            &#125;, &#123;\n                test: <span class=\"hljs-regexp\">/\\.less$/</span>,\n                loader: <span class=\"hljs-string\">&#x27;style!css!postcss!less&#x27;</span>\n            &#125;, &#123;\n                test: <span class=\"hljs-regexp\">/\\.css/</span>,\n                loader: ExtractTextPlugin.extract(<span class=\"hljs-string\">&#x27;style&#x27;</span>, <span class=\"hljs-string\">&#x27;css&#x27;</span>, <span class=\"hljs-string\">&#x27;postcss&#x27;</span>)\n            &#125;, &#123;\n                test: <span class=\"hljs-regexp\">/\\.(png|jpg|svg)$/</span>,\n                loader: <span class=\"hljs-string\">&#x27;url?limit=25000&#x27;</span>\n            &#125;\n        ]\n    &#125;,\n    postcss: [autoprefixer],\n    plugins: [\n        <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin(&#123;\n            DEBUG: process.env.NODE_ENV !== <span class=\"hljs-string\">&#x27;production&#x27;</span>\n        &#125;),\n        <span class=\"hljs-keyword\">new</span> ExtractTextPlugin(<span class=\"hljs-string\">&#x27;weui.min.css&#x27;</span>),\n        <span class=\"hljs-keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"hljs-string\">&#x27;vendor&#x27;</span>, <span class=\"hljs-string\">&#x27;vendor.bundle.js&#x27;</span>),\n        \n        <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin(&#123;\n            template: path.join(__dirname, <span class=\"hljs-string\">&#x27;./index.html&#x27;</span>)\n        &#125;),\n    ]\n&#125;;\n</code></pre>\n\n<p>​    更多的webpack学习，请移步<a href=\"https://zhaoda.gitbooks.io/webpack/content/\">webpack学习入门</a></p>\n<p>整个工程demo在GitHub上<a href=\"https://github.com/Cocoon-break/wechat_public_template\">wechat_public_template</a></p>\n<h2 id=\"常规问题\"><a href=\"#常规问题\" class=\"headerlink\" title=\"常规问题\"></a>常规问题</h2><ul>\n<li><p>网页无法适应全屏？</p>\n<p>在开发过程中发现body标签高度始终无法全屏，及时设置高度为100%，也无法生效。</p>\n <pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--1.添加移动适配设置 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span></span>\n<span class=\"hljs-tag\">          <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--2.添加js动态的把body高度设置为，设备屏高--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"javascript\">        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setHeight</span>(<span class=\"hljs-params\"></span>) </span>&#123;</span>\n<span class=\"javascript\">            <span class=\"hljs-built_in\">document</span>.body.style.height = screen.height + <span class=\"hljs-string\">&#x27;px&#x27;</span>;</span>\n        &#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--3.在body onload 时执行js--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;width: 100%;&quot;</span> <span class=\"hljs-attr\">onload</span>=<span class=\"hljs-string\">&quot;setHeight()&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span></code></pre>\n\n\n\n</li>\n</ul>\n<h2 id=\"开源库使用时遇到的问题\"><a href=\"#开源库使用时遇到的问题\" class=\"headerlink\" title=\"开源库使用时遇到的问题\"></a>开源库使用时遇到的问题</h2><ul>\n<li><p>在使用react-weui 发现样式无法生效</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;react-weui/lib/react-weui.min.css&#x27;</span>;<span class=\"hljs-comment\">//导入对应样式文件</span></code></pre>\n</li>\n<li><p>在使用fontawesome 时，发现图标无法显示</p>\n <pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--在html中把样式文件加上--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">&quot;stylesheet&quot;</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;src/css/fontAwesome/css/font-awesome.min.css&quot;</span>&gt;</span></code></pre>\n</li>\n<li><p>开发时想通过fetch直接请求服务端接口，解决跨域问题</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">//package.json 使用webpack-dev-server 启动开发环境，重点是-d</span>\n<span class=\"hljs-string\">&quot;scripts&quot;</span>:&#123;\n  <span class=\"hljs-string\">&quot;start&quot;</span>: <span class=\"hljs-string\">&quot;webpack-dev-server -d --hot --inline --progress --colors --host 0.0.0.0 --port 8080&quot;</span>,\n&#125;\n\n<span class=\"hljs-comment\">//webpack.config.js 配置代理</span>\n  <span class=\"hljs-built_in\">module</span>.exports = &#123;\n    <span class=\"hljs-comment\">//其他配置省略</span>\n    devServer:&#123;\n        proxy:&#123;\n            <span class=\"hljs-string\">&#x27;/api&#x27;</span>:&#123;\n                target:<span class=\"hljs-string\">&#x27;http://localhost:5000&#x27;</span>,\n                secure: <span class=\"hljs-literal\">false</span>,\n                changeOrigin: <span class=\"hljs-literal\">true</span>,\n                pathRewrite: &#123;<span class=\"hljs-string\">&#x27;^/api&#x27;</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>&#125;\n            &#125;\n        &#125;,\n    &#125;,\n  &#125;\n  \n<span class=\"hljs-comment\">//使用时代码</span>\n  fetch(<span class=\"hljs-string\">&#x27;/api/show_operation/1&#x27;</span>)\n            .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span>=&gt;</span>response.json())\n            .then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result))\n  \n<span class=\"hljs-comment\">//说明：通过proxy配置可以最终发出的请求路径为http://localhost:500/show_operation/1</span></code></pre>\n\n\n\n</li>\n</ul>"},{"title":"加密算法简介","date":"2017-08-28T07:47:00.000Z","_content":"\n​\t对于加密算法我也不是很熟，只能是单纯去使用，但是最近做项目时涉及到国密算法，由于个人对算法差不多是七窍通了六窍，一窍不通啊。于是同事给我科普了一下。\n\n​\t先将加密算法分两个大方向：1. 不可逆的加密算法 2. 不可逆的加密算法\n\n## 不可逆的加密算法\n\n​\t不可以逆的意思就是说，加密之后，你也不知道加密前的明文。如果要确认加密前的明文，你只能重新将明文加密一遍，看两次得出来的密文是否一致。不可逆加密算法的特征是加密过程中不需要使用密钥，直接输入明文通过算法处理后得到密文。\n\n​\t典型的不可逆的加密算法是**MD5** : MD5对要加密的对象没有大小限制，加密之后的密文长度为**128bit**,这里是128bit和字节是不一样的，转换成字节的话也就是16Byte。\n\n```sh\n~/tmp » md5 test.jpg\nMD5 (test.jpg) = f368d709b8652bf78f9ce61d9fd70d7a\n```\n\n上面的例子通过md5加密了一张图片,  MD5加密之后得到值是128bit，按4位二进制组合成一个十六进制，所以得出来的十六进制字符串是32个。\n\n一般来说不可逆的加密算法得出来的密文是定长的，无论要加密的内容大小是多少，如md5是32，sha256是64，sha512是128\n\n<!-- more -->\n\n## 可逆的加密算法\n\n​\t可逆的加密算法就是加密之后，还是有办法能够得到明文。可逆的加密算法又可分为对称加密和非对称加密。RSA就是典型的非对称的可逆加密算法。\n\n1. 对称的可逆加密算法\n\n   对称的加密算法，加密和解密用的都是同一个密钥，这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。对称加密算法的特点是算法公开、计算量小、加解密速度快、加解密效率高\n\n2. 非对称的可逆加密算法\n\n   非对称密钥算法是指一个加密算法的加密密钥和解密密钥是不一样的，或者说不能由其中一个密钥推导出另一个密钥。这两个密钥其中一个称为公钥，用于加密，是公开的，另一个称为私钥，用于解密，是保密的。其中由公钥计算私钥是计算上不可行的。\n\n\n\n - 分组加密\n- 向量加密","source":"_posts/加密算法简介.md","raw":"---\ntitle: 加密算法简介\ndate: 2017-08-28 15:47:00\ntags: \n- 扩展\ncategories:\n- 算法\n---\n\n​\t对于加密算法我也不是很熟，只能是单纯去使用，但是最近做项目时涉及到国密算法，由于个人对算法差不多是七窍通了六窍，一窍不通啊。于是同事给我科普了一下。\n\n​\t先将加密算法分两个大方向：1. 不可逆的加密算法 2. 不可逆的加密算法\n\n## 不可逆的加密算法\n\n​\t不可以逆的意思就是说，加密之后，你也不知道加密前的明文。如果要确认加密前的明文，你只能重新将明文加密一遍，看两次得出来的密文是否一致。不可逆加密算法的特征是加密过程中不需要使用密钥，直接输入明文通过算法处理后得到密文。\n\n​\t典型的不可逆的加密算法是**MD5** : MD5对要加密的对象没有大小限制，加密之后的密文长度为**128bit**,这里是128bit和字节是不一样的，转换成字节的话也就是16Byte。\n\n```sh\n~/tmp » md5 test.jpg\nMD5 (test.jpg) = f368d709b8652bf78f9ce61d9fd70d7a\n```\n\n上面的例子通过md5加密了一张图片,  MD5加密之后得到值是128bit，按4位二进制组合成一个十六进制，所以得出来的十六进制字符串是32个。\n\n一般来说不可逆的加密算法得出来的密文是定长的，无论要加密的内容大小是多少，如md5是32，sha256是64，sha512是128\n\n<!-- more -->\n\n## 可逆的加密算法\n\n​\t可逆的加密算法就是加密之后，还是有办法能够得到明文。可逆的加密算法又可分为对称加密和非对称加密。RSA就是典型的非对称的可逆加密算法。\n\n1. 对称的可逆加密算法\n\n   对称的加密算法，加密和解密用的都是同一个密钥，这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。对称加密算法的特点是算法公开、计算量小、加解密速度快、加解密效率高\n\n2. 非对称的可逆加密算法\n\n   非对称密钥算法是指一个加密算法的加密密钥和解密密钥是不一样的，或者说不能由其中一个密钥推导出另一个密钥。这两个密钥其中一个称为公钥，用于加密，是公开的，另一个称为私钥，用于解密，是保密的。其中由公钥计算私钥是计算上不可行的。\n\n\n\n - 分组加密\n- 向量加密","slug":"加密算法简介","published":1,"updated":"2020-02-27T03:22:06.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0o001omdymgflv0ge2","content":"<p>​    对于加密算法我也不是很熟，只能是单纯去使用，但是最近做项目时涉及到国密算法，由于个人对算法差不多是七窍通了六窍，一窍不通啊。于是同事给我科普了一下。</p>\n<p>​    先将加密算法分两个大方向：1. 不可逆的加密算法 2. 不可逆的加密算法</p>\n<h2 id=\"不可逆的加密算法\"><a href=\"#不可逆的加密算法\" class=\"headerlink\" title=\"不可逆的加密算法\"></a>不可逆的加密算法</h2><p>​    不可以逆的意思就是说，加密之后，你也不知道加密前的明文。如果要确认加密前的明文，你只能重新将明文加密一遍，看两次得出来的密文是否一致。不可逆加密算法的特征是加密过程中不需要使用密钥，直接输入明文通过算法处理后得到密文。</p>\n<p>​    典型的不可逆的加密算法是<strong>MD5</strong> : MD5对要加密的对象没有大小限制，加密之后的密文长度为<strong>128bit</strong>,这里是128bit和字节是不一样的，转换成字节的话也就是16Byte。</p>\n<pre><code class=\"hljs sh\">~/tmp » md5 test.jpg\nMD5 (test.jpg) = f368d709b8652bf78f9ce61d9fd70d7a</code></pre>\n\n<p>上面的例子通过md5加密了一张图片,  MD5加密之后得到值是128bit，按4位二进制组合成一个十六进制，所以得出来的十六进制字符串是32个。</p>\n<p>一般来说不可逆的加密算法得出来的密文是定长的，无论要加密的内容大小是多少，如md5是32，sha256是64，sha512是128</p>\n<a id=\"more\"></a>\n\n<h2 id=\"可逆的加密算法\"><a href=\"#可逆的加密算法\" class=\"headerlink\" title=\"可逆的加密算法\"></a>可逆的加密算法</h2><p>​    可逆的加密算法就是加密之后，还是有办法能够得到明文。可逆的加密算法又可分为对称加密和非对称加密。RSA就是典型的非对称的可逆加密算法。</p>\n<ol>\n<li><p>对称的可逆加密算法</p>\n<p>对称的加密算法，加密和解密用的都是同一个密钥，这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。对称加密算法的特点是算法公开、计算量小、加解密速度快、加解密效率高</p>\n</li>\n<li><p>非对称的可逆加密算法</p>\n<p>非对称密钥算法是指一个加密算法的加密密钥和解密密钥是不一样的，或者说不能由其中一个密钥推导出另一个密钥。这两个密钥其中一个称为公钥，用于加密，是公开的，另一个称为私钥，用于解密，是保密的。其中由公钥计算私钥是计算上不可行的。</p>\n</li>\n</ol>\n<ul>\n<li>分组加密<ul>\n<li>向量加密</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>​    对于加密算法我也不是很熟，只能是单纯去使用，但是最近做项目时涉及到国密算法，由于个人对算法差不多是七窍通了六窍，一窍不通啊。于是同事给我科普了一下。</p>\n<p>​    先将加密算法分两个大方向：1. 不可逆的加密算法 2. 不可逆的加密算法</p>\n<h2 id=\"不可逆的加密算法\"><a href=\"#不可逆的加密算法\" class=\"headerlink\" title=\"不可逆的加密算法\"></a>不可逆的加密算法</h2><p>​    不可以逆的意思就是说，加密之后，你也不知道加密前的明文。如果要确认加密前的明文，你只能重新将明文加密一遍，看两次得出来的密文是否一致。不可逆加密算法的特征是加密过程中不需要使用密钥，直接输入明文通过算法处理后得到密文。</p>\n<p>​    典型的不可逆的加密算法是<strong>MD5</strong> : MD5对要加密的对象没有大小限制，加密之后的密文长度为<strong>128bit</strong>,这里是128bit和字节是不一样的，转换成字节的话也就是16Byte。</p>\n<pre><code class=\"hljs sh\">~/tmp » md5 test.jpg\nMD5 (test.jpg) = f368d709b8652bf78f9ce61d9fd70d7a</code></pre>\n\n<p>上面的例子通过md5加密了一张图片,  MD5加密之后得到值是128bit，按4位二进制组合成一个十六进制，所以得出来的十六进制字符串是32个。</p>\n<p>一般来说不可逆的加密算法得出来的密文是定长的，无论要加密的内容大小是多少，如md5是32，sha256是64，sha512是128</p>","more":"<h2 id=\"可逆的加密算法\"><a href=\"#可逆的加密算法\" class=\"headerlink\" title=\"可逆的加密算法\"></a>可逆的加密算法</h2><p>​    可逆的加密算法就是加密之后，还是有办法能够得到明文。可逆的加密算法又可分为对称加密和非对称加密。RSA就是典型的非对称的可逆加密算法。</p>\n<ol>\n<li><p>对称的可逆加密算法</p>\n<p>对称的加密算法，加密和解密用的都是同一个密钥，这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。对称加密算法的特点是算法公开、计算量小、加解密速度快、加解密效率高</p>\n</li>\n<li><p>非对称的可逆加密算法</p>\n<p>非对称密钥算法是指一个加密算法的加密密钥和解密密钥是不一样的，或者说不能由其中一个密钥推导出另一个密钥。这两个密钥其中一个称为公钥，用于加密，是公开的，另一个称为私钥，用于解密，是保密的。其中由公钥计算私钥是计算上不可行的。</p>\n</li>\n</ol>\n<ul>\n<li>分组加密<ul>\n<li>向量加密</li>\n</ul>\n</li>\n</ul>"},{"title":"各个平台上传图片","date":"2017-06-13T02:47:00.000Z","_content":"\n开发时常遇到的一些上传图片操作，这里记录一下。包括android，iOS，和java后端，后面还遇到的其他语言或平台时，会进行补充\n\nandroid AsyncHttpClient 上传图片,要使用[android-async-http](https://github.com/loopj/android-async-http)\n\n```java\npublic void uploadImg(String filePath) {\n        AsyncHttpClient asyncHttpclient = new AsyncHttpClient();\n        RequestParams params = new RequestParams();\n        try {\n            params.put(\"liveness\", \"1\");\n            params.put(\"img\", new File(filePath));// 传入照片路径\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        String url = \"\";\n        asyncHttpclient.post(url, params, new AsyncHttpResponseHandler() {\n            @Override\n            public void onSuccess(int statusCode, Header[] headers,\n                                  byte[] responseByte) {\n                String successStr = new String(responseByte);\n                try {\n\n                    JSONObject jObject = new JSONObject(successStr)\n                            .getJSONArray(\"faces\").getJSONObject(0);\n                  //其他省略\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            @Override\n            public void onFailure(int statusCode, Header[] headers,\n                                  byte[] responseBody, Throwable error) {\n                // 上传失败\n            }\n        });\n    }\n```\n\n<!-- more -->\n\niOS NSMutableURLRequest上传图片，NSMutableURLRequest是oc自带库\n\n```objective-c\n- (void) uploadImage:(NSData *)imageData{\n    //字典里面装的是你要上传的内容\n    NSDictionary *parameters = @{@\"liveness\": @\"1\"};\n    //上传的接口\n    NSString* urlstring = @\"http://132.121.1.213:9000/faceid/v1/extract\";\n    //分界线的标识符\n    NSString *TWITTERFON_FORM_BOUNDARY = @\"AaB03x\";\n    //根据url初始化request\n    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]\n                                                            cachePolicy:NSURLRequestReloadIgnoringLocalCacheData\n                                                        timeoutInterval:10];\n    //分界线 --AaB03x\n    NSString *MPboundary=[[NSString alloc]initWithFormat:@\"--%@\",TWITTERFON_FORM_BOUNDARY];\n    //结束符 AaB03x--\n    NSString *endMPboundary=[[NSString alloc]initWithFormat:@\"%@--\",MPboundary];\n    //\t//要上传的图片\n    //\tUIImage *image=[params objectForKey:@\"pic\"];\n    //得到图片的data\n    //    NSData *data = UIImagePNGRepresentation(self.image);\n    //http body的字符串\n    NSMutableString *body=[[NSMutableString alloc]init];\n    //参数的集合的所有key的集合\n    NSArray *keys= [parameters allKeys];\n    //遍历keys\n    for(int i=0;i<[keys count];i++)\n    {\n        //得到当前key\n        NSString *key=[keys objectAtIndex:i];\n        //如果key不是img，说明value是字符类型，比如name：Boris\n        if(![key isEqualToString:@\"img\"])\n        {\n            //添加分界线，换行\n            [body appendFormat:@\"%@\\r\\n\",MPboundary];\n            //添加字段名称，换2行\n            [body appendFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\",key];\n            //添加字段的值\n            [body appendFormat:@\"%@\\r\\n\",[parameters objectForKey:key]];\n        }\n    }\n    ////添加分界线，换行\n    [body appendFormat:@\"%@\\r\\n\",MPboundary];\n    //声明img字段，文件名为boris.png\n    [body appendFormat:@\"Content-Disposition: form-data; name=\\\"img\\\"; filename=\\\"boris.png\\\"\\r\\n\"];\n    //声明上传文件的格式\n    [body appendFormat:@\"Content-Type: image/png\\r\\n\\r\\n\"];\n    //声明结束符：--AaB03x--\n    NSString *end=[[NSString alloc]initWithFormat:@\"\\r\\n%@\",endMPboundary];\n    //声明myRequestData，用来放入http body\n    NSMutableData *myRequestData=[NSMutableData data];\n    //将body字符串转化为UTF8格式的二进制\n    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];\n    //将image的data加入\n    [myRequestData appendData:imageData];\n    //加入结束符--AaB03x--\n    [myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];\n    //设置HTTPHeader中Content-Type的值\n    NSString *content=[[NSString alloc]initWithFormat:@\"multipart/form-data; boundary=%@\",TWITTERFON_FORM_BOUNDARY];\n    //设置HTTPHeader\n    [request setValue:content forHTTPHeaderField:@\"Content-Type\"];\n    //设置Content-Length\n    [request setValue:[NSString stringWithFormat:@\"%d\", (int)[myRequestData length]] forHTTPHeaderField:@\"Content-Length\"];\n    //设置http body\n    [request setHTTPBody:myRequestData];\n    //http method\n    [request setHTTPMethod:@\"POST\"];\n    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) {\n        if(data.length > 0)\n        {\n            \n        }\n    }];\n}\n```\n\njava中使用httpClient 上传文件\n\npom.xml 中添加 httpclient\n\n```xml\n<dependency>\n  <groupId>commons-httpclient</groupId>\n  <artifactId>commons-httpclient</artifactId>\n  <version>3.1</version>\n</dependency>\n```\n\n```java\n public static String postWithFormData(String url, Map map) {\n        HttpClient client = new HttpClient();\n        PostMethod postMethod = new PostMethod(url);\n        try {\n \t\t\tString imgPath = (String) map.get(\"img\");\n            FilePart imgpart = null;\n            if (imgPath != null && !imgPath.equals(\"\")) {\n               imgpart = new FilePart(\"img\", new File(imgPath));\n            }\n            StringPart stringPart = new StringPart(\"liveness\", \"1\");\n            Part[] parts = {imgpart, stringPart};\n          \n            MultipartRequestEntity multipartRequestEntity = new MultipartRequestEntity(parts, new HttpMethodParams());\n            postMethod.setRequestEntity(multipartRequestEntity);\n            int statusCode = client.executeMethod(postMethod);\n            if (statusCode != 200) {\n                Map map1 = new HashMap();\n                map1.put(\"msg\", \"http 请求错误\");\n                return new JSONObject(map1).toString();\n            }\n            InputStream inputStream = postMethod.getResponseBodyAsStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line = \"\";\n            StringBuilder sb = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            inputStream.close();\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n```\n\n","source":"_posts/各个平台上传图片.md","raw":"---\ntitle: 各个平台上传图片\ndate: 2017-06-13 10:47:00\ntags: \n- 随笔\ncategories:\n- 随笔\n---\n\n开发时常遇到的一些上传图片操作，这里记录一下。包括android，iOS，和java后端，后面还遇到的其他语言或平台时，会进行补充\n\nandroid AsyncHttpClient 上传图片,要使用[android-async-http](https://github.com/loopj/android-async-http)\n\n```java\npublic void uploadImg(String filePath) {\n        AsyncHttpClient asyncHttpclient = new AsyncHttpClient();\n        RequestParams params = new RequestParams();\n        try {\n            params.put(\"liveness\", \"1\");\n            params.put(\"img\", new File(filePath));// 传入照片路径\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        String url = \"\";\n        asyncHttpclient.post(url, params, new AsyncHttpResponseHandler() {\n            @Override\n            public void onSuccess(int statusCode, Header[] headers,\n                                  byte[] responseByte) {\n                String successStr = new String(responseByte);\n                try {\n\n                    JSONObject jObject = new JSONObject(successStr)\n                            .getJSONArray(\"faces\").getJSONObject(0);\n                  //其他省略\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            @Override\n            public void onFailure(int statusCode, Header[] headers,\n                                  byte[] responseBody, Throwable error) {\n                // 上传失败\n            }\n        });\n    }\n```\n\n<!-- more -->\n\niOS NSMutableURLRequest上传图片，NSMutableURLRequest是oc自带库\n\n```objective-c\n- (void) uploadImage:(NSData *)imageData{\n    //字典里面装的是你要上传的内容\n    NSDictionary *parameters = @{@\"liveness\": @\"1\"};\n    //上传的接口\n    NSString* urlstring = @\"http://132.121.1.213:9000/faceid/v1/extract\";\n    //分界线的标识符\n    NSString *TWITTERFON_FORM_BOUNDARY = @\"AaB03x\";\n    //根据url初始化request\n    NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]\n                                                            cachePolicy:NSURLRequestReloadIgnoringLocalCacheData\n                                                        timeoutInterval:10];\n    //分界线 --AaB03x\n    NSString *MPboundary=[[NSString alloc]initWithFormat:@\"--%@\",TWITTERFON_FORM_BOUNDARY];\n    //结束符 AaB03x--\n    NSString *endMPboundary=[[NSString alloc]initWithFormat:@\"%@--\",MPboundary];\n    //\t//要上传的图片\n    //\tUIImage *image=[params objectForKey:@\"pic\"];\n    //得到图片的data\n    //    NSData *data = UIImagePNGRepresentation(self.image);\n    //http body的字符串\n    NSMutableString *body=[[NSMutableString alloc]init];\n    //参数的集合的所有key的集合\n    NSArray *keys= [parameters allKeys];\n    //遍历keys\n    for(int i=0;i<[keys count];i++)\n    {\n        //得到当前key\n        NSString *key=[keys objectAtIndex:i];\n        //如果key不是img，说明value是字符类型，比如name：Boris\n        if(![key isEqualToString:@\"img\"])\n        {\n            //添加分界线，换行\n            [body appendFormat:@\"%@\\r\\n\",MPboundary];\n            //添加字段名称，换2行\n            [body appendFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\",key];\n            //添加字段的值\n            [body appendFormat:@\"%@\\r\\n\",[parameters objectForKey:key]];\n        }\n    }\n    ////添加分界线，换行\n    [body appendFormat:@\"%@\\r\\n\",MPboundary];\n    //声明img字段，文件名为boris.png\n    [body appendFormat:@\"Content-Disposition: form-data; name=\\\"img\\\"; filename=\\\"boris.png\\\"\\r\\n\"];\n    //声明上传文件的格式\n    [body appendFormat:@\"Content-Type: image/png\\r\\n\\r\\n\"];\n    //声明结束符：--AaB03x--\n    NSString *end=[[NSString alloc]initWithFormat:@\"\\r\\n%@\",endMPboundary];\n    //声明myRequestData，用来放入http body\n    NSMutableData *myRequestData=[NSMutableData data];\n    //将body字符串转化为UTF8格式的二进制\n    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];\n    //将image的data加入\n    [myRequestData appendData:imageData];\n    //加入结束符--AaB03x--\n    [myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];\n    //设置HTTPHeader中Content-Type的值\n    NSString *content=[[NSString alloc]initWithFormat:@\"multipart/form-data; boundary=%@\",TWITTERFON_FORM_BOUNDARY];\n    //设置HTTPHeader\n    [request setValue:content forHTTPHeaderField:@\"Content-Type\"];\n    //设置Content-Length\n    [request setValue:[NSString stringWithFormat:@\"%d\", (int)[myRequestData length]] forHTTPHeaderField:@\"Content-Length\"];\n    //设置http body\n    [request setHTTPBody:myRequestData];\n    //http method\n    [request setHTTPMethod:@\"POST\"];\n    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) {\n        if(data.length > 0)\n        {\n            \n        }\n    }];\n}\n```\n\njava中使用httpClient 上传文件\n\npom.xml 中添加 httpclient\n\n```xml\n<dependency>\n  <groupId>commons-httpclient</groupId>\n  <artifactId>commons-httpclient</artifactId>\n  <version>3.1</version>\n</dependency>\n```\n\n```java\n public static String postWithFormData(String url, Map map) {\n        HttpClient client = new HttpClient();\n        PostMethod postMethod = new PostMethod(url);\n        try {\n \t\t\tString imgPath = (String) map.get(\"img\");\n            FilePart imgpart = null;\n            if (imgPath != null && !imgPath.equals(\"\")) {\n               imgpart = new FilePart(\"img\", new File(imgPath));\n            }\n            StringPart stringPart = new StringPart(\"liveness\", \"1\");\n            Part[] parts = {imgpart, stringPart};\n          \n            MultipartRequestEntity multipartRequestEntity = new MultipartRequestEntity(parts, new HttpMethodParams());\n            postMethod.setRequestEntity(multipartRequestEntity);\n            int statusCode = client.executeMethod(postMethod);\n            if (statusCode != 200) {\n                Map map1 = new HashMap();\n                map1.put(\"msg\", \"http 请求错误\");\n                return new JSONObject(map1).toString();\n            }\n            InputStream inputStream = postMethod.getResponseBodyAsStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line = \"\";\n            StringBuilder sb = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            inputStream.close();\n            return sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return \"\";\n        }\n    }\n```\n\n","slug":"各个平台上传图片","published":1,"updated":"2020-02-27T03:05:19.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0p001pmdym10u7c03z","content":"<p>开发时常遇到的一些上传图片操作，这里记录一下。包括android，iOS，和java后端，后面还遇到的其他语言或平台时，会进行补充</p>\n<p>android AsyncHttpClient 上传图片,要使用<a href=\"https://github.com/loopj/android-async-http\">android-async-http</a></p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">uploadImg</span><span class=\"hljs-params\">(String filePath)</span> </span>&#123;\n        AsyncHttpClient asyncHttpclient = <span class=\"hljs-keyword\">new</span> AsyncHttpClient();\n        RequestParams params = <span class=\"hljs-keyword\">new</span> RequestParams();\n        <span class=\"hljs-keyword\">try</span> &#123;\n            params.put(<span class=\"hljs-string\">&quot;liveness&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);\n            params.put(<span class=\"hljs-string\">&quot;img&quot;</span>, <span class=\"hljs-keyword\">new</span> File(filePath));<span class=\"hljs-comment\">// 传入照片路径</span>\n        &#125; <span class=\"hljs-keyword\">catch</span> (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n        String url = <span class=\"hljs-string\">&quot;&quot;</span>;\n        asyncHttpclient.post(url, params, <span class=\"hljs-keyword\">new</span> AsyncHttpResponseHandler() &#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onSuccess</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> statusCode, Header[] headers,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                                  <span class=\"hljs-keyword\">byte</span>[] responseByte)</span> </span>&#123;\n                String successStr = <span class=\"hljs-keyword\">new</span> String(responseByte);\n                <span class=\"hljs-keyword\">try</span> &#123;\n\n                    JSONObject jObject = <span class=\"hljs-keyword\">new</span> JSONObject(successStr)\n                            .getJSONArray(<span class=\"hljs-string\">&quot;faces&quot;</span>).getJSONObject(<span class=\"hljs-number\">0</span>);\n                  <span class=\"hljs-comment\">//其他省略</span>\n                &#125; <span class=\"hljs-keyword\">catch</span> (JSONException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onFailure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> statusCode, Header[] headers,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                                  <span class=\"hljs-keyword\">byte</span>[] responseBody, Throwable error)</span> </span>&#123;\n                <span class=\"hljs-comment\">// 上传失败</span>\n            &#125;\n        &#125;);\n    &#125;</code></pre>\n\n<a id=\"more\"></a>\n\n<p>iOS NSMutableURLRequest上传图片，NSMutableURLRequest是oc自带库</p>\n<pre><code class=\"hljs objective-c\">- (void) uploadImage:(NSData *)imageData&#123;\n    &#x2F;&#x2F;字典里面装的是你要上传的内容\n    NSDictionary *parameters &#x3D; @&#123;@&quot;liveness&quot;: @&quot;1&quot;&#125;;\n    &#x2F;&#x2F;上传的接口\n    NSString* urlstring &#x3D; @&quot;http:&#x2F;&#x2F;132.121.1.213:9000&#x2F;faceid&#x2F;v1&#x2F;extract&quot;;\n    &#x2F;&#x2F;分界线的标识符\n    NSString *TWITTERFON_FORM_BOUNDARY &#x3D; @&quot;AaB03x&quot;;\n    &#x2F;&#x2F;根据url初始化request\n    NSMutableURLRequest * request &#x3D; [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]\n                                                            cachePolicy:NSURLRequestReloadIgnoringLocalCacheData\n                                                        timeoutInterval:10];\n    &#x2F;&#x2F;分界线 --AaB03x\n    NSString *MPboundary&#x3D;[[NSString alloc]initWithFormat:@&quot;--%@&quot;,TWITTERFON_FORM_BOUNDARY];\n    &#x2F;&#x2F;结束符 AaB03x--\n    NSString *endMPboundary&#x3D;[[NSString alloc]initWithFormat:@&quot;%@--&quot;,MPboundary];\n    &#x2F;&#x2F;\t&#x2F;&#x2F;要上传的图片\n    &#x2F;&#x2F;\tUIImage *image&#x3D;[params objectForKey:@&quot;pic&quot;];\n    &#x2F;&#x2F;得到图片的data\n    &#x2F;&#x2F;    NSData *data &#x3D; UIImagePNGRepresentation(self.image);\n    &#x2F;&#x2F;http body的字符串\n    NSMutableString *body&#x3D;[[NSMutableString alloc]init];\n    &#x2F;&#x2F;参数的集合的所有key的集合\n    NSArray *keys&#x3D; [parameters allKeys];\n    &#x2F;&#x2F;遍历keys\n    for(int i&#x3D;0;i&lt;[keys count];i++)\n    &#123;\n        &#x2F;&#x2F;得到当前key\n        NSString *key&#x3D;[keys objectAtIndex:i];\n        &#x2F;&#x2F;如果key不是img，说明value是字符类型，比如name：Boris\n        if(![key isEqualToString:@&quot;img&quot;])\n        &#123;\n            &#x2F;&#x2F;添加分界线，换行\n            [body appendFormat:@&quot;%@\\r\\n&quot;,MPboundary];\n            &#x2F;&#x2F;添加字段名称，换2行\n            [body appendFormat:@&quot;Content-Disposition: form-data; name&#x3D;\\&quot;%@\\&quot;\\r\\n\\r\\n&quot;,key];\n            &#x2F;&#x2F;添加字段的值\n            [body appendFormat:@&quot;%@\\r\\n&quot;,[parameters objectForKey:key]];\n        &#125;\n    &#125;\n    &#x2F;&#x2F;&#x2F;&#x2F;添加分界线，换行\n    [body appendFormat:@&quot;%@\\r\\n&quot;,MPboundary];\n    &#x2F;&#x2F;声明img字段，文件名为boris.png\n    [body appendFormat:@&quot;Content-Disposition: form-data; name&#x3D;\\&quot;img\\&quot;; filename&#x3D;\\&quot;boris.png\\&quot;\\r\\n&quot;];\n    &#x2F;&#x2F;声明上传文件的格式\n    [body appendFormat:@&quot;Content-Type: image&#x2F;png\\r\\n\\r\\n&quot;];\n    &#x2F;&#x2F;声明结束符：--AaB03x--\n    NSString *end&#x3D;[[NSString alloc]initWithFormat:@&quot;\\r\\n%@&quot;,endMPboundary];\n    &#x2F;&#x2F;声明myRequestData，用来放入http body\n    NSMutableData *myRequestData&#x3D;[NSMutableData data];\n    &#x2F;&#x2F;将body字符串转化为UTF8格式的二进制\n    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];\n    &#x2F;&#x2F;将image的data加入\n    [myRequestData appendData:imageData];\n    &#x2F;&#x2F;加入结束符--AaB03x--\n    [myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];\n    &#x2F;&#x2F;设置HTTPHeader中Content-Type的值\n    NSString *content&#x3D;[[NSString alloc]initWithFormat:@&quot;multipart&#x2F;form-data; boundary&#x3D;%@&quot;,TWITTERFON_FORM_BOUNDARY];\n    &#x2F;&#x2F;设置HTTPHeader\n    [request setValue:content forHTTPHeaderField:@&quot;Content-Type&quot;];\n    &#x2F;&#x2F;设置Content-Length\n    [request setValue:[NSString stringWithFormat:@&quot;%d&quot;, (int)[myRequestData length]] forHTTPHeaderField:@&quot;Content-Length&quot;];\n    &#x2F;&#x2F;设置http body\n    [request setHTTPBody:myRequestData];\n    &#x2F;&#x2F;http method\n    [request setHTTPMethod:@&quot;POST&quot;];\n    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) &#123;\n        if(data.length &gt; 0)\n        &#123;\n            \n        &#125;\n    &#125;];\n&#125;</code></pre>\n\n<p>java中使用httpClient 上传文件</p>\n<p>pom.xml 中添加 httpclient</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>commons-httpclient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>commons-httpclient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">postWithFormData</span><span class=\"hljs-params\">(String url, Map map)</span> </span>&#123;\n       HttpClient client = <span class=\"hljs-keyword\">new</span> HttpClient();\n       PostMethod postMethod = <span class=\"hljs-keyword\">new</span> PostMethod(url);\n       <span class=\"hljs-keyword\">try</span> &#123;\n\t\t\tString imgPath = (String) map.get(<span class=\"hljs-string\">&quot;img&quot;</span>);\n           FilePart imgpart = <span class=\"hljs-keyword\">null</span>;\n           <span class=\"hljs-keyword\">if</span> (imgPath != <span class=\"hljs-keyword\">null</span> &amp;&amp; !imgPath.equals(<span class=\"hljs-string\">&quot;&quot;</span>)) &#123;\n              imgpart = <span class=\"hljs-keyword\">new</span> FilePart(<span class=\"hljs-string\">&quot;img&quot;</span>, <span class=\"hljs-keyword\">new</span> File(imgPath));\n           &#125;\n           StringPart stringPart = <span class=\"hljs-keyword\">new</span> StringPart(<span class=\"hljs-string\">&quot;liveness&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);\n           Part[] parts = &#123;imgpart, stringPart&#125;;\n         \n           MultipartRequestEntity multipartRequestEntity = <span class=\"hljs-keyword\">new</span> MultipartRequestEntity(parts, <span class=\"hljs-keyword\">new</span> HttpMethodParams());\n           postMethod.setRequestEntity(multipartRequestEntity);\n           <span class=\"hljs-keyword\">int</span> statusCode = client.executeMethod(postMethod);\n           <span class=\"hljs-keyword\">if</span> (statusCode != <span class=\"hljs-number\">200</span>) &#123;\n               Map map1 = <span class=\"hljs-keyword\">new</span> HashMap();\n               map1.put(<span class=\"hljs-string\">&quot;msg&quot;</span>, <span class=\"hljs-string\">&quot;http 请求错误&quot;</span>);\n               <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JSONObject(map1).toString();\n           &#125;\n           InputStream inputStream = postMethod.getResponseBodyAsStream();\n           BufferedReader reader = <span class=\"hljs-keyword\">new</span> BufferedReader(<span class=\"hljs-keyword\">new</span> InputStreamReader(inputStream));\n           String line = <span class=\"hljs-string\">&quot;&quot;</span>;\n           StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\n           <span class=\"hljs-keyword\">while</span> ((line = reader.readLine()) != <span class=\"hljs-keyword\">null</span>) &#123;\n               sb.append(line + <span class=\"hljs-string\">&quot;\\n&quot;</span>);\n           &#125;\n           inputStream.close();\n           <span class=\"hljs-keyword\">return</span> sb.toString();\n       &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;\n           e.printStackTrace();\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;\n       &#125;\n   &#125;</code></pre>\n\n","site":{"data":{}},"excerpt":"<p>开发时常遇到的一些上传图片操作，这里记录一下。包括android，iOS，和java后端，后面还遇到的其他语言或平台时，会进行补充</p>\n<p>android AsyncHttpClient 上传图片,要使用<a href=\"https://github.com/loopj/android-async-http\">android-async-http</a></p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">uploadImg</span><span class=\"hljs-params\">(String filePath)</span> </span>&#123;\n        AsyncHttpClient asyncHttpclient = <span class=\"hljs-keyword\">new</span> AsyncHttpClient();\n        RequestParams params = <span class=\"hljs-keyword\">new</span> RequestParams();\n        <span class=\"hljs-keyword\">try</span> &#123;\n            params.put(<span class=\"hljs-string\">&quot;liveness&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);\n            params.put(<span class=\"hljs-string\">&quot;img&quot;</span>, <span class=\"hljs-keyword\">new</span> File(filePath));<span class=\"hljs-comment\">// 传入照片路径</span>\n        &#125; <span class=\"hljs-keyword\">catch</span> (FileNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n        String url = <span class=\"hljs-string\">&quot;&quot;</span>;\n        asyncHttpclient.post(url, params, <span class=\"hljs-keyword\">new</span> AsyncHttpResponseHandler() &#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onSuccess</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> statusCode, Header[] headers,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                                  <span class=\"hljs-keyword\">byte</span>[] responseByte)</span> </span>&#123;\n                String successStr = <span class=\"hljs-keyword\">new</span> String(responseByte);\n                <span class=\"hljs-keyword\">try</span> &#123;\n\n                    JSONObject jObject = <span class=\"hljs-keyword\">new</span> JSONObject(successStr)\n                            .getJSONArray(<span class=\"hljs-string\">&quot;faces&quot;</span>).getJSONObject(<span class=\"hljs-number\">0</span>);\n                  <span class=\"hljs-comment\">//其他省略</span>\n                &#125; <span class=\"hljs-keyword\">catch</span> (JSONException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onFailure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> statusCode, Header[] headers,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                                  <span class=\"hljs-keyword\">byte</span>[] responseBody, Throwable error)</span> </span>&#123;\n                <span class=\"hljs-comment\">// 上传失败</span>\n            &#125;\n        &#125;);\n    &#125;</code></pre>","more":"<p>iOS NSMutableURLRequest上传图片，NSMutableURLRequest是oc自带库</p>\n<pre><code class=\"hljs objective-c\">- (void) uploadImage:(NSData *)imageData&#123;\n    &#x2F;&#x2F;字典里面装的是你要上传的内容\n    NSDictionary *parameters &#x3D; @&#123;@&quot;liveness&quot;: @&quot;1&quot;&#125;;\n    &#x2F;&#x2F;上传的接口\n    NSString* urlstring &#x3D; @&quot;http:&#x2F;&#x2F;132.121.1.213:9000&#x2F;faceid&#x2F;v1&#x2F;extract&quot;;\n    &#x2F;&#x2F;分界线的标识符\n    NSString *TWITTERFON_FORM_BOUNDARY &#x3D; @&quot;AaB03x&quot;;\n    &#x2F;&#x2F;根据url初始化request\n    NSMutableURLRequest * request &#x3D; [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlstring]\n                                                            cachePolicy:NSURLRequestReloadIgnoringLocalCacheData\n                                                        timeoutInterval:10];\n    &#x2F;&#x2F;分界线 --AaB03x\n    NSString *MPboundary&#x3D;[[NSString alloc]initWithFormat:@&quot;--%@&quot;,TWITTERFON_FORM_BOUNDARY];\n    &#x2F;&#x2F;结束符 AaB03x--\n    NSString *endMPboundary&#x3D;[[NSString alloc]initWithFormat:@&quot;%@--&quot;,MPboundary];\n    &#x2F;&#x2F;\t&#x2F;&#x2F;要上传的图片\n    &#x2F;&#x2F;\tUIImage *image&#x3D;[params objectForKey:@&quot;pic&quot;];\n    &#x2F;&#x2F;得到图片的data\n    &#x2F;&#x2F;    NSData *data &#x3D; UIImagePNGRepresentation(self.image);\n    &#x2F;&#x2F;http body的字符串\n    NSMutableString *body&#x3D;[[NSMutableString alloc]init];\n    &#x2F;&#x2F;参数的集合的所有key的集合\n    NSArray *keys&#x3D; [parameters allKeys];\n    &#x2F;&#x2F;遍历keys\n    for(int i&#x3D;0;i&lt;[keys count];i++)\n    &#123;\n        &#x2F;&#x2F;得到当前key\n        NSString *key&#x3D;[keys objectAtIndex:i];\n        &#x2F;&#x2F;如果key不是img，说明value是字符类型，比如name：Boris\n        if(![key isEqualToString:@&quot;img&quot;])\n        &#123;\n            &#x2F;&#x2F;添加分界线，换行\n            [body appendFormat:@&quot;%@\\r\\n&quot;,MPboundary];\n            &#x2F;&#x2F;添加字段名称，换2行\n            [body appendFormat:@&quot;Content-Disposition: form-data; name&#x3D;\\&quot;%@\\&quot;\\r\\n\\r\\n&quot;,key];\n            &#x2F;&#x2F;添加字段的值\n            [body appendFormat:@&quot;%@\\r\\n&quot;,[parameters objectForKey:key]];\n        &#125;\n    &#125;\n    &#x2F;&#x2F;&#x2F;&#x2F;添加分界线，换行\n    [body appendFormat:@&quot;%@\\r\\n&quot;,MPboundary];\n    &#x2F;&#x2F;声明img字段，文件名为boris.png\n    [body appendFormat:@&quot;Content-Disposition: form-data; name&#x3D;\\&quot;img\\&quot;; filename&#x3D;\\&quot;boris.png\\&quot;\\r\\n&quot;];\n    &#x2F;&#x2F;声明上传文件的格式\n    [body appendFormat:@&quot;Content-Type: image&#x2F;png\\r\\n\\r\\n&quot;];\n    &#x2F;&#x2F;声明结束符：--AaB03x--\n    NSString *end&#x3D;[[NSString alloc]initWithFormat:@&quot;\\r\\n%@&quot;,endMPboundary];\n    &#x2F;&#x2F;声明myRequestData，用来放入http body\n    NSMutableData *myRequestData&#x3D;[NSMutableData data];\n    &#x2F;&#x2F;将body字符串转化为UTF8格式的二进制\n    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];\n    &#x2F;&#x2F;将image的data加入\n    [myRequestData appendData:imageData];\n    &#x2F;&#x2F;加入结束符--AaB03x--\n    [myRequestData appendData:[end dataUsingEncoding:NSUTF8StringEncoding]];\n    &#x2F;&#x2F;设置HTTPHeader中Content-Type的值\n    NSString *content&#x3D;[[NSString alloc]initWithFormat:@&quot;multipart&#x2F;form-data; boundary&#x3D;%@&quot;,TWITTERFON_FORM_BOUNDARY];\n    &#x2F;&#x2F;设置HTTPHeader\n    [request setValue:content forHTTPHeaderField:@&quot;Content-Type&quot;];\n    &#x2F;&#x2F;设置Content-Length\n    [request setValue:[NSString stringWithFormat:@&quot;%d&quot;, (int)[myRequestData length]] forHTTPHeaderField:@&quot;Content-Length&quot;];\n    &#x2F;&#x2F;设置http body\n    [request setHTTPBody:myRequestData];\n    &#x2F;&#x2F;http method\n    [request setHTTPMethod:@&quot;POST&quot;];\n    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue currentQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) &#123;\n        if(data.length &gt; 0)\n        &#123;\n            \n        &#125;\n    &#125;];\n&#125;</code></pre>\n\n<p>java中使用httpClient 上传文件</p>\n<p>pom.xml 中添加 httpclient</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>commons-httpclient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>commons-httpclient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>3.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">postWithFormData</span><span class=\"hljs-params\">(String url, Map map)</span> </span>&#123;\n       HttpClient client = <span class=\"hljs-keyword\">new</span> HttpClient();\n       PostMethod postMethod = <span class=\"hljs-keyword\">new</span> PostMethod(url);\n       <span class=\"hljs-keyword\">try</span> &#123;\n\t\t\tString imgPath = (String) map.get(<span class=\"hljs-string\">&quot;img&quot;</span>);\n           FilePart imgpart = <span class=\"hljs-keyword\">null</span>;\n           <span class=\"hljs-keyword\">if</span> (imgPath != <span class=\"hljs-keyword\">null</span> &amp;&amp; !imgPath.equals(<span class=\"hljs-string\">&quot;&quot;</span>)) &#123;\n              imgpart = <span class=\"hljs-keyword\">new</span> FilePart(<span class=\"hljs-string\">&quot;img&quot;</span>, <span class=\"hljs-keyword\">new</span> File(imgPath));\n           &#125;\n           StringPart stringPart = <span class=\"hljs-keyword\">new</span> StringPart(<span class=\"hljs-string\">&quot;liveness&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);\n           Part[] parts = &#123;imgpart, stringPart&#125;;\n         \n           MultipartRequestEntity multipartRequestEntity = <span class=\"hljs-keyword\">new</span> MultipartRequestEntity(parts, <span class=\"hljs-keyword\">new</span> HttpMethodParams());\n           postMethod.setRequestEntity(multipartRequestEntity);\n           <span class=\"hljs-keyword\">int</span> statusCode = client.executeMethod(postMethod);\n           <span class=\"hljs-keyword\">if</span> (statusCode != <span class=\"hljs-number\">200</span>) &#123;\n               Map map1 = <span class=\"hljs-keyword\">new</span> HashMap();\n               map1.put(<span class=\"hljs-string\">&quot;msg&quot;</span>, <span class=\"hljs-string\">&quot;http 请求错误&quot;</span>);\n               <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JSONObject(map1).toString();\n           &#125;\n           InputStream inputStream = postMethod.getResponseBodyAsStream();\n           BufferedReader reader = <span class=\"hljs-keyword\">new</span> BufferedReader(<span class=\"hljs-keyword\">new</span> InputStreamReader(inputStream));\n           String line = <span class=\"hljs-string\">&quot;&quot;</span>;\n           StringBuilder sb = <span class=\"hljs-keyword\">new</span> StringBuilder();\n           <span class=\"hljs-keyword\">while</span> ((line = reader.readLine()) != <span class=\"hljs-keyword\">null</span>) &#123;\n               sb.append(line + <span class=\"hljs-string\">&quot;\\n&quot;</span>);\n           &#125;\n           inputStream.close();\n           <span class=\"hljs-keyword\">return</span> sb.toString();\n       &#125; <span class=\"hljs-keyword\">catch</span> (IOException e) &#123;\n           e.printStackTrace();\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;\n       &#125;\n   &#125;</code></pre>"},{"title":"私有化的坑","date":"2017-07-20T04:53:30.000Z","_content":"\n​\t最近遇到的坑确实是有点多了，这里记录一下。事情开始是这样的，想将公有云的一套工程进行私有化，因为公有云的是自己的系统，不用考虑太多的因素，想统一环境还是比较容易的，只要能够在一套环境成功运行，其他的直接copy就行。但是私有云就不行了，各个客户使用的环境都有一定的差异。私有化就是将使这个工程能够在不同的环境运行。\n\n​\t公有云的这套工程是python工程，python工程使用了一些so库。而这些so库又依赖系统的`/lib64/libc.so.6`，然后工程就报`version \"GLIBC_2.14\" not found`,原因是系统libc不支持GLIBC_2.14这个版本，这时我就有两个解决方案，一个是我将系统的libc.so.6 升级，还有一个我弄一个统一的环境。很显然方案一不是私有云，我总不能让我所有的客户去升级libc.so.6吧，着很显然不符合私有化。\n\n​\t在尝试方案一的过程中，我发现原来把一个Linux系统弄崩其实很简单，崩了之后各种无法使用，你只能去重装系统。你只要执行`mv /lib64/libc.so.6 /lib64/libc.so.6.bak`,你会发现接下来无论你输入什么命令都不好使了。这是因为`/lib64/libc.so.6 `是最底层的库，系统上的程序基本是依赖这个库的。所以/lib64下的so库不要轻易去动。\n\n<!-- more -->\n\n​\t于是我去尝试了第二种方案，弄一个统一的环境，那要怎么弄呢？so 库是依赖系统的libc.so.6，我要怎么让我的这个工程的so不去依赖/lib64 下的so而是去依赖我指定的一个路径的so呢？\n\n1.   我先用docker搭建一个可以运行工程的环境，使用docker弄了一个ubuntu的系统。以下是一些使用的命令\n\n     ```sh\n     docker pull ubuntu #获取ubuntu的镜像\n     docker run -it --name kas -v /Users/wushengping/dockerUbuntu:/go -p 9001:9001 ubuntu bash #第一次以交互模式启动ubuntu，并命名为kas，同时将ubuntu系统端口9001映射到本机上\n     docker ps -a #查看docker 下所有container状态\n     docker start kas # 启动kas,kas是ubuntu系统镜像，只是启动并为进入交互模式\n     docker exec -it kas bash #进入ubuntu 交互模式\n     ```\n\n2. 在ubuntu上可以正常运行之后，通过ldd 的命令将so依赖的系统相关的so 导出来,同时将/lib64/ld-linux-x86-64.so.2 也导出来\n\n     ```sh\n     cp `ldd xxxx.so | awk '{print $3}' | grep '^[^(]'` ~/libs\n     cp /lib64/ld-linux-x86-64.so.2  ~\n     ```\n\n3. 将刚才的导出的库，传到redhats6.4系统上，然后指定工程运行所需的依赖库。\n\n     ```sh\n     ld-linux-x86-64.so.2 --library-path ./libs python xxxx #xxx表示工程的入口文件\n     ```\n\n     这时你会发现这个工程起都起不来了，并报了core dump 的错误，这时因为指定路径之后，只能通过二进制的方式去启动这个工程。而python 只是一个命令，并不是二进制的文件，无法执行。这里需要注意的是ld-linux-x86-64.so.2 只能是刚才从ubuntu导出来的文件，否则也会报core dump\n\n4. 在第三步我们没有成功运行起来，是因为我们还缺少将python工程编译成一个二进制可执行的文件。**pyInstaller** 这个工具可以将python工程打成一个二进制的包，同时会将工程依赖的库也打进这个二进制。\n\n     ```sh\n     pyinstall -f entry.py #entry.py 是你整个工程的入口文件\n     ```\n\n     执行完成之后会生成一个dist目录，目录下有整个工程的二进制文件\n\n5. 整个私有化的流程算是完成了交付给客户的时候包括一下文件\n\n     - ld-linux-x86-64.so.2\n     - libs \n     - 可执行的二进制文件\n\n     当然实际交付的工程中有更多的文件，看工程是怎么规划的。这里不过多解释\n\n\n\n本篇文章主要是记录私有化工程的一些思路，过程中遇到的很多坑。很多细节这里也不去体现了。大家自行领会。其中关于的docker的使用和pyinstaller 的安装使用，不是本篇文章的重点。可以自行谷歌","source":"_posts/私有化的坑.md","raw":"---\ntitle: 私有化的坑\ndate: 2017-07-20 12:53:30\ntags: \n- Linux\ncategories:\n- Linux\n---\n\n​\t最近遇到的坑确实是有点多了，这里记录一下。事情开始是这样的，想将公有云的一套工程进行私有化，因为公有云的是自己的系统，不用考虑太多的因素，想统一环境还是比较容易的，只要能够在一套环境成功运行，其他的直接copy就行。但是私有云就不行了，各个客户使用的环境都有一定的差异。私有化就是将使这个工程能够在不同的环境运行。\n\n​\t公有云的这套工程是python工程，python工程使用了一些so库。而这些so库又依赖系统的`/lib64/libc.so.6`，然后工程就报`version \"GLIBC_2.14\" not found`,原因是系统libc不支持GLIBC_2.14这个版本，这时我就有两个解决方案，一个是我将系统的libc.so.6 升级，还有一个我弄一个统一的环境。很显然方案一不是私有云，我总不能让我所有的客户去升级libc.so.6吧，着很显然不符合私有化。\n\n​\t在尝试方案一的过程中，我发现原来把一个Linux系统弄崩其实很简单，崩了之后各种无法使用，你只能去重装系统。你只要执行`mv /lib64/libc.so.6 /lib64/libc.so.6.bak`,你会发现接下来无论你输入什么命令都不好使了。这是因为`/lib64/libc.so.6 `是最底层的库，系统上的程序基本是依赖这个库的。所以/lib64下的so库不要轻易去动。\n\n<!-- more -->\n\n​\t于是我去尝试了第二种方案，弄一个统一的环境，那要怎么弄呢？so 库是依赖系统的libc.so.6，我要怎么让我的这个工程的so不去依赖/lib64 下的so而是去依赖我指定的一个路径的so呢？\n\n1.   我先用docker搭建一个可以运行工程的环境，使用docker弄了一个ubuntu的系统。以下是一些使用的命令\n\n     ```sh\n     docker pull ubuntu #获取ubuntu的镜像\n     docker run -it --name kas -v /Users/wushengping/dockerUbuntu:/go -p 9001:9001 ubuntu bash #第一次以交互模式启动ubuntu，并命名为kas，同时将ubuntu系统端口9001映射到本机上\n     docker ps -a #查看docker 下所有container状态\n     docker start kas # 启动kas,kas是ubuntu系统镜像，只是启动并为进入交互模式\n     docker exec -it kas bash #进入ubuntu 交互模式\n     ```\n\n2. 在ubuntu上可以正常运行之后，通过ldd 的命令将so依赖的系统相关的so 导出来,同时将/lib64/ld-linux-x86-64.so.2 也导出来\n\n     ```sh\n     cp `ldd xxxx.so | awk '{print $3}' | grep '^[^(]'` ~/libs\n     cp /lib64/ld-linux-x86-64.so.2  ~\n     ```\n\n3. 将刚才的导出的库，传到redhats6.4系统上，然后指定工程运行所需的依赖库。\n\n     ```sh\n     ld-linux-x86-64.so.2 --library-path ./libs python xxxx #xxx表示工程的入口文件\n     ```\n\n     这时你会发现这个工程起都起不来了，并报了core dump 的错误，这时因为指定路径之后，只能通过二进制的方式去启动这个工程。而python 只是一个命令，并不是二进制的文件，无法执行。这里需要注意的是ld-linux-x86-64.so.2 只能是刚才从ubuntu导出来的文件，否则也会报core dump\n\n4. 在第三步我们没有成功运行起来，是因为我们还缺少将python工程编译成一个二进制可执行的文件。**pyInstaller** 这个工具可以将python工程打成一个二进制的包，同时会将工程依赖的库也打进这个二进制。\n\n     ```sh\n     pyinstall -f entry.py #entry.py 是你整个工程的入口文件\n     ```\n\n     执行完成之后会生成一个dist目录，目录下有整个工程的二进制文件\n\n5. 整个私有化的流程算是完成了交付给客户的时候包括一下文件\n\n     - ld-linux-x86-64.so.2\n     - libs \n     - 可执行的二进制文件\n\n     当然实际交付的工程中有更多的文件，看工程是怎么规划的。这里不过多解释\n\n\n\n本篇文章主要是记录私有化工程的一些思路，过程中遇到的很多坑。很多细节这里也不去体现了。大家自行领会。其中关于的docker的使用和pyinstaller 的安装使用，不是本篇文章的重点。可以自行谷歌","slug":"私有化的坑","published":1,"updated":"2020-02-27T03:32:55.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0q001umdymh8f31jh3","content":"<p>​    最近遇到的坑确实是有点多了，这里记录一下。事情开始是这样的，想将公有云的一套工程进行私有化，因为公有云的是自己的系统，不用考虑太多的因素，想统一环境还是比较容易的，只要能够在一套环境成功运行，其他的直接copy就行。但是私有云就不行了，各个客户使用的环境都有一定的差异。私有化就是将使这个工程能够在不同的环境运行。</p>\n<p>​    公有云的这套工程是python工程，python工程使用了一些so库。而这些so库又依赖系统的<code>/lib64/libc.so.6</code>，然后工程就报<code>version &quot;GLIBC_2.14&quot; not found</code>,原因是系统libc不支持GLIBC_2.14这个版本，这时我就有两个解决方案，一个是我将系统的libc.so.6 升级，还有一个我弄一个统一的环境。很显然方案一不是私有云，我总不能让我所有的客户去升级libc.so.6吧，着很显然不符合私有化。</p>\n<p>​    在尝试方案一的过程中，我发现原来把一个Linux系统弄崩其实很简单，崩了之后各种无法使用，你只能去重装系统。你只要执行<code>mv /lib64/libc.so.6 /lib64/libc.so.6.bak</code>,你会发现接下来无论你输入什么命令都不好使了。这是因为<code>/lib64/libc.so.6 </code>是最底层的库，系统上的程序基本是依赖这个库的。所以/lib64下的so库不要轻易去动。</p>\n<a id=\"more\"></a>\n\n<p>​    于是我去尝试了第二种方案，弄一个统一的环境，那要怎么弄呢？so 库是依赖系统的libc.so.6，我要怎么让我的这个工程的so不去依赖/lib64 下的so而是去依赖我指定的一个路径的so呢？</p>\n<ol>\n<li><p>我先用docker搭建一个可以运行工程的环境，使用docker弄了一个ubuntu的系统。以下是一些使用的命令</p>\n<pre><code class=\"hljs sh\">docker pull ubuntu <span class=\"hljs-comment\">#获取ubuntu的镜像</span>\ndocker run -it --name kas -v /Users/wushengping/dockerUbuntu:/go -p 9001:9001 ubuntu bash <span class=\"hljs-comment\">#第一次以交互模式启动ubuntu，并命名为kas，同时将ubuntu系统端口9001映射到本机上</span>\ndocker ps -a <span class=\"hljs-comment\">#查看docker 下所有container状态</span>\ndocker start kas <span class=\"hljs-comment\"># 启动kas,kas是ubuntu系统镜像，只是启动并为进入交互模式</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it kas bash <span class=\"hljs-comment\">#进入ubuntu 交互模式</span></code></pre>\n</li>\n<li><p>在ubuntu上可以正常运行之后，通过ldd 的命令将so依赖的系统相关的so 导出来,同时将/lib64/ld-linux-x86-64.so.2 也导出来</p>\n  <pre><code class=\"hljs sh\">cp `ldd xxxx.so | awk <span class=\"hljs-string\">&#x27;&#123;print $3&#125;&#x27;</span> | grep <span class=\"hljs-string\">&#x27;^[^(]&#x27;</span>` ~/libs\ncp /lib64/ld-linux-x86-64.so.2  ~</code></pre>\n</li>\n<li><p>将刚才的导出的库，传到redhats6.4系统上，然后指定工程运行所需的依赖库。</p>\n  <pre><code class=\"hljs sh\">ld-linux-x86-64.so.2 --library-path ./libs python xxxx <span class=\"hljs-comment\">#xxx表示工程的入口文件</span></code></pre>\n\n<p>  这时你会发现这个工程起都起不来了，并报了core dump 的错误，这时因为指定路径之后，只能通过二进制的方式去启动这个工程。而python 只是一个命令，并不是二进制的文件，无法执行。这里需要注意的是ld-linux-x86-64.so.2 只能是刚才从ubuntu导出来的文件，否则也会报core dump</p>\n</li>\n<li><p>在第三步我们没有成功运行起来，是因为我们还缺少将python工程编译成一个二进制可执行的文件。<strong>pyInstaller</strong> 这个工具可以将python工程打成一个二进制的包，同时会将工程依赖的库也打进这个二进制。</p>\n  <pre><code class=\"hljs sh\">pyinstall -f entry.py <span class=\"hljs-comment\">#entry.py 是你整个工程的入口文件</span></code></pre>\n\n<p>  执行完成之后会生成一个dist目录，目录下有整个工程的二进制文件</p>\n</li>\n<li><p>整个私有化的流程算是完成了交付给客户的时候包括一下文件</p>\n<ul>\n<li><p>ld-linux-x86-64.so.2</p>\n</li>\n<li><p>libs </p>\n</li>\n<li><p>可执行的二进制文件</p>\n<p>当然实际交付的工程中有更多的文件，看工程是怎么规划的。这里不过多解释</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>本篇文章主要是记录私有化工程的一些思路，过程中遇到的很多坑。很多细节这里也不去体现了。大家自行领会。其中关于的docker的使用和pyinstaller 的安装使用，不是本篇文章的重点。可以自行谷歌</p>\n","site":{"data":{}},"excerpt":"<p>​    最近遇到的坑确实是有点多了，这里记录一下。事情开始是这样的，想将公有云的一套工程进行私有化，因为公有云的是自己的系统，不用考虑太多的因素，想统一环境还是比较容易的，只要能够在一套环境成功运行，其他的直接copy就行。但是私有云就不行了，各个客户使用的环境都有一定的差异。私有化就是将使这个工程能够在不同的环境运行。</p>\n<p>​    公有云的这套工程是python工程，python工程使用了一些so库。而这些so库又依赖系统的<code>/lib64/libc.so.6</code>，然后工程就报<code>version &quot;GLIBC_2.14&quot; not found</code>,原因是系统libc不支持GLIBC_2.14这个版本，这时我就有两个解决方案，一个是我将系统的libc.so.6 升级，还有一个我弄一个统一的环境。很显然方案一不是私有云，我总不能让我所有的客户去升级libc.so.6吧，着很显然不符合私有化。</p>\n<p>​    在尝试方案一的过程中，我发现原来把一个Linux系统弄崩其实很简单，崩了之后各种无法使用，你只能去重装系统。你只要执行<code>mv /lib64/libc.so.6 /lib64/libc.so.6.bak</code>,你会发现接下来无论你输入什么命令都不好使了。这是因为<code>/lib64/libc.so.6 </code>是最底层的库，系统上的程序基本是依赖这个库的。所以/lib64下的so库不要轻易去动。</p>","more":"<p>​    于是我去尝试了第二种方案，弄一个统一的环境，那要怎么弄呢？so 库是依赖系统的libc.so.6，我要怎么让我的这个工程的so不去依赖/lib64 下的so而是去依赖我指定的一个路径的so呢？</p>\n<ol>\n<li><p>我先用docker搭建一个可以运行工程的环境，使用docker弄了一个ubuntu的系统。以下是一些使用的命令</p>\n<pre><code class=\"hljs sh\">docker pull ubuntu <span class=\"hljs-comment\">#获取ubuntu的镜像</span>\ndocker run -it --name kas -v /Users/wushengping/dockerUbuntu:/go -p 9001:9001 ubuntu bash <span class=\"hljs-comment\">#第一次以交互模式启动ubuntu，并命名为kas，同时将ubuntu系统端口9001映射到本机上</span>\ndocker ps -a <span class=\"hljs-comment\">#查看docker 下所有container状态</span>\ndocker start kas <span class=\"hljs-comment\"># 启动kas,kas是ubuntu系统镜像，只是启动并为进入交互模式</span>\ndocker <span class=\"hljs-built_in\">exec</span> -it kas bash <span class=\"hljs-comment\">#进入ubuntu 交互模式</span></code></pre>\n</li>\n<li><p>在ubuntu上可以正常运行之后，通过ldd 的命令将so依赖的系统相关的so 导出来,同时将/lib64/ld-linux-x86-64.so.2 也导出来</p>\n  <pre><code class=\"hljs sh\">cp `ldd xxxx.so | awk <span class=\"hljs-string\">&#x27;&#123;print $3&#125;&#x27;</span> | grep <span class=\"hljs-string\">&#x27;^[^(]&#x27;</span>` ~/libs\ncp /lib64/ld-linux-x86-64.so.2  ~</code></pre>\n</li>\n<li><p>将刚才的导出的库，传到redhats6.4系统上，然后指定工程运行所需的依赖库。</p>\n  <pre><code class=\"hljs sh\">ld-linux-x86-64.so.2 --library-path ./libs python xxxx <span class=\"hljs-comment\">#xxx表示工程的入口文件</span></code></pre>\n\n<p>  这时你会发现这个工程起都起不来了，并报了core dump 的错误，这时因为指定路径之后，只能通过二进制的方式去启动这个工程。而python 只是一个命令，并不是二进制的文件，无法执行。这里需要注意的是ld-linux-x86-64.so.2 只能是刚才从ubuntu导出来的文件，否则也会报core dump</p>\n</li>\n<li><p>在第三步我们没有成功运行起来，是因为我们还缺少将python工程编译成一个二进制可执行的文件。<strong>pyInstaller</strong> 这个工具可以将python工程打成一个二进制的包，同时会将工程依赖的库也打进这个二进制。</p>\n  <pre><code class=\"hljs sh\">pyinstall -f entry.py <span class=\"hljs-comment\">#entry.py 是你整个工程的入口文件</span></code></pre>\n\n<p>  执行完成之后会生成一个dist目录，目录下有整个工程的二进制文件</p>\n</li>\n<li><p>整个私有化的流程算是完成了交付给客户的时候包括一下文件</p>\n<ul>\n<li><p>ld-linux-x86-64.so.2</p>\n</li>\n<li><p>libs </p>\n</li>\n<li><p>可执行的二进制文件</p>\n<p>当然实际交付的工程中有更多的文件，看工程是怎么规划的。这里不过多解释</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>本篇文章主要是记录私有化工程的一些思路，过程中遇到的很多坑。很多细节这里也不去体现了。大家自行领会。其中关于的docker的使用和pyinstaller 的安装使用，不是本篇文章的重点。可以自行谷歌</p>"},{"title":"内网端口映射到外网","date":"2017-08-21T07:47:00.000Z","_content":"\n​\t最近有一个客户想要看我们的产品，想体验一下我们的产品，需要我们提供一个小程序，于是就弄了一个小程序给客户，小程序还好说我们有现成的东西，直接给客户，麻烦的是小程序背后的服务。由于我们背后的人脸识别服务都是私有化部署的，而且这个客户只是想临时体验一下，所以将整个服务部署到公有云完全是没有必要的。但是我们内部有已经部署好的，又不想在公有云上去搭建一套。于是去咨询了下同事，是不是有什么工具可以把内网的端口暴露到公网上。然后同事就介绍了一个工具`autossh`\n\n​\t好了背景介绍完了，接下来就是去实践了。\n\n现有两台服务器：服务器A是阿里云上的一台机器，服务器B是公司内部的一台虚拟机，这个台虚拟机必须是可以连接公网的。\n\n<!-- more -->\n\n1. 登录到服务B上\n\n   ```sh\n   #1.将autossh下载到服务器B上\n   wget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n   #2.解压\n   tar xzvf autossh-1.4e.tgz\n   #3. 编译安装\n    cd autossh-1.4e\n    ./configure\n    make\n    make install\n   #4. 生成服务器B的公钥，一会儿需要把服务器B的公钥添加到服务器A上\n   ssh-keygen\n   #5. 执行ssh-keygen 一路回车即可，这个会在~/.ssh目录下生成id_rsa.pub,编辑这个文件，把内容复制到一个文本文件\n   vim ~/.ssh/id_rsa.pub\n   ```\n\n\n2. 登录到服务器A上\n\n   ```sh\n   #1.在~/.ssh目录下创建authorized_keys文件\n   touch ~/.ssh/authorized_keys\n   #2.编辑这个文件并将刚才从服务器A上复制的公钥粘贴到这个文件上，保存退出即可\n   vim ~/.ssh/authorized_keys\n   ```\n\n3. 登录到服务器B上\n\n   ```sh\n   #1.制定需要暴露到公网端口\n   autossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa 服务器A的用户名@服务器A的IP地址\n   ```\n\n   参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连\n\n   后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口\n\n到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。","source":"_posts/内网端口映射到外网.md","raw":"---\ntitle: 内网端口映射到外网\ndate: 2017-08-21 15:47:00\ntags:\n- Linux\ncategories:\n- Linux\n---\n\n​\t最近有一个客户想要看我们的产品，想体验一下我们的产品，需要我们提供一个小程序，于是就弄了一个小程序给客户，小程序还好说我们有现成的东西，直接给客户，麻烦的是小程序背后的服务。由于我们背后的人脸识别服务都是私有化部署的，而且这个客户只是想临时体验一下，所以将整个服务部署到公有云完全是没有必要的。但是我们内部有已经部署好的，又不想在公有云上去搭建一套。于是去咨询了下同事，是不是有什么工具可以把内网的端口暴露到公网上。然后同事就介绍了一个工具`autossh`\n\n​\t好了背景介绍完了，接下来就是去实践了。\n\n现有两台服务器：服务器A是阿里云上的一台机器，服务器B是公司内部的一台虚拟机，这个台虚拟机必须是可以连接公网的。\n\n<!-- more -->\n\n1. 登录到服务B上\n\n   ```sh\n   #1.将autossh下载到服务器B上\n   wget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n   #2.解压\n   tar xzvf autossh-1.4e.tgz\n   #3. 编译安装\n    cd autossh-1.4e\n    ./configure\n    make\n    make install\n   #4. 生成服务器B的公钥，一会儿需要把服务器B的公钥添加到服务器A上\n   ssh-keygen\n   #5. 执行ssh-keygen 一路回车即可，这个会在~/.ssh目录下生成id_rsa.pub,编辑这个文件，把内容复制到一个文本文件\n   vim ~/.ssh/id_rsa.pub\n   ```\n\n\n2. 登录到服务器A上\n\n   ```sh\n   #1.在~/.ssh目录下创建authorized_keys文件\n   touch ~/.ssh/authorized_keys\n   #2.编辑这个文件并将刚才从服务器A上复制的公钥粘贴到这个文件上，保存退出即可\n   vim ~/.ssh/authorized_keys\n   ```\n\n3. 登录到服务器B上\n\n   ```sh\n   #1.制定需要暴露到公网端口\n   autossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa 服务器A的用户名@服务器A的IP地址\n   ```\n\n   参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连\n\n   后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口\n\n到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。","slug":"内网端口映射到外网","published":1,"updated":"2020-02-27T03:31:07.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0r001xmdym652oa2m1","content":"<p>​    最近有一个客户想要看我们的产品，想体验一下我们的产品，需要我们提供一个小程序，于是就弄了一个小程序给客户，小程序还好说我们有现成的东西，直接给客户，麻烦的是小程序背后的服务。由于我们背后的人脸识别服务都是私有化部署的，而且这个客户只是想临时体验一下，所以将整个服务部署到公有云完全是没有必要的。但是我们内部有已经部署好的，又不想在公有云上去搭建一套。于是去咨询了下同事，是不是有什么工具可以把内网的端口暴露到公网上。然后同事就介绍了一个工具<code>autossh</code></p>\n<p>​    好了背景介绍完了，接下来就是去实践了。</p>\n<p>现有两台服务器：服务器A是阿里云上的一台机器，服务器B是公司内部的一台虚拟机，这个台虚拟机必须是可以连接公网的。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><p>登录到服务B上</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#1.将autossh下载到服务器B上</span>\nwget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n<span class=\"hljs-comment\">#2.解压</span>\ntar xzvf autossh-1.4e.tgz\n<span class=\"hljs-comment\">#3. 编译安装</span>\n <span class=\"hljs-built_in\">cd</span> autossh-1.4e\n ./configure\n make\n make install\n<span class=\"hljs-comment\">#4. 生成服务器B的公钥，一会儿需要把服务器B的公钥添加到服务器A上</span>\nssh-keygen\n<span class=\"hljs-comment\">#5. 执行ssh-keygen 一路回车即可，这个会在~/.ssh目录下生成id_rsa.pub,编辑这个文件，把内容复制到一个文本文件</span>\nvim ~/.ssh/id_rsa.pub</code></pre>\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>登录到服务器A上</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#1.在~/.ssh目录下创建authorized_keys文件</span>\ntouch ~/.ssh/authorized_keys\n<span class=\"hljs-comment\">#2.编辑这个文件并将刚才从服务器A上复制的公钥粘贴到这个文件上，保存退出即可</span>\nvim ~/.ssh/authorized_keys</code></pre>\n</li>\n<li><p>登录到服务器B上</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#1.制定需要暴露到公网端口</span>\nautossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa 服务器A的用户名@服务器A的IP地址</code></pre>\n\n<p>参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连</p>\n<p>后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口</p>\n</li>\n</ol>\n<p>到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。</p>\n","site":{"data":{}},"excerpt":"<p>​    最近有一个客户想要看我们的产品，想体验一下我们的产品，需要我们提供一个小程序，于是就弄了一个小程序给客户，小程序还好说我们有现成的东西，直接给客户，麻烦的是小程序背后的服务。由于我们背后的人脸识别服务都是私有化部署的，而且这个客户只是想临时体验一下，所以将整个服务部署到公有云完全是没有必要的。但是我们内部有已经部署好的，又不想在公有云上去搭建一套。于是去咨询了下同事，是不是有什么工具可以把内网的端口暴露到公网上。然后同事就介绍了一个工具<code>autossh</code></p>\n<p>​    好了背景介绍完了，接下来就是去实践了。</p>\n<p>现有两台服务器：服务器A是阿里云上的一台机器，服务器B是公司内部的一台虚拟机，这个台虚拟机必须是可以连接公网的。</p>","more":"<ol>\n<li><p>登录到服务B上</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#1.将autossh下载到服务器B上</span>\nwget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n<span class=\"hljs-comment\">#2.解压</span>\ntar xzvf autossh-1.4e.tgz\n<span class=\"hljs-comment\">#3. 编译安装</span>\n <span class=\"hljs-built_in\">cd</span> autossh-1.4e\n ./configure\n make\n make install\n<span class=\"hljs-comment\">#4. 生成服务器B的公钥，一会儿需要把服务器B的公钥添加到服务器A上</span>\nssh-keygen\n<span class=\"hljs-comment\">#5. 执行ssh-keygen 一路回车即可，这个会在~/.ssh目录下生成id_rsa.pub,编辑这个文件，把内容复制到一个文本文件</span>\nvim ~/.ssh/id_rsa.pub</code></pre>\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>登录到服务器A上</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#1.在~/.ssh目录下创建authorized_keys文件</span>\ntouch ~/.ssh/authorized_keys\n<span class=\"hljs-comment\">#2.编辑这个文件并将刚才从服务器A上复制的公钥粘贴到这个文件上，保存退出即可</span>\nvim ~/.ssh/authorized_keys</code></pre>\n</li>\n<li><p>登录到服务器B上</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#1.制定需要暴露到公网端口</span>\nautossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa 服务器A的用户名@服务器A的IP地址</code></pre>\n\n<p>参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连</p>\n<p>后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口</p>\n</li>\n</ol>\n<p>到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。</p>"},{"title":"身份证识别跑批脚本","date":"2018-03-21T04:53:30.000Z","index_img":["/images/shell/idcard_front.jpg"],"_content":"\n使用shell对文件夹进行遍历处理，最后通过markdown生成可视化的结果文件。比较适合对少量数据进行结果快速比对\n\n- shell脚本遍历子目录及子目录下的文件，并将文件去发请求，把接口返回回来的json写入到文件中\n\n  ```shell\n  #!/bin/bash\n  function getdir(){\n  \turl = $2\n      for element in `ls $1`\n      do  \n          dir_or_file=$1\"/\"$element\n          if [ -d $dir_or_file ]\n          then \n              getdir $dir_or_file\n          else\n  \t    \tfilepath=${dir_or_file%.*}\n  \t    \t#不带文件后缀的文件路径\n  \t    \tfilename=${filepath//\\//\\_}\n  \t    \t#把文件路径中的反斜线换成下划线\n  \t    \t\n  \t\t    if [ -e ${dir_or_file%.*}.jpg ]\n  \t\t    then\n  \t     \t    curl -F img=@${dir_or_file%.*}.jpg $url > idcard_result/${filename}.json\t\n  \t\t    elif [ -e ${dir_or_file%.*}.png ]\n  \t   \t    then\n  \t\t\t\tcurl -F img=@${dir_or_file%.*}.png $url > idcard_result/${filename}.json\n              fi\n          fi  \n      done\n  }\n  parentpath=$1\n  mkdir idcard_result\n  url=http://10.201.102.163:9002/faceid/v1/idcard\n  #echo $parentpath http://10.201.102.163:9002/faceid/v1/idcard\n  echo $url\n  getdir $parentpath $url\n  ```\n\n- python 比较身份证正确答案的json文件和ocr识别结果的文件进行核对，统计是否识别正确。python版本为2.7.13。以下为check.py的源码,因为在python2.7里json.load出来的json 是unicode编码的，所以比较的时候在自己的中文中添加U。如：std[U'姓名']\n\n  <!-- more -->\n\n  ```python\n  #!/usr/bin/env python\n  # -*- coding:utf-8 -*-\n  import sys\n  import json\n  reload(sys)\n  sys.setdefaultencoding('utf-8')\n  def startcheck(originfile, ocrfile):\n      with open(originfile, 'r') as f:\n          std = json.load(f, encoding='utf-8')\n\n      with open(ocrfile, 'r') as f:\n          rst = json.load(f, encoding='utf-8')\n\n      result = True\n      if rst['side'] == 'front':\n          bd = rst['birthday']\n          bd_date = bd['year'] + '年' + bd['month'] + '月' + bd['day'] + '日'\n          if rst['name'] != std[U'姓名']:\n              result = False\n          if rst['gender'] != std[U'性别']:\n              result = False\n          if rst['race'] != std[U'民族']:\n              result = False\n          if bd_date != std[U'出生']:\n              result = False\n          if rst['address'] != std[U'住址']:\n              result = False\n          if rst['id_card_number'] != std[U'公民身份号码']:\n              result = False\n      else:\n          if rst['issued_by'] != std[U'签发机关']:\n              result = False\n          if rst['valid_date'] != std[U'有效期']:\n              result = False\n      strResult = str(result)\n      content = '%s,%s,%s,\\n' % (originfile, ocrfile, strResult)\n      with open('./check_result.csv', 'a') as f:\n          f.write(content)\n\n  if __name__ == '__main__':\n      originfile_path = sys.argv[1]\n      print 'originfile_path:::', originfile_path\n      ocrfile_path = sys.argv[2]\n      print 'ocrfile_path:::', ocrfile_path\n      startcheck(originfile_path, ocrfile_path)\n\n  ```\n\n  ```shell\n  python check.py real.json ocr.json\n  ```\n\n  real.json，以下身份证信息均为非真实身份证\n\n  ```json\n  {\n    \"住址\": \"山东省招远市温泉路309号\",\n    \"姓名\": \"杜英男\",\n    \"民族\": \"汉\",\n    \"性别\": \"女\",\n    \"公民身份号码\": \"230122195807160467\",\n    \"出生\": \"1988年7月16日\"\n  }\n  ```\n\n  ocr.json\n\n  ```json\n  {\n    \"address\": \"湖南省长沙县安沙镇泗洲村龙口组337号\",\n    \"address_confidence\": [],\n    \"birthday\": {\n      \"day\": \"11\",\n      \"day_confidence\": [],\n      \"month\": \"2\",\n      \"month_confidence\": [],\n      \"year\": \"1994\",\n      \"year_confidence\": []\n    },\n    \"card_bound\": {},\n    \"gender\": \"男\",\n    \"gender_confidence\": [],\n    \"head_rect\": {},\n    \"id_card_number\": \"430121198402117321\",\n    \"idnumber_confidence\": [],\n    \"name\": \"王威一\",\n    \"name_confidence\": [],\n    \"race\": \"汉\",\n    \"race_confidence\": [],\n    \"request_id\": \"1521613434,cdc90cd4-ea2e-4bf9-b112-bce711ba2e90\",\n    \"side\": \"front\",\n    \"time_used\": 346\n  }\n  ```\n\n  \n\n- 切分文件进行比对，同时生成md文件，通过typora导出pdf可视化文件\n\n  ```shell\n  #!/bin/bash\n  for f in `ls -v *.jpg | grep _ |cut -d_ -f 1 |uniq -c |awk '{print $2}'`\n  do\n  #echo ${f}_0.jpg\n  a=`curl -F image_idcard=@${f}_0.jpg -F image_best=@${f}_1.jpg -F watermark=1 http://10.201.102.104:9000/verify | jq -c -r .confidence`\n  echo ![img](http://localhost:8080/${f}_0.jpg) ![img](http://localhost:8080/${f}_1.jpg) >>$a.md \n  #echo ${f}_0.jpg ${f}_1.jpg $a >> a.log\n  done\n\n  ```\n\n  ls -v 排序列出所有文件\n\n  grep _ 标记出带有下滑线的\n\n  cut -d _ -f 1 将文件按下划线切分取第一部分\n\n  uniq -c 显示重复的数量和cut -d _ -f 1的部分\n\n  awk '{print $2}' 打印出cut -d _ -f 1部分\n\n  \n\n  \n\n","source":"_posts/脚本跑批.md","raw":"---\ntitle: 身份证识别跑批脚本\ndate: 2018-03-21 12:53:30\nindex_img:\n- /images/shell/idcard_front.jpg\ntags:\n- shell \n- Linux\ncategories:\n- Linux\n---\n\n使用shell对文件夹进行遍历处理，最后通过markdown生成可视化的结果文件。比较适合对少量数据进行结果快速比对\n\n- shell脚本遍历子目录及子目录下的文件，并将文件去发请求，把接口返回回来的json写入到文件中\n\n  ```shell\n  #!/bin/bash\n  function getdir(){\n  \turl = $2\n      for element in `ls $1`\n      do  \n          dir_or_file=$1\"/\"$element\n          if [ -d $dir_or_file ]\n          then \n              getdir $dir_or_file\n          else\n  \t    \tfilepath=${dir_or_file%.*}\n  \t    \t#不带文件后缀的文件路径\n  \t    \tfilename=${filepath//\\//\\_}\n  \t    \t#把文件路径中的反斜线换成下划线\n  \t    \t\n  \t\t    if [ -e ${dir_or_file%.*}.jpg ]\n  \t\t    then\n  \t     \t    curl -F img=@${dir_or_file%.*}.jpg $url > idcard_result/${filename}.json\t\n  \t\t    elif [ -e ${dir_or_file%.*}.png ]\n  \t   \t    then\n  \t\t\t\tcurl -F img=@${dir_or_file%.*}.png $url > idcard_result/${filename}.json\n              fi\n          fi  \n      done\n  }\n  parentpath=$1\n  mkdir idcard_result\n  url=http://10.201.102.163:9002/faceid/v1/idcard\n  #echo $parentpath http://10.201.102.163:9002/faceid/v1/idcard\n  echo $url\n  getdir $parentpath $url\n  ```\n\n- python 比较身份证正确答案的json文件和ocr识别结果的文件进行核对，统计是否识别正确。python版本为2.7.13。以下为check.py的源码,因为在python2.7里json.load出来的json 是unicode编码的，所以比较的时候在自己的中文中添加U。如：std[U'姓名']\n\n  <!-- more -->\n\n  ```python\n  #!/usr/bin/env python\n  # -*- coding:utf-8 -*-\n  import sys\n  import json\n  reload(sys)\n  sys.setdefaultencoding('utf-8')\n  def startcheck(originfile, ocrfile):\n      with open(originfile, 'r') as f:\n          std = json.load(f, encoding='utf-8')\n\n      with open(ocrfile, 'r') as f:\n          rst = json.load(f, encoding='utf-8')\n\n      result = True\n      if rst['side'] == 'front':\n          bd = rst['birthday']\n          bd_date = bd['year'] + '年' + bd['month'] + '月' + bd['day'] + '日'\n          if rst['name'] != std[U'姓名']:\n              result = False\n          if rst['gender'] != std[U'性别']:\n              result = False\n          if rst['race'] != std[U'民族']:\n              result = False\n          if bd_date != std[U'出生']:\n              result = False\n          if rst['address'] != std[U'住址']:\n              result = False\n          if rst['id_card_number'] != std[U'公民身份号码']:\n              result = False\n      else:\n          if rst['issued_by'] != std[U'签发机关']:\n              result = False\n          if rst['valid_date'] != std[U'有效期']:\n              result = False\n      strResult = str(result)\n      content = '%s,%s,%s,\\n' % (originfile, ocrfile, strResult)\n      with open('./check_result.csv', 'a') as f:\n          f.write(content)\n\n  if __name__ == '__main__':\n      originfile_path = sys.argv[1]\n      print 'originfile_path:::', originfile_path\n      ocrfile_path = sys.argv[2]\n      print 'ocrfile_path:::', ocrfile_path\n      startcheck(originfile_path, ocrfile_path)\n\n  ```\n\n  ```shell\n  python check.py real.json ocr.json\n  ```\n\n  real.json，以下身份证信息均为非真实身份证\n\n  ```json\n  {\n    \"住址\": \"山东省招远市温泉路309号\",\n    \"姓名\": \"杜英男\",\n    \"民族\": \"汉\",\n    \"性别\": \"女\",\n    \"公民身份号码\": \"230122195807160467\",\n    \"出生\": \"1988年7月16日\"\n  }\n  ```\n\n  ocr.json\n\n  ```json\n  {\n    \"address\": \"湖南省长沙县安沙镇泗洲村龙口组337号\",\n    \"address_confidence\": [],\n    \"birthday\": {\n      \"day\": \"11\",\n      \"day_confidence\": [],\n      \"month\": \"2\",\n      \"month_confidence\": [],\n      \"year\": \"1994\",\n      \"year_confidence\": []\n    },\n    \"card_bound\": {},\n    \"gender\": \"男\",\n    \"gender_confidence\": [],\n    \"head_rect\": {},\n    \"id_card_number\": \"430121198402117321\",\n    \"idnumber_confidence\": [],\n    \"name\": \"王威一\",\n    \"name_confidence\": [],\n    \"race\": \"汉\",\n    \"race_confidence\": [],\n    \"request_id\": \"1521613434,cdc90cd4-ea2e-4bf9-b112-bce711ba2e90\",\n    \"side\": \"front\",\n    \"time_used\": 346\n  }\n  ```\n\n  \n\n- 切分文件进行比对，同时生成md文件，通过typora导出pdf可视化文件\n\n  ```shell\n  #!/bin/bash\n  for f in `ls -v *.jpg | grep _ |cut -d_ -f 1 |uniq -c |awk '{print $2}'`\n  do\n  #echo ${f}_0.jpg\n  a=`curl -F image_idcard=@${f}_0.jpg -F image_best=@${f}_1.jpg -F watermark=1 http://10.201.102.104:9000/verify | jq -c -r .confidence`\n  echo ![img](http://localhost:8080/${f}_0.jpg) ![img](http://localhost:8080/${f}_1.jpg) >>$a.md \n  #echo ${f}_0.jpg ${f}_1.jpg $a >> a.log\n  done\n\n  ```\n\n  ls -v 排序列出所有文件\n\n  grep _ 标记出带有下滑线的\n\n  cut -d _ -f 1 将文件按下划线切分取第一部分\n\n  uniq -c 显示重复的数量和cut -d _ -f 1的部分\n\n  awk '{print $2}' 打印出cut -d _ -f 1部分\n\n  \n\n  \n\n","slug":"脚本跑批","published":1,"updated":"2020-03-24T08:25:33.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckghk0s0s0022mdymhpgl1203","content":"<p>使用shell对文件夹进行遍历处理，最后通过markdown生成可视化的结果文件。比较适合对少量数据进行结果快速比对</p>\n<ul>\n<li><p>shell脚本遍历子目录及子目录下的文件，并将文件去发请求，把接口返回回来的json写入到文件中</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\nfunction getdir()&#123;\n\turl = $2\n    for element in `ls $1`\n    do  \n        dir_or_file=$1&quot;/&quot;$element\n        if [ -d $dir_or_file ]\n        then \n            getdir $dir_or_file\n        else\n\t    \tfilepath=$&#123;dir_or_file%.*&#125;\n\t    \t#不带文件后缀的文件路径\n\t    \tfilename=$&#123;filepath//\\//\\_&#125;\n\t    \t#把文件路径中的反斜线换成下划线\n\t    \t\n\t\t    if [ -e $&#123;dir_or_file%.*&#125;.jpg ]\n\t\t    then\n\t     \t    curl -F img=@$&#123;dir_or_file%.*&#125;.jpg $url &gt; idcard_result/$&#123;filename&#125;.json\t\n\t\t    elif [ -e $&#123;dir_or_file%.*&#125;.png ]\n\t   \t    then\n\t\t\t\tcurl -F img=@$&#123;dir_or_file%.*&#125;.png $url &gt; idcard_result/$&#123;filename&#125;.json\n            fi\n        fi  \n    done\n&#125;\nparentpath=$1\nmkdir idcard_result\nurl=http://10.201.102.163:9002/faceid/v1/idcard\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$parentpath</span> http://10.201.102.163:9002/faceid/v1/idcard</span>\necho $url\ngetdir $parentpath $url</code></pre>\n</li>\n<li><p>python 比较身份证正确答案的json文件和ocr识别结果的文件进行核对，统计是否识别正确。python版本为2.7.13。以下为check.py的源码,因为在python2.7里json.load出来的json 是unicode编码的，所以比较的时候在自己的中文中添加U。如：std[U’姓名’]</p>\n<a id=\"more\"></a>\n\n<pre><code class=\"hljs python\"><span class=\"hljs-comment\">#!/usr/bin/env python</span>\n<span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span>\n<span class=\"hljs-keyword\">import</span> sys\n<span class=\"hljs-keyword\">import</span> json\nreload(sys)\nsys.setdefaultencoding(<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">startcheck</span>(<span class=\"hljs-params\">originfile, ocrfile</span>):</span>\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(originfile, <span class=\"hljs-string\">&#x27;r&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n        std = json.load(f, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(ocrfile, <span class=\"hljs-string\">&#x27;r&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n        rst = json.load(f, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n\n    result = <span class=\"hljs-literal\">True</span>\n    <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;side&#x27;</span>] == <span class=\"hljs-string\">&#x27;front&#x27;</span>:\n        bd = rst[<span class=\"hljs-string\">&#x27;birthday&#x27;</span>]\n        bd_date = bd[<span class=\"hljs-string\">&#x27;year&#x27;</span>] + <span class=\"hljs-string\">&#x27;年&#x27;</span> + bd[<span class=\"hljs-string\">&#x27;month&#x27;</span>] + <span class=\"hljs-string\">&#x27;月&#x27;</span> + bd[<span class=\"hljs-string\">&#x27;day&#x27;</span>] + <span class=\"hljs-string\">&#x27;日&#x27;</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;name&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;姓名&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;gender&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;性别&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;race&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;民族&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> bd_date != std[<span class=\"hljs-string\">U&#x27;出生&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;address&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;住址&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;id_card_number&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;公民身份号码&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n    <span class=\"hljs-keyword\">else</span>:\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;issued_by&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;签发机关&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;valid_date&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;有效期&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n    strResult = <span class=\"hljs-built_in\">str</span>(result)\n    content = <span class=\"hljs-string\">&#x27;%s,%s,%s,\\n&#x27;</span> % (originfile, ocrfile, strResult)\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;./check_result.csv&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n        f.write(content)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:\n    originfile_path = sys.argv[<span class=\"hljs-number\">1</span>]\n    <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&#x27;originfile_path:::&#x27;</span>, originfile_path\n    ocrfile_path = sys.argv[<span class=\"hljs-number\">2</span>]\n    <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&#x27;ocrfile_path:::&#x27;</span>, ocrfile_path\n    startcheck(originfile_path, ocrfile_path)\n</code></pre>\n\n<pre><code class=\"hljs shell\">python check.py real.json ocr.json</code></pre>\n\n<p>real.json，以下身份证信息均为非真实身份证</p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">&quot;住址&quot;</span>: <span class=\"hljs-string\">&quot;山东省招远市温泉路309号&quot;</span>,\n  <span class=\"hljs-attr\">&quot;姓名&quot;</span>: <span class=\"hljs-string\">&quot;杜英男&quot;</span>,\n  <span class=\"hljs-attr\">&quot;民族&quot;</span>: <span class=\"hljs-string\">&quot;汉&quot;</span>,\n  <span class=\"hljs-attr\">&quot;性别&quot;</span>: <span class=\"hljs-string\">&quot;女&quot;</span>,\n  <span class=\"hljs-attr\">&quot;公民身份号码&quot;</span>: <span class=\"hljs-string\">&quot;230122195807160467&quot;</span>,\n  <span class=\"hljs-attr\">&quot;出生&quot;</span>: <span class=\"hljs-string\">&quot;1988年7月16日&quot;</span>\n&#125;</code></pre>\n\n<p>ocr.json</p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">&quot;address&quot;</span>: <span class=\"hljs-string\">&quot;湖南省长沙县安沙镇泗洲村龙口组337号&quot;</span>,\n  <span class=\"hljs-attr\">&quot;address_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;birthday&quot;</span>: &#123;\n    <span class=\"hljs-attr\">&quot;day&quot;</span>: <span class=\"hljs-string\">&quot;11&quot;</span>,\n    <span class=\"hljs-attr\">&quot;day_confidence&quot;</span>: [],\n    <span class=\"hljs-attr\">&quot;month&quot;</span>: <span class=\"hljs-string\">&quot;2&quot;</span>,\n    <span class=\"hljs-attr\">&quot;month_confidence&quot;</span>: [],\n    <span class=\"hljs-attr\">&quot;year&quot;</span>: <span class=\"hljs-string\">&quot;1994&quot;</span>,\n    <span class=\"hljs-attr\">&quot;year_confidence&quot;</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">&quot;card_bound&quot;</span>: &#123;&#125;,\n  <span class=\"hljs-attr\">&quot;gender&quot;</span>: <span class=\"hljs-string\">&quot;男&quot;</span>,\n  <span class=\"hljs-attr\">&quot;gender_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;head_rect&quot;</span>: &#123;&#125;,\n  <span class=\"hljs-attr\">&quot;id_card_number&quot;</span>: <span class=\"hljs-string\">&quot;430121198402117321&quot;</span>,\n  <span class=\"hljs-attr\">&quot;idnumber_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;王威一&quot;</span>,\n  <span class=\"hljs-attr\">&quot;name_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;race&quot;</span>: <span class=\"hljs-string\">&quot;汉&quot;</span>,\n  <span class=\"hljs-attr\">&quot;race_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;request_id&quot;</span>: <span class=\"hljs-string\">&quot;1521613434,cdc90cd4-ea2e-4bf9-b112-bce711ba2e90&quot;</span>,\n  <span class=\"hljs-attr\">&quot;side&quot;</span>: <span class=\"hljs-string\">&quot;front&quot;</span>,\n  <span class=\"hljs-attr\">&quot;time_used&quot;</span>: <span class=\"hljs-number\">346</span>\n&#125;</code></pre>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>切分文件进行比对，同时生成md文件，通过typora导出pdf可视化文件</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\nfor f in `ls -v *.jpg | grep _ |cut -d_ -f 1 |uniq -c |awk &#x27;&#123;print $2&#125;&#x27;`\ndo\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;f&#125;</span>_0.jpg</span>\na=`curl -F image_idcard=@$&#123;f&#125;_0.jpg -F image_best=@$&#123;f&#125;_1.jpg -F watermark=1 http://10.201.102.104:9000/verify | jq -c -r .confidence`\necho ![img](http://localhost:8080/$&#123;f&#125;_0.jpg) ![img](http://localhost:8080/$&#123;f&#125;_1.jpg) &gt;&gt;$a.md \n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;f&#125;</span>_0.jpg <span class=\"hljs-variable\">$&#123;f&#125;</span>_1.jpg <span class=\"hljs-variable\">$a</span> &gt;&gt; a.log</span>\ndone\n</code></pre>\n\n<p>ls -v 排序列出所有文件</p>\n<p>grep _ 标记出带有下滑线的</p>\n<p>cut -d _ -f 1 将文件按下划线切分取第一部分</p>\n<p>uniq -c 显示重复的数量和cut -d _ -f 1的部分</p>\n<p>awk ‘{print $2}’ 打印出cut -d _ -f 1部分</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>使用shell对文件夹进行遍历处理，最后通过markdown生成可视化的结果文件。比较适合对少量数据进行结果快速比对</p>\n<ul>\n<li><p>shell脚本遍历子目录及子目录下的文件，并将文件去发请求，把接口返回回来的json写入到文件中</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\nfunction getdir()&#123;\n\turl = $2\n    for element in `ls $1`\n    do  \n        dir_or_file=$1&quot;/&quot;$element\n        if [ -d $dir_or_file ]\n        then \n            getdir $dir_or_file\n        else\n\t    \tfilepath=$&#123;dir_or_file%.*&#125;\n\t    \t#不带文件后缀的文件路径\n\t    \tfilename=$&#123;filepath//\\//\\_&#125;\n\t    \t#把文件路径中的反斜线换成下划线\n\t    \t\n\t\t    if [ -e $&#123;dir_or_file%.*&#125;.jpg ]\n\t\t    then\n\t     \t    curl -F img=@$&#123;dir_or_file%.*&#125;.jpg $url &gt; idcard_result/$&#123;filename&#125;.json\t\n\t\t    elif [ -e $&#123;dir_or_file%.*&#125;.png ]\n\t   \t    then\n\t\t\t\tcurl -F img=@$&#123;dir_or_file%.*&#125;.png $url &gt; idcard_result/$&#123;filename&#125;.json\n            fi\n        fi  \n    done\n&#125;\nparentpath=$1\nmkdir idcard_result\nurl=http://10.201.102.163:9002/faceid/v1/idcard\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$parentpath</span> http://10.201.102.163:9002/faceid/v1/idcard</span>\necho $url\ngetdir $parentpath $url</code></pre>\n</li>\n<li><p>python 比较身份证正确答案的json文件和ocr识别结果的文件进行核对，统计是否识别正确。python版本为2.7.13。以下为check.py的源码,因为在python2.7里json.load出来的json 是unicode编码的，所以比较的时候在自己的中文中添加U。如：std[U’姓名’]</p>","more":"<pre><code class=\"hljs python\"><span class=\"hljs-comment\">#!/usr/bin/env python</span>\n<span class=\"hljs-comment\"># -*- coding:utf-8 -*-</span>\n<span class=\"hljs-keyword\">import</span> sys\n<span class=\"hljs-keyword\">import</span> json\nreload(sys)\nsys.setdefaultencoding(<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">startcheck</span>(<span class=\"hljs-params\">originfile, ocrfile</span>):</span>\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(originfile, <span class=\"hljs-string\">&#x27;r&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n        std = json.load(f, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(ocrfile, <span class=\"hljs-string\">&#x27;r&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n        rst = json.load(f, encoding=<span class=\"hljs-string\">&#x27;utf-8&#x27;</span>)\n\n    result = <span class=\"hljs-literal\">True</span>\n    <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;side&#x27;</span>] == <span class=\"hljs-string\">&#x27;front&#x27;</span>:\n        bd = rst[<span class=\"hljs-string\">&#x27;birthday&#x27;</span>]\n        bd_date = bd[<span class=\"hljs-string\">&#x27;year&#x27;</span>] + <span class=\"hljs-string\">&#x27;年&#x27;</span> + bd[<span class=\"hljs-string\">&#x27;month&#x27;</span>] + <span class=\"hljs-string\">&#x27;月&#x27;</span> + bd[<span class=\"hljs-string\">&#x27;day&#x27;</span>] + <span class=\"hljs-string\">&#x27;日&#x27;</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;name&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;姓名&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;gender&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;性别&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;race&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;民族&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> bd_date != std[<span class=\"hljs-string\">U&#x27;出生&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;address&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;住址&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;id_card_number&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;公民身份号码&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n    <span class=\"hljs-keyword\">else</span>:\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;issued_by&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;签发机关&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">if</span> rst[<span class=\"hljs-string\">&#x27;valid_date&#x27;</span>] != std[<span class=\"hljs-string\">U&#x27;有效期&#x27;</span>]:\n            result = <span class=\"hljs-literal\">False</span>\n    strResult = <span class=\"hljs-built_in\">str</span>(result)\n    content = <span class=\"hljs-string\">&#x27;%s,%s,%s,\\n&#x27;</span> % (originfile, ocrfile, strResult)\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;./check_result.csv&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:\n        f.write(content)\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:\n    originfile_path = sys.argv[<span class=\"hljs-number\">1</span>]\n    <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&#x27;originfile_path:::&#x27;</span>, originfile_path\n    ocrfile_path = sys.argv[<span class=\"hljs-number\">2</span>]\n    <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&#x27;ocrfile_path:::&#x27;</span>, ocrfile_path\n    startcheck(originfile_path, ocrfile_path)\n</code></pre>\n\n<pre><code class=\"hljs shell\">python check.py real.json ocr.json</code></pre>\n\n<p>real.json，以下身份证信息均为非真实身份证</p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">&quot;住址&quot;</span>: <span class=\"hljs-string\">&quot;山东省招远市温泉路309号&quot;</span>,\n  <span class=\"hljs-attr\">&quot;姓名&quot;</span>: <span class=\"hljs-string\">&quot;杜英男&quot;</span>,\n  <span class=\"hljs-attr\">&quot;民族&quot;</span>: <span class=\"hljs-string\">&quot;汉&quot;</span>,\n  <span class=\"hljs-attr\">&quot;性别&quot;</span>: <span class=\"hljs-string\">&quot;女&quot;</span>,\n  <span class=\"hljs-attr\">&quot;公民身份号码&quot;</span>: <span class=\"hljs-string\">&quot;230122195807160467&quot;</span>,\n  <span class=\"hljs-attr\">&quot;出生&quot;</span>: <span class=\"hljs-string\">&quot;1988年7月16日&quot;</span>\n&#125;</code></pre>\n\n<p>ocr.json</p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">&quot;address&quot;</span>: <span class=\"hljs-string\">&quot;湖南省长沙县安沙镇泗洲村龙口组337号&quot;</span>,\n  <span class=\"hljs-attr\">&quot;address_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;birthday&quot;</span>: &#123;\n    <span class=\"hljs-attr\">&quot;day&quot;</span>: <span class=\"hljs-string\">&quot;11&quot;</span>,\n    <span class=\"hljs-attr\">&quot;day_confidence&quot;</span>: [],\n    <span class=\"hljs-attr\">&quot;month&quot;</span>: <span class=\"hljs-string\">&quot;2&quot;</span>,\n    <span class=\"hljs-attr\">&quot;month_confidence&quot;</span>: [],\n    <span class=\"hljs-attr\">&quot;year&quot;</span>: <span class=\"hljs-string\">&quot;1994&quot;</span>,\n    <span class=\"hljs-attr\">&quot;year_confidence&quot;</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">&quot;card_bound&quot;</span>: &#123;&#125;,\n  <span class=\"hljs-attr\">&quot;gender&quot;</span>: <span class=\"hljs-string\">&quot;男&quot;</span>,\n  <span class=\"hljs-attr\">&quot;gender_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;head_rect&quot;</span>: &#123;&#125;,\n  <span class=\"hljs-attr\">&quot;id_card_number&quot;</span>: <span class=\"hljs-string\">&quot;430121198402117321&quot;</span>,\n  <span class=\"hljs-attr\">&quot;idnumber_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;王威一&quot;</span>,\n  <span class=\"hljs-attr\">&quot;name_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;race&quot;</span>: <span class=\"hljs-string\">&quot;汉&quot;</span>,\n  <span class=\"hljs-attr\">&quot;race_confidence&quot;</span>: [],\n  <span class=\"hljs-attr\">&quot;request_id&quot;</span>: <span class=\"hljs-string\">&quot;1521613434,cdc90cd4-ea2e-4bf9-b112-bce711ba2e90&quot;</span>,\n  <span class=\"hljs-attr\">&quot;side&quot;</span>: <span class=\"hljs-string\">&quot;front&quot;</span>,\n  <span class=\"hljs-attr\">&quot;time_used&quot;</span>: <span class=\"hljs-number\">346</span>\n&#125;</code></pre>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>切分文件进行比对，同时生成md文件，通过typora导出pdf可视化文件</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\nfor f in `ls -v *.jpg | grep _ |cut -d_ -f 1 |uniq -c |awk &#x27;&#123;print $2&#125;&#x27;`\ndo\n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;f&#125;</span>_0.jpg</span>\na=`curl -F image_idcard=@$&#123;f&#125;_0.jpg -F image_best=@$&#123;f&#125;_1.jpg -F watermark=1 http://10.201.102.104:9000/verify | jq -c -r .confidence`\necho ![img](http://localhost:8080/$&#123;f&#125;_0.jpg) ![img](http://localhost:8080/$&#123;f&#125;_1.jpg) &gt;&gt;$a.md \n<span class=\"hljs-meta\">#</span><span class=\"bash\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$&#123;f&#125;</span>_0.jpg <span class=\"hljs-variable\">$&#123;f&#125;</span>_1.jpg <span class=\"hljs-variable\">$a</span> &gt;&gt; a.log</span>\ndone\n</code></pre>\n\n<p>ls -v 排序列出所有文件</p>\n<p>grep _ 标记出带有下滑线的</p>\n<p>cut -d _ -f 1 将文件按下划线切分取第一部分</p>\n<p>uniq -c 显示重复的数量和cut -d _ -f 1的部分</p>\n<p>awk ‘{print $2}’ 打印出cut -d _ -f 1部分</p>\n</li>\n</ul>"},{"title":"并发模型及线程模型概述","date":"2020-07-08T10:50:22.000Z","index_img":["/images/other/wm.jpg"],"_content":"\n### 同步异步\n\n要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？\n\n举一个例子说明，领导安排小东开发：\n\n**同步阻塞：**领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。\n\n**同步不阻塞：**领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。\n\n**异步阻塞：**领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。\n\n**异步不阻塞：**领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。\n\n**总结：**\n\n同步，是调用者主动去查看调用的状态；\n\n异步，则是被调用者来通知调用者；\n\n阻塞和非阻塞的区别是调用后是否立即返回\n\n### 并发模型\n\n#### 进程和线程的区别\n\n进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。\n\n进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。\n\n线程的上下文切换代价比进程要小的多。\n进程之间强调的是通信，线程之间强调的是同步（数据安全）。\n\n[转自链接](https://learnku.com/articles/32807)\n\n#### 并发模型\n\n1. 单进/线程-循环处理任务\n\n   单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。\n\n2. 多进程单线程\n\n   主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重\n\n3. 单进程多线程\n\n   单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。\n\n4. 多进程多线程\n\n   这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在**CPU密集型作业**下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。\n\n5. IO多路复用\n\n   IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。\n\n   [彻底理解 IO多路复用](https://juejin.im/post/6844904200141438984)\n   \n6. 协程\n\n   协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地`yield`进行切换，golang 则是用 go 语法来开启`goroutine`，具体的调度由语言层面提供的运行时执行。\n\n### 线程模型\n\n线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。\n\n以下内容摘抄自[Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池](https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst)\n\n**[内核调度实体（KSE，Kernel Scheduling Entity）](https://helix979.github.io/jkoo/post/os-scheduler/)**\n\n1. 内核级线程模型\n\n   用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。\n\n   这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   C[内核线程] -->D(用户线程)\n   E[内核线程] -->F(用户线程)\n    \n   ```\n\n   \n\n2. 用户级线程模型\n\n   用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 **协程库**基本上都属于这种方式（比如python的gevent）。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   ```\n\n   由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。\n\n   但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的**协程库**会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。\n\n3. 两级线程模型（混合型线程模型）\n\n   两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。\n\n   在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   K[内核线程] -->B\n   K-->D\n   K-->F\n   Z[内核线程] -->B\n   Z-->D\n   Z-->F\n   ```\n\n   所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？**即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』**\n\n   \n\n参考链接:\n\nhttps://juejin.im/entry/6844903680651558919\n\nhttps://juejin.im/post/6844904200141438984\n\nhttps://learnku.com/articles/32807\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\n","source":"_posts/并发模型及线程模型概述.md","raw":"---\ntitle: 并发模型及线程模型概述\ndate: 2020-07-08 18:50:22\nindex_img:\n- /images/other/wm.jpg\ntags: \n- 扩展\ncategories:\n- 随笔\n---\n\n### 同步异步\n\n要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？\n\n举一个例子说明，领导安排小东开发：\n\n**同步阻塞：**领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。\n\n**同步不阻塞：**领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。\n\n**异步阻塞：**领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。\n\n**异步不阻塞：**领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。\n\n**总结：**\n\n同步，是调用者主动去查看调用的状态；\n\n异步，则是被调用者来通知调用者；\n\n阻塞和非阻塞的区别是调用后是否立即返回\n\n### 并发模型\n\n#### 进程和线程的区别\n\n进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。\n\n进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。\n\n线程的上下文切换代价比进程要小的多。\n进程之间强调的是通信，线程之间强调的是同步（数据安全）。\n\n[转自链接](https://learnku.com/articles/32807)\n\n#### 并发模型\n\n1. 单进/线程-循环处理任务\n\n   单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。\n\n2. 多进程单线程\n\n   主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重\n\n3. 单进程多线程\n\n   单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。\n\n4. 多进程多线程\n\n   这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在**CPU密集型作业**下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。\n\n5. IO多路复用\n\n   IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。\n\n   [彻底理解 IO多路复用](https://juejin.im/post/6844904200141438984)\n   \n6. 协程\n\n   协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地`yield`进行切换，golang 则是用 go 语法来开启`goroutine`，具体的调度由语言层面提供的运行时执行。\n\n### 线程模型\n\n线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。\n\n以下内容摘抄自[Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池](https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst)\n\n**[内核调度实体（KSE，Kernel Scheduling Entity）](https://helix979.github.io/jkoo/post/os-scheduler/)**\n\n1. 内核级线程模型\n\n   用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。\n\n   这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   C[内核线程] -->D(用户线程)\n   E[内核线程] -->F(用户线程)\n    \n   ```\n\n   \n\n2. 用户级线程模型\n\n   用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 **协程库**基本上都属于这种方式（比如python的gevent）。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   ```\n\n   由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。\n\n   但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的**协程库**会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。\n\n3. 两级线程模型（混合型线程模型）\n\n   两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。\n\n   在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   K[内核线程] -->B\n   K-->D\n   K-->F\n   Z[内核线程] -->B\n   Z-->D\n   Z-->F\n   ```\n\n   所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？**即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』**\n\n   \n\n参考链接:\n\nhttps://juejin.im/entry/6844903680651558919\n\nhttps://juejin.im/post/6844904200141438984\n\nhttps://learnku.com/articles/32807\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\n","slug":"并发模型及线程模型概述","published":1,"updated":"2020-11-09T11:06:24.048Z","_id":"ckhafu8qe0000ksym8g700cou","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"同步异步\"><a href=\"#同步异步\" class=\"headerlink\" title=\"同步异步\"></a>同步异步</h3><p>要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？</p>\n<p>举一个例子说明，领导安排小东开发：</p>\n<p><strong>同步阻塞：</strong>领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。</p>\n<p><strong>同步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。</p>\n<p><strong>异步阻塞：</strong>领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。</p>\n<p><strong>异步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。</p>\n<p><strong>总结：</strong></p>\n<p>同步，是调用者主动去查看调用的状态；</p>\n<p>异步，则是被调用者来通知调用者；</p>\n<p>阻塞和非阻塞的区别是调用后是否立即返回</p>\n<h3 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h3><h4 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h4><p>进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。</p>\n<p>进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。</p>\n<p>线程的上下文切换代价比进程要小的多。<br>进程之间强调的是通信，线程之间强调的是同步（数据安全）。</p>\n<p><a href=\"https://learnku.com/articles/32807\">转自链接</a></p>\n<h4 id=\"并发模型-1\"><a href=\"#并发模型-1\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h4><ol>\n<li><p>单进/线程-循环处理任务</p>\n<p>单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。</p>\n</li>\n<li><p>多进程单线程</p>\n<p>主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重</p>\n</li>\n<li><p>单进程多线程</p>\n<p>单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。</p>\n</li>\n<li><p>多进程多线程</p>\n<p>这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在<strong>CPU密集型作业</strong>下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。</p>\n</li>\n<li><p>IO多路复用</p>\n<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。</p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">彻底理解 IO多路复用</a></p>\n</li>\n<li><p>协程</p>\n<p>协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地<code>yield</code>进行切换，golang 则是用 go 语法来开启<code>goroutine</code>，具体的调度由语言层面提供的运行时执行。</p>\n</li>\n</ol>\n<h3 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h3><p>线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。</p>\n<p>以下内容摘抄自<a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池</a></p>\n<p><strong><a href=\"https://helix979.github.io/jkoo/post/os-scheduler/\">内核调度实体（KSE，Kernel Scheduling Entity）</a></strong></p>\n<ol>\n<li><p>内核级线程模型</p>\n<p>用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。</p>\n<p>这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nC[内核线程] --&gt;D(用户线程)\nE[内核线程] --&gt;F(用户线程)</code></pre>\n\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>用户级线程模型</p>\n<p>用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 <strong>协程库</strong>基本上都属于这种方式（比如python的gevent）。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)</code></pre>\n\n<p>由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。</p>\n<p>但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的<strong>协程库</strong>会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p>\n</li>\n<li><p>两级线程模型（混合型线程模型）</p>\n<p>两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。</p>\n<p>在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)\nK[内核线程] --&gt;B\nK--&gt;D\nK--&gt;F\nZ[内核线程] --&gt;B\nZ--&gt;D\nZ--&gt;F</code></pre>\n\n<p>所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？<strong>即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』</strong></p>\n</li>\n</ol>\n<p>参考链接:</p>\n<p><a href=\"https://juejin.im/entry/6844903680651558919\">https://juejin.im/entry/6844903680651558919</a></p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">https://juejin.im/post/6844904200141438984</a></p>\n<p><a href=\"https://learnku.com/articles/32807\">https://learnku.com/articles/32807</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"同步异步\"><a href=\"#同步异步\" class=\"headerlink\" title=\"同步异步\"></a>同步异步</h3><p>要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？</p>\n<p>举一个例子说明，领导安排小东开发：</p>\n<p><strong>同步阻塞：</strong>领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。</p>\n<p><strong>同步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。</p>\n<p><strong>异步阻塞：</strong>领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。</p>\n<p><strong>异步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。</p>\n<p><strong>总结：</strong></p>\n<p>同步，是调用者主动去查看调用的状态；</p>\n<p>异步，则是被调用者来通知调用者；</p>\n<p>阻塞和非阻塞的区别是调用后是否立即返回</p>\n<h3 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h3><h4 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h4><p>进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。</p>\n<p>进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。</p>\n<p>线程的上下文切换代价比进程要小的多。<br>进程之间强调的是通信，线程之间强调的是同步（数据安全）。</p>\n<p><a href=\"https://learnku.com/articles/32807\">转自链接</a></p>\n<h4 id=\"并发模型-1\"><a href=\"#并发模型-1\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h4><ol>\n<li><p>单进/线程-循环处理任务</p>\n<p>单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。</p>\n</li>\n<li><p>多进程单线程</p>\n<p>主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重</p>\n</li>\n<li><p>单进程多线程</p>\n<p>单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。</p>\n</li>\n<li><p>多进程多线程</p>\n<p>这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在<strong>CPU密集型作业</strong>下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。</p>\n</li>\n<li><p>IO多路复用</p>\n<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。</p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">彻底理解 IO多路复用</a></p>\n</li>\n<li><p>协程</p>\n<p>协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地<code>yield</code>进行切换，golang 则是用 go 语法来开启<code>goroutine</code>，具体的调度由语言层面提供的运行时执行。</p>\n</li>\n</ol>\n<h3 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h3><p>线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。</p>\n<p>以下内容摘抄自<a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池</a></p>\n<p><strong><a href=\"https://helix979.github.io/jkoo/post/os-scheduler/\">内核调度实体（KSE，Kernel Scheduling Entity）</a></strong></p>\n<ol>\n<li><p>内核级线程模型</p>\n<p>用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。</p>\n<p>这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nC[内核线程] --&gt;D(用户线程)\nE[内核线程] --&gt;F(用户线程)</code></pre>\n\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>用户级线程模型</p>\n<p>用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 <strong>协程库</strong>基本上都属于这种方式（比如python的gevent）。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)</code></pre>\n\n<p>由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。</p>\n<p>但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的<strong>协程库</strong>会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p>\n</li>\n<li><p>两级线程模型（混合型线程模型）</p>\n<p>两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。</p>\n<p>在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)\nK[内核线程] --&gt;B\nK--&gt;D\nK--&gt;F\nZ[内核线程] --&gt;B\nZ--&gt;D\nZ--&gt;F</code></pre>\n\n<p>所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？<strong>即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』</strong></p>\n</li>\n</ol>\n<p>参考链接:</p>\n<p><a href=\"https://juejin.im/entry/6844903680651558919\">https://juejin.im/entry/6844903680651558919</a></p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">https://juejin.im/post/6844904200141438984</a></p>\n<p><a href=\"https://learnku.com/articles/32807\">https://learnku.com/articles/32807</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n"},{"title":"并发模型及线程模型概述","date":"2020-08-10T12:40:22.000Z","index_img":["/images/golang/goroutine.jpg"],"_content":"\n### Goroutine & Scheduler\n\n在上一篇的[并发模型和线程模型概述]()中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。\n\n每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。\n\n在了解golang的scheduler之前，我们先了解下os scheduler。\n\n#### os scheduler\n\n调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备\n\nos scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。\n\n当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。\n\n#### Go scheduler\n\n今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从[Go调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/) 了解\n\n##### G-P-M 模型\n\n每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。\n\n先来了解下G-P- M\n\n- G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。\n- M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。\n- P：Processor，表示逻辑处理器。\n\n在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。\n\n##### G-P-M模型调度\n\n根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。\n\n当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。\n\n如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为\n\nGo runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：\n\n- blocking syscall (for example opening a file)\n- network input\n- channel operations\n- primitives in the sync package\n\n这四种场景又可归类为两种类型：\n\n1. 用户态阻塞/唤醒\n\n   当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由`_Gruning`变为`_Gwaitting`，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。\n\n2. 系统调用阻塞\n\n   当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在`_Gsyscall`状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。\n\n更多的调度过程可参考[理解golang调度之二 ：Go调度器](https://juejin.cn/post/6844903846825705485)含图解\n\n#### 工作负载\n\n如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。\n\n- **CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。\n- **IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。\n\n**cpu-bound的工作负载，你需要并行去使用并发**。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。\n\n**在IO-Bound的workloads里，你不需要并行去使用并发**。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。\n\n#### 并发和并行\n\n| 类型      | 线程数 | 结论                                       | 原因                                                         |\n| --------- | ------ | ------------------------------------------ | ------------------------------------------------------------ |\n| CPU密集型 | 1      | 起一个goroutine，性能要好于起多个goroutine | 1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗 |\n| CPU密集型 | 大于1  | 起多个goroutine，性能要好于起一个goroutine | 多个OS线程中可以并行计算。收益大于goroutine上下文切换        |\n| IO密集型  | 1      | 起多个goroutine，性能高于起一个goroutine   | 1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做 |\n| IO密集型  | 大于1  | 起多个goroutine，性能高于起一个goroutine   | 多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。 |\n\n该表格结论来自于[理解golang调度之三：并发](https://juejin.im/post/6844903847568080904)\n\n参考：\n\nhttps://qcrao.com/2019/09/02/dive-into-go-scheduler/\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\nhttps://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\n\nhttps://www.cnblogs.com/jiujuan/p/12735559.html\n\n","source":"_posts/Goroutine & Scheduler.md","raw":"---\ntitle: 并发模型及线程模型概述\ndate: 2020-08-10 20:40:22\nindex_img:\n- /images/golang/goroutine.jpg\ntags: \n- golang\ncategories:\n- golang\n---\n\n### Goroutine & Scheduler\n\n在上一篇的[并发模型和线程模型概述]()中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。\n\n每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。\n\n在了解golang的scheduler之前，我们先了解下os scheduler。\n\n#### os scheduler\n\n调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备\n\nos scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。\n\n当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。\n\n#### Go scheduler\n\n今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从[Go调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/) 了解\n\n##### G-P-M 模型\n\n每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。\n\n先来了解下G-P- M\n\n- G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。\n- M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。\n- P：Processor，表示逻辑处理器。\n\n在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。\n\n##### G-P-M模型调度\n\n根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。\n\n当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。\n\n如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为\n\nGo runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：\n\n- blocking syscall (for example opening a file)\n- network input\n- channel operations\n- primitives in the sync package\n\n这四种场景又可归类为两种类型：\n\n1. 用户态阻塞/唤醒\n\n   当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由`_Gruning`变为`_Gwaitting`，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。\n\n2. 系统调用阻塞\n\n   当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在`_Gsyscall`状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。\n\n更多的调度过程可参考[理解golang调度之二 ：Go调度器](https://juejin.cn/post/6844903846825705485)含图解\n\n#### 工作负载\n\n如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。\n\n- **CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。\n- **IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。\n\n**cpu-bound的工作负载，你需要并行去使用并发**。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。\n\n**在IO-Bound的workloads里，你不需要并行去使用并发**。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。\n\n#### 并发和并行\n\n| 类型      | 线程数 | 结论                                       | 原因                                                         |\n| --------- | ------ | ------------------------------------------ | ------------------------------------------------------------ |\n| CPU密集型 | 1      | 起一个goroutine，性能要好于起多个goroutine | 1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗 |\n| CPU密集型 | 大于1  | 起多个goroutine，性能要好于起一个goroutine | 多个OS线程中可以并行计算。收益大于goroutine上下文切换        |\n| IO密集型  | 1      | 起多个goroutine，性能高于起一个goroutine   | 1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做 |\n| IO密集型  | 大于1  | 起多个goroutine，性能高于起一个goroutine   | 多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。 |\n\n该表格结论来自于[理解golang调度之三：并发](https://juejin.im/post/6844903847568080904)\n\n参考：\n\nhttps://qcrao.com/2019/09/02/dive-into-go-scheduler/\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\nhttps://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\n\nhttps://www.cnblogs.com/jiujuan/p/12735559.html\n\n","slug":"Goroutine & Scheduler","published":1,"updated":"2020-11-24T06:48:56.163Z","_id":"ckhvmd4m900006jym3bcoas92","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Goroutine-amp-Scheduler\"><a href=\"#Goroutine-amp-Scheduler\" class=\"headerlink\" title=\"Goroutine &amp; Scheduler\"></a>Goroutine &amp; Scheduler</h3><p>在上一篇的<a href=\"\">并发模型和线程模型概述</a>中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。</p>\n<p>每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。</p>\n<p>在了解golang的scheduler之前，我们先了解下os scheduler。</p>\n<h4 id=\"os-scheduler\"><a href=\"#os-scheduler\" class=\"headerlink\" title=\"os scheduler\"></a>os scheduler</h4><p>调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备</p>\n<p>os scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。</p>\n<p>当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。</p>\n<h4 id=\"Go-scheduler\"><a href=\"#Go-scheduler\" class=\"headerlink\" title=\"Go scheduler\"></a>Go scheduler</h4><p>今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从<a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">Go调度器</a> 了解</p>\n<h5 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h5><p>每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。</p>\n<p>先来了解下G-P- M</p>\n<ul>\n<li>G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。</li>\n<li>M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。</li>\n<li>P：Processor，表示逻辑处理器。</li>\n</ul>\n<p>在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。</p>\n<h5 id=\"G-P-M模型调度\"><a href=\"#G-P-M模型调度\" class=\"headerlink\" title=\"G-P-M模型调度\"></a>G-P-M模型调度</h5><p>根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。</p>\n<p>当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。</p>\n<p>如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为</p>\n<p>Go runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：</p>\n<ul>\n<li>blocking syscall (for example opening a file)</li>\n<li>network input</li>\n<li>channel operations</li>\n<li>primitives in the sync package</li>\n</ul>\n<p>这四种场景又可归类为两种类型：</p>\n<ol>\n<li><p>用户态阻塞/唤醒</p>\n<p>当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。</p>\n</li>\n<li><p>系统调用阻塞</p>\n<p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在<code>_Gsyscall</code>状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p>\n</li>\n</ol>\n<p>更多的调度过程可参考<a href=\"https://juejin.cn/post/6844903846825705485\">理解golang调度之二 ：Go调度器</a>含图解</p>\n<h4 id=\"工作负载\"><a href=\"#工作负载\" class=\"headerlink\" title=\"工作负载\"></a>工作负载</h4><p>如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。</p>\n<ul>\n<li>**CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。</li>\n<li>**IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。</li>\n</ul>\n<p><strong>cpu-bound的工作负载，你需要并行去使用并发</strong>。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。</p>\n<p><strong>在IO-Bound的workloads里，你不需要并行去使用并发</strong>。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。</p>\n<h4 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>线程数</th>\n<th>结论</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU密集型</td>\n<td>1</td>\n<td>起一个goroutine，性能要好于起多个goroutine</td>\n<td>1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗</td>\n</tr>\n<tr>\n<td>CPU密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能要好于起一个goroutine</td>\n<td>多个OS线程中可以并行计算。收益大于goroutine上下文切换</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。</td>\n</tr>\n</tbody></table>\n<p>该表格结论来自于<a href=\"https://juejin.im/post/6844903847568080904\">理解golang调度之三：并发</a></p>\n<p>参考：</p>\n<p><a href=\"https://qcrao.com/2019/09/02/dive-into-go-scheduler/\">https://qcrao.com/2019/09/02/dive-into-go-scheduler/</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n<p><a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</a></p>\n<p><a href=\"https://www.cnblogs.com/jiujuan/p/12735559.html\">https://www.cnblogs.com/jiujuan/p/12735559.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Goroutine-amp-Scheduler\"><a href=\"#Goroutine-amp-Scheduler\" class=\"headerlink\" title=\"Goroutine &amp; Scheduler\"></a>Goroutine &amp; Scheduler</h3><p>在上一篇的<a href=\"\">并发模型和线程模型概述</a>中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。</p>\n<p>每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。</p>\n<p>在了解golang的scheduler之前，我们先了解下os scheduler。</p>\n<h4 id=\"os-scheduler\"><a href=\"#os-scheduler\" class=\"headerlink\" title=\"os scheduler\"></a>os scheduler</h4><p>调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备</p>\n<p>os scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。</p>\n<p>当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。</p>\n<h4 id=\"Go-scheduler\"><a href=\"#Go-scheduler\" class=\"headerlink\" title=\"Go scheduler\"></a>Go scheduler</h4><p>今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从<a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">Go调度器</a> 了解</p>\n<h5 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h5><p>每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。</p>\n<p>先来了解下G-P- M</p>\n<ul>\n<li>G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。</li>\n<li>M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。</li>\n<li>P：Processor，表示逻辑处理器。</li>\n</ul>\n<p>在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。</p>\n<h5 id=\"G-P-M模型调度\"><a href=\"#G-P-M模型调度\" class=\"headerlink\" title=\"G-P-M模型调度\"></a>G-P-M模型调度</h5><p>根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。</p>\n<p>当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。</p>\n<p>如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为</p>\n<p>Go runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：</p>\n<ul>\n<li>blocking syscall (for example opening a file)</li>\n<li>network input</li>\n<li>channel operations</li>\n<li>primitives in the sync package</li>\n</ul>\n<p>这四种场景又可归类为两种类型：</p>\n<ol>\n<li><p>用户态阻塞/唤醒</p>\n<p>当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。</p>\n</li>\n<li><p>系统调用阻塞</p>\n<p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在<code>_Gsyscall</code>状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p>\n</li>\n</ol>\n<p>更多的调度过程可参考<a href=\"https://juejin.cn/post/6844903846825705485\">理解golang调度之二 ：Go调度器</a>含图解</p>\n<h4 id=\"工作负载\"><a href=\"#工作负载\" class=\"headerlink\" title=\"工作负载\"></a>工作负载</h4><p>如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。</p>\n<ul>\n<li>**CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。</li>\n<li>**IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。</li>\n</ul>\n<p><strong>cpu-bound的工作负载，你需要并行去使用并发</strong>。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。</p>\n<p><strong>在IO-Bound的workloads里，你不需要并行去使用并发</strong>。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。</p>\n<h4 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>线程数</th>\n<th>结论</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU密集型</td>\n<td>1</td>\n<td>起一个goroutine，性能要好于起多个goroutine</td>\n<td>1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗</td>\n</tr>\n<tr>\n<td>CPU密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能要好于起一个goroutine</td>\n<td>多个OS线程中可以并行计算。收益大于goroutine上下文切换</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。</td>\n</tr>\n</tbody></table>\n<p>该表格结论来自于<a href=\"https://juejin.im/post/6844903847568080904\">理解golang调度之三：并发</a></p>\n<p>参考：</p>\n<p><a href=\"https://qcrao.com/2019/09/02/dive-into-go-scheduler/\">https://qcrao.com/2019/09/02/dive-into-go-scheduler/</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n<p><a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</a></p>\n<p><a href=\"https://www.cnblogs.com/jiujuan/p/12735559.html\">https://www.cnblogs.com/jiujuan/p/12735559.html</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckghk0rzy0001mdym47ba5zwb","category_id":"ckghk0s030003mdym14sl9w28","_id":"ckghk0s09000dmdymfeam1e0x"},{"post_id":"ckghk0s010002mdym1raf6iwp","category_id":"ckghk0s070008mdym6mf3deg5","_id":"ckghk0s0b000jmdym479t532q"},{"post_id":"ckghk0s09000gmdym74x2a376","category_id":"ckghk0s09000emdymhuux6l3b","_id":"ckghk0s0f000qmdymgym85w1o"},{"post_id":"ckghk0s050005mdymg6smfo0z","category_id":"ckghk0s09000emdymhuux6l3b","_id":"ckghk0s0g000vmdym55tbb7dq"},{"post_id":"ckghk0s050006mdymfwvm63vj","category_id":"ckghk0s09000emdymhuux6l3b","_id":"ckghk0s0h000zmdymdvw1fbq5"},{"post_id":"ckghk0s0e000pmdymgeg4frcz","category_id":"ckghk0s030003mdym14sl9w28","_id":"ckghk0s0i0013mdymh8ci8vus"},{"post_id":"ckghk0s060007mdym174a6s7g","category_id":"ckghk0s09000emdymhuux6l3b","_id":"ckghk0s0j0017mdym82w49m4b"},{"post_id":"ckghk0s07000bmdym9yrbdgdb","category_id":"ckghk0s09000emdymhuux6l3b","_id":"ckghk0s0l001cmdym33lfcuqh"},{"post_id":"ckghk0s0k0019mdymgifths4p","category_id":"ckghk0s070008mdym6mf3deg5","_id":"ckghk0s0n001imdymdp7phhtk"},{"post_id":"ckghk0s08000cmdym23lja312","category_id":"ckghk0s0j0016mdym747o6af5","_id":"ckghk0s0o001kmdym85ipdq6o"},{"post_id":"ckghk0s0m001hmdymhn7z9zpe","category_id":"ckghk0s070008mdym6mf3deg5","_id":"ckghk0s0q001qmdym2euhaf72"},{"post_id":"ckghk0s0a000imdymhwz0hykc","category_id":"ckghk0s0l001dmdym1loe8dap","_id":"ckghk0s0r001vmdym43t70w0z"},{"post_id":"ckghk0s0n001jmdymbml10z3d","category_id":"ckghk0s0j0016mdym747o6af5","_id":"ckghk0s0s001ymdym37oofxuh"},{"post_id":"ckghk0s0d000nmdym5t2rfl42","category_id":"ckghk0s0l001dmdym1loe8dap","_id":"ckghk0s0t0023mdym9lr68fl1"},{"post_id":"ckghk0s0q001umdymh8f31jh3","category_id":"ckghk0s070008mdym6mf3deg5","_id":"ckghk0s0t0025mdyma5d3dqtg"},{"post_id":"ckghk0s0g000umdyma01a1i38","category_id":"ckghk0s0q001rmdymgvivhnax","_id":"ckghk0s0u0029mdym4ykm4n66"},{"post_id":"ckghk0s0r001xmdym652oa2m1","category_id":"ckghk0s070008mdym6mf3deg5","_id":"ckghk0s0u002bmdym29ox8n97"},{"post_id":"ckghk0s0s0022mdymhpgl1203","category_id":"ckghk0s070008mdym6mf3deg5","_id":"ckghk0s0u002dmdymdka2erxc"},{"post_id":"ckghk0s0g000xmdymhahveqnx","category_id":"ckghk0s0q001rmdymgvivhnax","_id":"ckghk0s0v002gmdymcs97aztz"},{"post_id":"ckghk0s0i0012mdymhh95dxbp","category_id":"ckghk0s0t0026mdymbvpd97i8","_id":"ckghk0s0v002imdymf27k44mx"},{"post_id":"ckghk0s0i0015mdym4zpcbcvf","category_id":"ckghk0s0u002cmdymbzy187kp","_id":"ckghk0s0w002mmdym0d7z1jor"},{"post_id":"ckghk0s0l001bmdymgxb63h3o","category_id":"ckghk0s0l001dmdym1loe8dap","_id":"ckghk0s0x002pmdymbj586ewk"},{"post_id":"ckghk0s0m001fmdymhkc08vvf","category_id":"ckghk0s0w002lmdym6qxtdmaq","_id":"ckghk0s0y002umdym72gh6zl6"},{"post_id":"ckghk0s0o001omdymgflv0ge2","category_id":"ckghk0s0x002qmdymdrm24oar","_id":"ckghk0s0z002ymdym9cio61ja"},{"post_id":"ckghk0s0p001pmdym10u7c03z","category_id":"ckghk0s0w002lmdym6qxtdmaq","_id":"ckghk0s0z0031mdymcgfp9hpe"},{"post_id":"ckhafu8qe0000ksym8g700cou","category_id":"ckghk0s0w002lmdym6qxtdmaq","_id":"ckhafu8ql0002ksymbpao3icv"},{"post_id":"ckhvmd4m900006jym3bcoas92","category_id":"ckghk0s0q001rmdymgvivhnax","_id":"ckhvmd4mg00026jym3prvge7o"}],"PostTag":[{"post_id":"ckghk0rzy0001mdym47ba5zwb","tag_id":"ckghk0s040004mdymdsxu9px1","_id":"ckghk0s07000amdym0s8e81ni"},{"post_id":"ckghk0s010002mdym1raf6iwp","tag_id":"ckghk0s070009mdym7dkjf77b","_id":"ckghk0s0a000hmdym7mfi9tck"},{"post_id":"ckghk0s09000gmdym74x2a376","tag_id":"ckghk0s09000fmdym2cagce7r","_id":"ckghk0s0b000mmdym9emy8svl"},{"post_id":"ckghk0s050005mdymg6smfo0z","tag_id":"ckghk0s09000fmdym2cagce7r","_id":"ckghk0s0e000omdym640nf1ha"},{"post_id":"ckghk0s0a000imdymhwz0hykc","tag_id":"ckghk0s070009mdym7dkjf77b","_id":"ckghk0s0f000tmdym60ok58g7"},{"post_id":"ckghk0s050006mdymfwvm63vj","tag_id":"ckghk0s09000fmdym2cagce7r","_id":"ckghk0s0g000wmdymaubzdw0n"},{"post_id":"ckghk0s0e000pmdymgeg4frcz","tag_id":"ckghk0s040004mdymdsxu9px1","_id":"ckghk0s0h0011mdym4mxi393z"},{"post_id":"ckghk0s060007mdym174a6s7g","tag_id":"ckghk0s09000fmdym2cagce7r","_id":"ckghk0s0i0014mdym73d7f7b5"},{"post_id":"ckghk0s07000bmdym9yrbdgdb","tag_id":"ckghk0s09000fmdym2cagce7r","_id":"ckghk0s0k001amdymgycz456c"},{"post_id":"ckghk0s08000cmdym23lja312","tag_id":"ckghk0s0j0018mdym0ujn994g","_id":"ckghk0s0m001gmdymgis05zwe"},{"post_id":"ckghk0s0d000nmdym5t2rfl42","tag_id":"ckghk0s0l001emdymhl6lbqy1","_id":"ckghk0s0o001nmdym91yuce0g"},{"post_id":"ckghk0s0o001omdymgflv0ge2","tag_id":"ckghk0s0l001emdymhl6lbqy1","_id":"ckghk0s0q001tmdymbmyyf99r"},{"post_id":"ckghk0s0g000umdyma01a1i38","tag_id":"ckghk0s0o001mmdymbm4p05qy","_id":"ckghk0s0r001wmdym4j3fckvx"},{"post_id":"ckghk0s0q001umdymh8f31jh3","tag_id":"ckghk0s070009mdym7dkjf77b","_id":"ckghk0s0s0021mdym9zd307fd"},{"post_id":"ckghk0s0g000xmdymhahveqnx","tag_id":"ckghk0s0q001smdymg46o2dwp","_id":"ckghk0s0t0024mdymeug904zd"},{"post_id":"ckghk0s0r001xmdym652oa2m1","tag_id":"ckghk0s070009mdym7dkjf77b","_id":"ckghk0s0u0027mdym414u36c2"},{"post_id":"ckghk0s0i0012mdymhh95dxbp","tag_id":"ckghk0s0s0020mdym25oe0xiu","_id":"ckghk0s0u002amdymh6msgun1"},{"post_id":"ckghk0s0i0015mdym4zpcbcvf","tag_id":"ckghk0s0u0028mdym20fz1vyd","_id":"ckghk0s0v002fmdym9uvk07ic"},{"post_id":"ckghk0s0k0019mdymgifths4p","tag_id":"ckghk0s0v002emdymcmmsh7nr","_id":"ckghk0s0w002kmdymelqr909i"},{"post_id":"ckghk0s0l001bmdymgxb63h3o","tag_id":"ckghk0s0u0028mdym20fz1vyd","_id":"ckghk0s0x002omdym31b1fqpf"},{"post_id":"ckghk0s0l001bmdymgxb63h3o","tag_id":"ckghk0s070009mdym7dkjf77b","_id":"ckghk0s0x002rmdymclmhg8eh"},{"post_id":"ckghk0s0m001fmdymhkc08vvf","tag_id":"ckghk0s0w002nmdym1qqj8c1j","_id":"ckghk0s0y002tmdym4t5o3jmx"},{"post_id":"ckghk0s0m001hmdymhn7z9zpe","tag_id":"ckghk0s0v002emdymcmmsh7nr","_id":"ckghk0s0y002xmdym0z106x3d"},{"post_id":"ckghk0s0n001jmdymbml10z3d","tag_id":"ckghk0s0y002wmdymfp9rd1te","_id":"ckghk0s0z0030mdym4q1g1pgv"},{"post_id":"ckghk0s0p001pmdym10u7c03z","tag_id":"ckghk0s0w002nmdym1qqj8c1j","_id":"ckghk0s100033mdym4ojw1z04"},{"post_id":"ckghk0s0s0022mdymhpgl1203","tag_id":"ckghk0s0v002emdymcmmsh7nr","_id":"ckghk0s100034mdym8ro3hq1f"},{"post_id":"ckghk0s0s0022mdymhpgl1203","tag_id":"ckghk0s070009mdym7dkjf77b","_id":"ckghk0s100035mdym8q2e4a7c"},{"post_id":"ckhafu8qe0000ksym8g700cou","tag_id":"ckghk0s0l001emdymhl6lbqy1","_id":"ckhafu8qk0001ksymg8p45j36"},{"post_id":"ckhvmd4m900006jym3bcoas92","tag_id":"ckghk0s0o001mmdymbm4p05qy","_id":"ckhvmd4mf00016jyma8w68q9b"}],"Tag":[{"name":"开发效率","_id":"ckghk0s040004mdymdsxu9px1"},{"name":"Linux","_id":"ckghk0s070009mdym7dkjf77b"},{"name":"mysql","_id":"ckghk0s09000fmdym2cagce7r"},{"name":"react-native","_id":"ckghk0s0j0018mdym0ujn994g"},{"name":"扩展","_id":"ckghk0s0l001emdymhl6lbqy1"},{"name":"golang","_id":"ckghk0s0o001mmdymbm4p05qy"},{"name":"golang cgo","_id":"ckghk0s0q001smdymg46o2dwp"},{"name":"jna","_id":"ckghk0s0s0020mdym25oe0xiu"},{"name":"Python","_id":"ckghk0s0u0028mdym20fz1vyd"},{"name":"shell","_id":"ckghk0s0v002emdymcmmsh7nr"},{"name":"随笔","_id":"ckghk0s0w002nmdym1qqj8c1j"},{"name":"react web","_id":"ckghk0s0y002wmdymfp9rd1te"}]}}