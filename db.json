{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/apple-touch-icon.png","path":"img/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/coloradoablaze.jpg","path":"img/coloradoablaze.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/lufei.jpg","path":"img/lufei.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/ali_pay.jpg","path":"images/ali_pay.jpg","modified":0,"renderable":0},{"_id":"source/images/ali_pay1.jpg","path":"images/ali_pay1.jpg","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/coloradoablaze.jpg","path":"images/coloradoablaze.jpg","modified":0,"renderable":0},{"_id":"source/images/wechat_pay.jpg","path":"images/wechat_pay.jpg","modified":0,"renderable":0},{"_id":"source/images/golang/goroutine.jpg","path":"images/golang/goroutine.jpg","modified":0,"renderable":0},{"_id":"source/images/golang/string.jpg","path":"images/golang/string.jpg","modified":0,"renderable":0},{"_id":"source/images/golang/logo.jpg","path":"images/golang/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/java/jna.jpg","path":"images/java/jna.jpg","modified":0,"renderable":0},{"_id":"source/images/other/banner.png","path":"images/other/banner.png","modified":0,"renderable":0},{"_id":"source/images/other/wm.jpg","path":"images/other/wm.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/MySQL_Architecture.jpg","path":"images/mysql/MySQL_Architecture.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/join.jpg","path":"images/mysql/join.jpg","modified":0,"renderable":0},{"_id":"source/images/mysql/logo-mysql.png","path":"images/mysql/logo-mysql.png","modified":0,"renderable":0},{"_id":"source/images/shell/idcard_front.jpg","path":"images/shell/idcard_front.jpg","modified":0,"renderable":0},{"_id":"source/images/shell/002_supervisor_1.jpg","path":"images/shell/002_supervisor_1.jpg","modified":1,"renderable":0},{"_id":"source/images/shell/003_ffmpeg_1.jpg","path":"images/shell/003_ffmpeg_1.jpg","modified":1,"renderable":0},{"_id":"source/images/shell/001_ssh_1.jpg","path":"images/shell/001_ssh_1.jpg","modified":0,"renderable":0},{"_id":"source/images/shell/004_shell_1.jpg","path":"images/shell/004_shell_1.jpg","modified":0,"renderable":0},{"_id":"source/images/shell/005_mac_1.png","path":"images/shell/005_mac_1.png","modified":0,"renderable":0},{"_id":"source/images/shell/005_mac_2.png","path":"images/shell/005_mac_2.png","modified":0,"renderable":0},{"_id":"source/images/shell/005_mac_3.jpg","path":"images/shell/005_mac_3.jpg","modified":1,"renderable":0},{"_id":"source/images/shell/005_mac_0.jpg","path":"images/shell/005_mac_0.jpg","modified":1,"renderable":0},{"_id":"source/images/shell/005_mac_4.jpg","path":"images/shell/005_mac_4.jpg","modified":1,"renderable":0},{"_id":"source/images/other/006_encrypt_1.jpg","path":"images/other/006_encrypt_1.jpg","modified":1,"renderable":0},{"_id":"source/images/other/006_encrypt_0.jpg","path":"images/other/006_encrypt_0.jpg","modified":1,"renderable":0},{"_id":"source/images/mysql/007_mysql_0.jpg","path":"images/mysql/007_mysql_0.jpg","modified":1,"renderable":0},{"_id":"source/images/mysql/008_mysql_0.jpg","path":"images/mysql/008_mysql_0.jpg","modified":1,"renderable":0},{"_id":"source/images/mysql/009_mysql_0.jpg","path":"images/mysql/009_mysql_0.jpg","modified":1,"renderable":0},{"_id":"source/images/mysql/010_mysql_0.jpg","path":"images/mysql/010_mysql_0.jpg","modified":1,"renderable":0},{"_id":"source/images/mysql/011_mysql_0.jpg","path":"images/mysql/011_mysql_0.jpg","modified":1,"renderable":0},{"_id":"source/images/golang/012_cgo_0.jpg","path":"images/golang/012_cgo_0.jpg","modified":1,"renderable":0},{"_id":"source/images/golang/013_go_0.jpg","path":"images/golang/013_go_0.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/Goroutine & Scheduler.md","hash":"41f38d3fe43674aa65ca98f59db85f81d77563ae","modified":1614220647087},{"_id":"source/_config.yml","hash":"135508674a6df897aa5e79be171812a46c14dd06","modified":1582696898240},{"_id":"source/.DS_Store","hash":"c1bf04a053bd70f6b4cf04b59b593578cfac8c61","modified":1615354809585},{"_id":"source/CNAME","hash":"682d2eaebba01726aaf8d32981f6388716146047","modified":1603171077058},{"_id":"source/_posts/Mac下打造流畅的终端使用环境.md","hash":"335381919fa98f6b15cfc62d8cd33fd7894f7d9d","modified":1582775064080},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1587549433730},{"_id":"source/_posts/Linux下打RPM包.md","hash":"e76a111bf0e960abf88f38655c99972c903c79ae","modified":1584957215960},{"_id":"source/_posts/MySQL系列一.md","hash":"4623eaa476b94773edea70c83e7305c3363a22e8","modified":1585037407270},{"_id":"source/_posts/MySQL系列五.md","hash":"e43a60ea88d67d27607702f5207e3eb153ab3a85","modified":1585037426030},{"_id":"source/_posts/MySQL系列三.md","hash":"9fdf6cef6aead262762079ae018bcf0a652cc685","modified":1585037418130},{"_id":"source/_posts/MySQL系列四.md","hash":"b3c79d59a7978e4fe680b4b29d31635a7bcec14f","modified":1614741154374},{"_id":"source/_posts/MySQL系列二.md","hash":"fa5faf6d6d511a59ed3194dc506d0205b2f7267b","modified":1585036914440},{"_id":"source/_posts/RN中使用mobx来进行状态管理.md","hash":"ccac6a3a2f9da998d6367015f6e6e58e17007f4b","modified":1582775325760},{"_id":"source/_posts/caddy的简易使用.md","hash":"a70313dbbdd872e580852fbc3ef16065bfd88e88","modified":1582775510450},{"_id":"source/_posts/golang之cgo.md","hash":"2525b378e574555b1175896172fbc8bdf900b9b0","modified":1585199275030},{"_id":"source/_posts/ffmpeg简易介绍.md","hash":"092eef3640cf9ea297186df2e8b7701c3bd24be1","modified":1584957901080},{"_id":"source/_posts/iterm,tmux,vim的常用快捷键.md","hash":"4f3302833050c2281d5665bb6c04a949b01168fa","modified":1582774918960},{"_id":"source/_posts/golang之slice and map.md","hash":"a4f335db7216e2e3677d6dd2ce0d4ee9c7e9a3b5","modified":1585203133150},{"_id":"source/_posts/python 开发服务端.md","hash":"ffe5a023d7130bcb90ad35bada3c4e720f488ce6","modified":1582775273210},{"_id":"source/_posts/java 之 JNA.md","hash":"c7cf936f89d45758f23025fa2cf6e031b190727b","modified":1604920007372},{"_id":"source/_posts/supervisor 是基于python的进程管理工具.md","hash":"44c09a23fa7fee3be75715b4c6db06678ea4e6ef","modified":1584956943640},{"_id":"source/_posts/shell 脚本中读取参数值.md","hash":"6b5212cc9d8a00fe3fcbacd2bdddd79828d23f82","modified":1582775370350},{"_id":"source/_posts/xargs和jq.md","hash":"41e87e8e695aa86b22abf785274be0871cdae58d","modified":1582775640820},{"_id":"source/_posts/内网端口映射到外网.md","hash":"1694e938ee69c2e4ea02b2780fa866ecb67ffcaa","modified":1582774267590},{"_id":"source/_posts/传统POS流程及名词解释.md","hash":"33c790d9fe5565c5ec277625da4abecaa1e10854","modified":1603104891192},{"_id":"source/_posts/公众号web开发过程记录.md","hash":"d8fae31e9aa55112c4c34cc15d6e91ee35eeaeae","modified":1582775302430},{"_id":"source/_posts/加密算法简介.md","hash":"f8b32aa8b56656f60e74574a3f9a7e240507cf1e","modified":1582773726490},{"_id":"source/_posts/各个平台上传图片.md","hash":"d3d8b25012a60adf36e0fdfd676b0b9fe6d10a0f","modified":1582772719620},{"_id":"source/_posts/脚本跑批.md","hash":"5fa1acc2c5dd99155aad61ef5f77332093692372","modified":1585038333870},{"_id":"source/_posts/私有化的坑.md","hash":"3a6ff30bfcd584a4c2bbda8b42d6e0e669e75812","modified":1582774375700},{"_id":"source/about/index.md","hash":"2494285319044135ad6f322cdaf5fb1b72b09648","modified":1603105091019},{"_id":"source/_posts/并发模型及线程模型概述.md","hash":"a2771d8d90d5dc16a131bf711c56e153f8800f03","modified":1604919984048},{"_id":"source/images/avatar.jpg","hash":"419755f44dfcd73ed13ae43d9d74adb0b6ef4e4d","modified":1494322683000},{"_id":"source/images/ali_pay1.jpg","hash":"e148168a1ecd2047cfc4477271e0b3a2bbb95db9","modified":1494831538000},{"_id":"source/images/.DS_Store","hash":"0f0401371c1dbb99fda518cab0d5703a55415011","modified":1615201186022},{"_id":"source/images/golang/string.jpg","hash":"72570fc66f7f503c18cb18f4f9acc5abe5de683b","modified":1584941568910},{"_id":"source/images/golang/logo.jpg","hash":"f9d0fb3714e505f4e1c7bbb9e5f0db93042adb89","modified":1585203015580},{"_id":"source/images/java/jna.jpg","hash":"c37a876a1e15271d7e350f9bf1b6cda816b36749","modified":1603100124002},{"_id":"source/images/golang/goroutine.jpg","hash":"18757e32eccd45c21aec0559c0b71571bc47275f","modified":1606200502313},{"_id":"source/images/mysql/logo-mysql.png","hash":"4778178f2c8a10fef2787534f116dc258637d0b5","modified":1585037331780},{"_id":"source/images/ali_pay.jpg","hash":"6e555acc6f2b1c5f25a3dda2c4559248e7f69714","modified":1497863075000},{"_id":"source/images/wechat_pay.jpg","hash":"cb369604dbab18468279e5a3292e93c4fd47bc9a","modified":1497862984000},{"_id":"source/images/other/wm.jpg","hash":"45837871e640802ce05b3098c677be563f06103d","modified":1604919432739},{"_id":"source/images/mysql/join.jpg","hash":"85c83a6923f5feb8bdb1a4aa581fc311d499c9dd","modified":1583286332150},{"_id":"source/images/mysql/MySQL_Architecture.jpg","hash":"f528f4983b168716f13ebff749013ec986fccd58","modified":1583207535390},{"_id":"source/images/other/banner.png","hash":"a79a3cec3dba526e6c51eddc071e7267026b2b76","modified":1601774904043},{"_id":"source/images/shell/idcard_front.jpg","hash":"c75027f4ee8e541aed1508d925aaba5fb0dbf420","modified":1550718283470},{"_id":"source/images/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1583462844000},{"_id":"source/images/screenShot/iterm2_color.jpg","hash":"62a8abd33d8dbebdcc9ab53f6c4975311e3c3f41","modified":1495875048000},{"_id":"source/images/screenShot/iterm2_keymap.jpg","hash":"d0325aac666446894a687567edb5b4b5e14bad18","modified":1496384594000},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1602940783000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1602940783000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1602940783000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1602940783000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1602940783000},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1602940783000},{"_id":"themes/fluid/README_en.md","hash":"1c4c47d45746c6741167ba5e8153e235e73f7172","modified":1602940783000},{"_id":"themes/fluid/_config.yml","hash":"4c7e70668b4b88df0c89034daf9bd94ab632444f","modified":1606200585288},{"_id":"themes/fluid/package.json","hash":"e2772a7e62badea6d404887d8c2723f0fb7af07d","modified":1602940783000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1602940783000},{"_id":"themes/fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1602940783000},{"_id":"themes/fluid/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1603104373704},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1602940783000},{"_id":"themes/fluid/README.md","hash":"046950dfee8bb3934baed67678e60a002cb20c3c","modified":1602940783000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1602940783000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1602940783000},{"_id":"themes/fluid/layout/categories.ejs","hash":"6c4ab9fcdf5f7b58238bf06276b027075872c424","modified":1602940783000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1602940783000},{"_id":"themes/fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1602940783000},{"_id":"themes/fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1602940783000},{"_id":"themes/fluid/layout/index.ejs","hash":"58e994d28fd72d585d2e4c63d0c0fd3e61dd14b8","modified":1602940783000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1602940783000},{"_id":"themes/fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1602940783000},{"_id":"themes/fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1602940783000},{"_id":"themes/fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1602940783000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1602940783000},{"_id":"themes/fluid/layout/layout.ejs","hash":"92474673da8f6016be9f4c0184b746ec21954a4d","modified":1602940783000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"bccd7961fa146dd5f0d70f77e7ab94e9f58d5bd3","modified":1602940783000},{"_id":"themes/fluid/layout/post.ejs","hash":"8cbfe4dee760631df26d23c49edaab18b8340526","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1602940783000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"8f20dca8a03aefd495d0550544f25d8c6e44333e","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"55f62c4766f5d505e8307e667f83ea459b84dfb6","modified":1602940783000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"a44f0abeb75039804f33771c9c3bdeb78ed2cd7a","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"382bd3ee27bc6d90776fc9171a487ff208bc4caa","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"450918516e50065774e64cae293d39161f0ea137","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"7c40672443ba61b62b68a9aa6685ea944dbbb061","modified":1602940783000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1602940783000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1602940783000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1602940783000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1602940783000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1602940783000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1602940783000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1602940783000},{"_id":"themes/fluid/scripts/events/index.js","hash":"a6ab2c6d9f9ba58cd1fabb85c2817874246fd525","modified":1602940783000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1602940783000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"8a70f2016d9df68d29800b3bceb8f4c021158248","modified":1602940783000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1602940783000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1602940783000},{"_id":"themes/fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1602940783000},{"_id":"themes/fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1602940783000},{"_id":"themes/fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1602940783000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1602940783000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1602940783000},{"_id":"themes/fluid/source/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1581745631000},{"_id":"themes/fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1583214946290},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1602940783000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1602940783000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1602940783000},{"_id":"themes/fluid/source/img/lufei.jpg","hash":"64a7f41e948344e239872ab52a0b4d42e10e6361","modified":1582706884290},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1602940783000},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"eeb3462cbedd195156aa671fb522bebee0274b5e","modified":1602940783000},{"_id":"themes/fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1602940783000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"2b9a49594e9aea4dc8fdd606a63c8c5b9189e325","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/comments/remark42.ejs","hash":"3c254c1b7bc5a4c6bd5b724514d463608408018b","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"96d56372cad997b09c26dbd29a19f917140c6ab0","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/preset-configs.js","hash":"202459c9444b1ba967396db3625af261b0b19820","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"0250fb16c7c798afd1f7fc816163ea0728765568","modified":1602940783000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1602940783000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1602940783000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"fe96204aa2e7ee4f7f404c9e90752a8ff822d779","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"f7004d597163e0af7b9107b0be1df12f4c0a7bc0","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"4f939807936632f2ff2504f139648033aa351957","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"4304bab8ad087911cbf5025a41014fbb67f20b5a","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"1e7e4290a7653f748e0a46c81cc6aed4564f8bf4","modified":1602940783000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"ec4e9678d2f4df03b1ad773adf57acc83a947687","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"40a198e741805fdd51117bcb0d373660ab7dfdf9","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4ad804ab26bdbf5b55abbc5548b6db395cfed04","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":1602940783000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1602940783000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"2264bec80ba051a19ba80396618f3d0c22948f0b","modified":1602940783000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1602940783000},{"_id":"themes/fluid/source/img/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1583462844000},{"_id":"source/images/screenShot/iterm2_tmux_keymap.jpg","hash":"91a1ba4c89e8dd9c8036962268333b508c9264eb","modified":1496386335000},{"_id":"public/local-search.xml","hash":"5007da4dcb3c43e1942831e47bd373692c423ee5","modified":1606200934068},{"_id":"public/about/index.html","hash":"e717f6860e1f9a6e879f0f8533377f6c682a0faf","modified":1606200934068},{"_id":"public/2020/10/19/传统POS流程及名词解释/index.html","hash":"1c357bda1c2ca66971ec8068ec3dad9644628171","modified":1606200934068},{"_id":"public/2020/08/10/Goroutine & Scheduler/index.html","hash":"a38cc81c2b2d334dd1c214a0633720984a6e1643","modified":1606200934068},{"_id":"public/2020/07/08/并发模型及线程模型概述/index.html","hash":"45067ab1e6a0fa9bdd092b597f35c0f90c55c8db","modified":1606200934068},{"_id":"public/2018/10/15/java 之 JNA/index.html","hash":"3194b15e58cc26fdddb264c0c1bf8a9228069cce","modified":1606200934068},{"_id":"public/2018/09/10/golang之slice and map/index.html","hash":"754cfc8753d978559440c1ea43202649de937534","modified":1606200934068},{"_id":"public/2018/08/30/golang之cgo/index.html","hash":"64bcd7c164a515b1e6acf21be7848e458a627c7f","modified":1606200934068},{"_id":"public/2018/08/25/MySQL系列五/index.html","hash":"96ec24c24b0f94c333f4906fdd3f7fa6714724a6","modified":1606200934068},{"_id":"public/2018/08/22/MySQL系列四/index.html","hash":"a74db66400359d7373efdf37eb03540c3505a046","modified":1606200934068},{"_id":"public/2018/08/18/MySQL系列三/index.html","hash":"811ec2c00a63caf3df351f055eb6e3803f55c974","modified":1606200934068},{"_id":"public/2018/08/15/MySQL系列二/index.html","hash":"3dc358757db68a6c512ebace49458263ba366856","modified":1606200934068},{"_id":"public/2018/08/12/MySQL系列一/index.html","hash":"9a6b62bf818452cd892561c9b2252c0244c2d041","modified":1606200934068},{"_id":"public/2018/03/21/脚本跑批/index.html","hash":"0a5355959ab026a3d2ed2370bcc29a24023e6fa3","modified":1606200934068},{"_id":"public/2017/08/28/加密算法简介/index.html","hash":"91f3b686387a68e61499ba50aedbd15e0eca5d80","modified":1606200934068},{"_id":"public/2017/08/21/内网端口映射到外网/index.html","hash":"e29b7e54ed0290ec985ab12a524095c724a0262a","modified":1606200934068},{"_id":"public/2017/07/20/私有化的坑/index.html","hash":"8fb41107e13d6b873d289ec4600c455e4a5d9be3","modified":1606200934068},{"_id":"public/2017/07/05/xargs和jq/index.html","hash":"abdd7ada39877e71846fc3194af112054122aa5a","modified":1606200934068},{"_id":"public/2017/06/30/caddy的简易使用/index.html","hash":"aa7485ea5de560c20c1511a0b281b865a2c9a009","modified":1606200934068},{"_id":"public/2017/06/19/公众号web开发过程记录/index.html","hash":"a170855d2d165836166cd4e85d6df0fedb9e5589","modified":1606200934068},{"_id":"public/2017/06/19/python 开发服务端/index.html","hash":"2e17e8bc2e5f46a634ca6209a639492d0c58ffc9","modified":1606200934068},{"_id":"public/2017/06/13/RN中使用mobx来进行状态管理/index.html","hash":"77d60cf9c34d84defc21dbf0455cf98282cc6724","modified":1606200934068},{"_id":"public/2017/06/13/各个平台上传图片/index.html","hash":"1bdcba4151e5823b1b9985967346ab0cd7f9794b","modified":1606200934068},{"_id":"public/2017/06/02/iterm,tmux,vim的常用快捷键/index.html","hash":"b427efe4061ef339e8d7eccac211212643df431d","modified":1606200934068},{"_id":"public/2017/05/27/Mac下打造流畅的终端使用环境/index.html","hash":"75300503b7e34391f43b60c38854c1e0aac90069","modified":1606200934068},{"_id":"public/2017/05/25/shell 脚本中读取参数值/index.html","hash":"782a261b7ea03ee9f4f793af06d3dd44222f35ee","modified":1606200934068},{"_id":"public/2017/05/22/ffmpeg简易介绍/index.html","hash":"0eb8ab662a0aabbf1f439567066646654efa92be","modified":1606200934068},{"_id":"public/2017/05/15/Linux下打RPM包/index.html","hash":"116de35d7f1f6e1625d706841b131659dae6a9c9","modified":1606200934068},{"_id":"public/2017/04/28/supervisor 是基于python的进程管理工具/index.html","hash":"c29a9cc4e8cb6546ed19094eaa2905539f4d988f","modified":1606200934068},{"_id":"public/archives/index.html","hash":"71048c6f2b368c6f908a9f32d0166378061e0806","modified":1606200934068},{"_id":"public/archives/page/2/index.html","hash":"62f64724dc739b4869b9123bdda387c0e6b6bff1","modified":1606200934068},{"_id":"public/archives/page/3/index.html","hash":"e26d8ee2104e0b773e2ddb3997c81b6b69a5fd00","modified":1606200934068},{"_id":"public/archives/page/4/index.html","hash":"2c8d04298713191f57914b62fe54a5f76385b55f","modified":1606200934068},{"_id":"public/archives/page/5/index.html","hash":"0549969f0834377b0be31985e0bf6d625fbe9e7c","modified":1606200934068},{"_id":"public/archives/2017/index.html","hash":"e4caec325835cf4f495dd7a7de2c065d729cdec5","modified":1606200934068},{"_id":"public/archives/2017/page/2/index.html","hash":"f2577747ae6749a5352eff94990607d10baae0e1","modified":1606200934068},{"_id":"public/archives/2017/page/3/index.html","hash":"666d51fb9a52df0d6586c74746b0e3f7fd98b797","modified":1606200934068},{"_id":"public/archives/2017/04/index.html","hash":"a2f25034cde26344cfd09dbc8dd1545be0247b5b","modified":1606200934068},{"_id":"public/archives/2017/05/index.html","hash":"17f496b6e6610c25be364098d620986a66ddd35d","modified":1606200934068},{"_id":"public/archives/2017/06/index.html","hash":"c8f4fd9fa464e111107e7a25026ecc1fec691a36","modified":1606200934068},{"_id":"public/archives/2017/07/index.html","hash":"cec4b93c518f5e8c4c170dd78502ce8c40eec2ff","modified":1606200934068},{"_id":"public/archives/2017/08/index.html","hash":"51668da4750418c982f439013e0dc8189d0cca66","modified":1606200934068},{"_id":"public/archives/2018/index.html","hash":"abe452c1fdc92a2e0280193387756875efe3e2dd","modified":1606200934068},{"_id":"public/archives/2018/page/2/index.html","hash":"00d2da9aced795ea6e9d7580ac71a1c03cb59015","modified":1606200934068},{"_id":"public/archives/2018/03/index.html","hash":"67d5b00a395ed10280707bf0a63edd5e47ef385e","modified":1606200934068},{"_id":"public/archives/2018/08/index.html","hash":"d662b95d91a75ef09590114f4a337880f27d3157","modified":1606200934068},{"_id":"public/archives/2018/09/index.html","hash":"1c9bf7d8ca39824d69728a879f3dbb0898a7ad06","modified":1606200934068},{"_id":"public/archives/2018/10/index.html","hash":"60d2ef6f32e29a6bf5e7a1e9f5fc95c0056f71a6","modified":1606200934068},{"_id":"public/archives/2020/index.html","hash":"fadbcc01d8dd4d8cc5508609ac85515eeca140ae","modified":1606200934068},{"_id":"public/archives/2020/07/index.html","hash":"a30e032cf3cac5268b8cedbec8096955f7677211","modified":1606200934068},{"_id":"public/archives/2020/08/index.html","hash":"654c022113231e8dd437214a2d2cfc49b95576f9","modified":1606200934068},{"_id":"public/archives/2020/10/index.html","hash":"422dcb486f93e34e58a53746bccb2d6eb4c1bf65","modified":1606200934068},{"_id":"public/categories/开发效率/index.html","hash":"848de0b716c8a98140bb433611e9711996666236","modified":1606200934068},{"_id":"public/categories/golang/index.html","hash":"b7a024615a80fd1949fe40db60cc239138a8810f","modified":1606200934068},{"_id":"public/categories/Linux/index.html","hash":"255c025c1200545f7ed1a964845a22d0446ea83d","modified":1606200934068},{"_id":"public/categories/DB/index.html","hash":"1dc4b150c0a1bb16991dd6f0d00027fa58013779","modified":1606200934068},{"_id":"public/categories/前端/index.html","hash":"ba44354a9edea9bc385604a358ee4933ac7129bb","modified":1606200934068},{"_id":"public/categories/开源工具/index.html","hash":"1b0b440019ee4d50a82923f82190d3b41dde1550","modified":1606200934068},{"_id":"public/categories/Java/index.html","hash":"9fd8148691fbaac5b60c186b6dce7e995ec16a86","modified":1606200934068},{"_id":"public/categories/Python/index.html","hash":"fac28a90613764bb1784dafd9dc4edb4e0823cb6","modified":1606200934068},{"_id":"public/categories/随笔/index.html","hash":"293c2d00ffc685f72962a238543b2dccc85bde39","modified":1606200934068},{"_id":"public/categories/算法/index.html","hash":"2181cd2b27c44a0fa5c0b90607a4e05d3516fd4a","modified":1606200934068},{"_id":"public/index.html","hash":"6192757a6ad569e53f33d609e5ad42c1e736ec10","modified":1606200934068},{"_id":"public/page/2/index.html","hash":"8fff87d110be9d39db163aa58e913642de511b1b","modified":1606200934068},{"_id":"public/page/3/index.html","hash":"658a8e00dbc102124503c71c9d8a194fbca2eba0","modified":1606200934068},{"_id":"public/page/4/index.html","hash":"bda41448ac25d363a61b185c0185ef484aa7f172","modified":1606200934068},{"_id":"public/page/5/index.html","hash":"08a91b503460a1a3d713044756c2d9eb4aba412f","modified":1606200934068},{"_id":"public/tags/开发效率/index.html","hash":"65dcb5d4b0fd566635613029be751b1ede1ffbbc","modified":1606200934068},{"_id":"public/tags/golang/index.html","hash":"00b80d574d297e345ee1f033f45af07e6c4dffc0","modified":1606200934068},{"_id":"public/tags/Linux/index.html","hash":"a59922b4dd315086478eb8b823f328c505ff1fb5","modified":1606200934068},{"_id":"public/tags/mysql/index.html","hash":"28c94fbbe1e899cf5abdbf2f393597aae274d89c","modified":1606200934068},{"_id":"public/tags/react-native/index.html","hash":"b0cecc547b8faa84a679dc9048f8cbf14dcfa28d","modified":1606200934068},{"_id":"public/tags/扩展/index.html","hash":"8ad7fb508ae97b9cbfc71a2305fecd82c2657169","modified":1606200934068},{"_id":"public/tags/golang-cgo/index.html","hash":"9ecfc357300b144bc847db4ca169cb224c1fc675","modified":1606200934068},{"_id":"public/tags/jna/index.html","hash":"f2fcd5286b314bf05d18477901a0e16d73fdfdc8","modified":1606200934068},{"_id":"public/tags/Python/index.html","hash":"79c7ca80392a9d302f3a456b78a7ca7de29e6c60","modified":1606200934068},{"_id":"public/tags/shell/index.html","hash":"ad046456921287a7379107f01d090693e04d50b8","modified":1606200934068},{"_id":"public/tags/react-web/index.html","hash":"bdd8969db8c1883f25c5a721e09f935ec674ea52","modified":1606200934068},{"_id":"public/tags/随笔/index.html","hash":"e36b834ebd786ef98aa7ad9cb1a48e482a740c05","modified":1606200934068},{"_id":"public/tags/index.html","hash":"ac29940a881180bc9020afddd74e79b7e80f6aa2","modified":1606200934068},{"_id":"public/404.html","hash":"9ea735bd3263b3bd7287730a354404d68aa6a5c7","modified":1606200934068},{"_id":"public/categories/index.html","hash":"d13d229ac112fdc6dab235ac0aea019e99ea922f","modified":1606200934068},{"_id":"public/links/index.html","hash":"4ff199500d1c545de2cc584d43600f73b3927d5b","modified":1606200934068},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1606200934068},{"_id":"public/img/apple-touch-icon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1606200934068},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1606200934068},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1606200934068},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1606200934068},{"_id":"public/img/lufei.jpg","hash":"64a7f41e948344e239872ab52a0b4d42e10e6361","modified":1606200934068},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1606200934068},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1606200934068},{"_id":"public/CNAME","hash":"682d2eaebba01726aaf8d32981f6388716146047","modified":1606200934068},{"_id":"public/images/ali_pay1.jpg","hash":"e148168a1ecd2047cfc4477271e0b3a2bbb95db9","modified":1606200934068},{"_id":"public/images/avatar.jpg","hash":"419755f44dfcd73ed13ae43d9d74adb0b6ef4e4d","modified":1606200934068},{"_id":"public/images/golang/goroutine.jpg","hash":"18757e32eccd45c21aec0559c0b71571bc47275f","modified":1606200934068},{"_id":"public/images/golang/string.jpg","hash":"72570fc66f7f503c18cb18f4f9acc5abe5de683b","modified":1606200934068},{"_id":"public/images/golang/logo.jpg","hash":"f9d0fb3714e505f4e1c7bbb9e5f0db93042adb89","modified":1606200934068},{"_id":"public/images/java/jna.jpg","hash":"c37a876a1e15271d7e350f9bf1b6cda816b36749","modified":1606200934068},{"_id":"public/images/mysql/logo-mysql.png","hash":"4778178f2c8a10fef2787534f116dc258637d0b5","modified":1606200934068},{"_id":"public/images/ali_pay.jpg","hash":"6e555acc6f2b1c5f25a3dda2c4559248e7f69714","modified":1606200934068},{"_id":"public/images/wechat_pay.jpg","hash":"cb369604dbab18468279e5a3292e93c4fd47bc9a","modified":1606200934068},{"_id":"public/images/other/wm.jpg","hash":"45837871e640802ce05b3098c677be563f06103d","modified":1606200934068},{"_id":"public/images/mysql/MySQL_Architecture.jpg","hash":"f528f4983b168716f13ebff749013ec986fccd58","modified":1606200934068},{"_id":"public/images/mysql/join.jpg","hash":"85c83a6923f5feb8bdb1a4aa581fc311d499c9dd","modified":1606200934068},{"_id":"public/js/color-schema.js","hash":"8a70f2016d9df68d29800b3bceb8f4c021158248","modified":1606200934068},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1606200934068},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1606200934068},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1606200934068},{"_id":"public/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1606200934068},{"_id":"public/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1606200934068},{"_id":"public/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1606200934068},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1606200934068},{"_id":"public/css/main.css","hash":"4c092bcb04cb3793cac7f62efc49bed5b4fa4d76","modified":1606200934068},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1606200934068},{"_id":"public/images/other/banner.png","hash":"a79a3cec3dba526e6c51eddc071e7267026b2b76","modified":1606200934068},{"_id":"public/images/shell/idcard_front.jpg","hash":"c75027f4ee8e541aed1508d925aaba5fb0dbf420","modified":1606200934068},{"_id":"public/images/screenShot/iterm2_color.jpg","hash":"62a8abd33d8dbebdcc9ab53f6c4975311e3c3f41","modified":1606200934068},{"_id":"public/img/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1606200934068},{"_id":"public/images/coloradoablaze.jpg","hash":"4393270a29bd3348116b14c5ce296fc2c4a5431f","modified":1606200934068},{"_id":"public/images/screenShot/iterm2_keymap.jpg","hash":"d0325aac666446894a687567edb5b4b5e14bad18","modified":1606200934068},{"_id":"public/images/screenShot/iterm2_tmux_keymap.jpg","hash":"91a1ba4c89e8dd9c8036962268333b508c9264eb","modified":1606200934068},{"_id":"source/_posts/001_ssh免密登录.md","hash":"db70e8f74f668887ac111eb6a1875eb22a3ec4bc","modified":1615272988938},{"_id":"source/_posts/Golang GC.md","hash":"61069491c5ed57c1c43f5f32ed1554b529c3dbe1","modified":1606457438836},{"_id":"source/images/shell/001_shell_1.jpg","hash":"ab615e950871cfb6c518a9b2e1e41db8dbc166a5","modified":1615199786171},{"_id":"source/_posts/002_supervisor.md","hash":"05224c9fd6eacac1b458d4a7e9fd832270f5fa01","modified":1615201236872},{"_id":"source/images/shell/002_supervisor_1.jpg","hash":"88d25cfdf78288e74d4cd1884a3aafb27bb77f6c","modified":1615355143322},{"_id":"source/_posts/003_ffmpeg.md","hash":"47e55c1953d2649bebb5a3845832344fcdf2cecf","modified":1615260190294},{"_id":"source/images/shell/003_ffmpeg_1.jpg","hash":"7f61a62def406266dd256f49b69bf05fcbd2a0ad","modified":1615355063588},{"_id":"source/_posts/004_shell笔记.md","hash":"ac8a9614b3d8b2da0e0d8ab428d9d8f01e302396","modified":1615271504371},{"_id":"source/images/shell/001_ssh_1.jpg","hash":"ab615e950871cfb6c518a9b2e1e41db8dbc166a5","modified":1615199786171},{"_id":"source/images/shell/004_shell_1.jpg","hash":"33e92900c09d9e06c3bd0d64247cbf9418e97d3d","modified":1615271442432},{"_id":"source/_posts/005_mac效率.md","hash":"729766a4f06574f048783066e9ca1f86c3542e3a","modified":1615354850805},{"_id":"source/images/shell/005_mac_1.png","hash":"b8473410439ab28aa8286e85328a32c6268c784e","modified":1615343529502},{"_id":"source/images/shell/005_mac_2.png","hash":"c7a39b21a01593f67761d7a49c890f0300fa41ef","modified":1615344336899},{"_id":"source/images/shell/005_mac_0.jpg","hash":"57eaf371bca098cf239ee43ec42d36dd0c8db968","modified":1615354805391},{"_id":"source/images/shell/005_mac_3.jpg","hash":"62a8abd33d8dbebdcc9ab53f6c4975311e3c3f41","modified":1495875048000},{"_id":"source/images/shell/005_mac_4.jpg","hash":"6a38bc70b2a3d5b4906c9691f22a0c14015ebc80","modified":1615352361575}],"Category":[{"name":"开发效率","_id":"ckhvmkcwn0003dwym311x62d8"},{"name":"golang","_id":"ckhvmkcwr0008dwym98tc83k7"},{"name":"Linux","_id":"ckhvmkcwu000edwymceidbx4g"},{"name":"DB","_id":"ckhvmkcww000kdwym8d6j6pju"},{"name":"前端","_id":"ckhvmkcx9001jdwym2hz153lr"},{"name":"开源工具","_id":"ckhvmkcxc001sdwymfdrn180a"},{"name":"Java","_id":"ckhvmkcxj0028dwym43x6g8cs"},{"name":"Python","_id":"ckhvmkcxl002fdwym0djuffq4"},{"name":"随笔","_id":"ckhvmkcxn002pdwymb8e95evh"},{"name":"算法","_id":"ckhvmkcxo002udwymdah8hon8"}],"Data":[],"Page":[{"title":"关于我","date":"2020-10-19T10:34:00.000Z","banner_img":"/images/coloradoablaze.jpg","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-10-19 18:34:00\nbanner_img: /images/coloradoablaze.jpg\n---\n","updated":"2020-10-19T10:58:11.019Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckhvmkcwe0000dwymanv12l67","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"golang之goroutine","date":"2020-08-10T12:40:22.000Z","index_img":["/images/golang/goroutine.jpg"],"_content":"\n### Goroutine & Scheduler\n\n在上一篇的[并发模型和线程模型概述]()中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。\n\n每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。\n\n在了解golang的scheduler之前，我们先了解下os scheduler。\n\n#### os scheduler\n\n调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备\n\nos scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。\n\n当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。\n\n#### Go scheduler\n\n今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从[Go调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/) 了解\n\n##### G-P-M 模型\n\n每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。\n\n先来了解下G-P- M\n\n- G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。\n- M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。\n- P：Processor，表示逻辑处理器。\n\n在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。\n\n##### G-P-M模型调度\n\n根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。\n\n当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。\n\n如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为\n\nGo runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：\n\n- blocking syscall (for example opening a file)\n- network input\n- channel operations\n- primitives in the sync package\n\n这四种场景又可归类为两种类型：\n\n1. 用户态阻塞/唤醒\n\n   当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由`_Gruning`变为`_Gwaitting`，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。\n\n2. 系统调用阻塞\n\n   当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在`_Gsyscall`状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。\n\n更多的调度过程可参考[理解golang调度之二 ：Go调度器](https://juejin.cn/post/6844903846825705485)含图解\n\n#### 工作负载\n\n如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。\n\n- **CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。\n- **IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。\n\n**cpu-bound的工作负载，你需要并行去使用并发**。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。\n\n**在IO-Bound的workloads里，你不需要并行去使用并发**。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。\n\n#### 并发和并行\n\n| 类型      | 线程数 | 结论                                       | 原因                                                         |\n| --------- | ------ | ------------------------------------------ | ------------------------------------------------------------ |\n| CPU密集型 | 1      | 起一个goroutine，性能要好于起多个goroutine | 1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗 |\n| CPU密集型 | 大于1  | 起多个goroutine，性能要好于起一个goroutine | 多个OS线程中可以并行计算。收益大于goroutine上下文切换        |\n| IO密集型  | 1      | 起多个goroutine，性能高于起一个goroutine   | 1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做 |\n| IO密集型  | 大于1  | 起多个goroutine，性能高于起一个goroutine   | 多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。 |\n\n该表格结论来自于[理解golang调度之三：并发](https://juejin.im/post/6844903847568080904)\n\n参考：\n\nhttps://qcrao.com/2019/09/02/dive-into-go-scheduler/\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\nhttps://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\n\nhttps://www.cnblogs.com/jiujuan/p/12735559.html\n\n","source":"_posts/Goroutine & Scheduler.md","raw":"---\ntitle: golang之goroutine\ndate: 2020-08-10 20:40:22\nindex_img:\n- /images/golang/goroutine.jpg\ntags: \n- golang\ncategories:\n- golang\n---\n\n### Goroutine & Scheduler\n\n在上一篇的[并发模型和线程模型概述]()中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。\n\n每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。\n\n在了解golang的scheduler之前，我们先了解下os scheduler。\n\n#### os scheduler\n\n调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备\n\nos scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。\n\n当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。\n\n#### Go scheduler\n\n今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从[Go调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/) 了解\n\n##### G-P-M 模型\n\n每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。\n\n先来了解下G-P- M\n\n- G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。\n- M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。\n- P：Processor，表示逻辑处理器。\n\n在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。\n\n##### G-P-M模型调度\n\n根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。\n\n当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。\n\n如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为\n\nGo runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：\n\n- blocking syscall (for example opening a file)\n- network input\n- channel operations\n- primitives in the sync package\n\n这四种场景又可归类为两种类型：\n\n1. 用户态阻塞/唤醒\n\n   当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由`_Gruning`变为`_Gwaitting`，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。\n\n2. 系统调用阻塞\n\n   当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在`_Gsyscall`状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。\n\n更多的调度过程可参考[理解golang调度之二 ：Go调度器](https://juejin.cn/post/6844903846825705485)含图解\n\n#### 工作负载\n\n如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。\n\n- **CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。\n- **IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。\n\n**cpu-bound的工作负载，你需要并行去使用并发**。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。\n\n**在IO-Bound的workloads里，你不需要并行去使用并发**。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。\n\n#### 并发和并行\n\n| 类型      | 线程数 | 结论                                       | 原因                                                         |\n| --------- | ------ | ------------------------------------------ | ------------------------------------------------------------ |\n| CPU密集型 | 1      | 起一个goroutine，性能要好于起多个goroutine | 1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗 |\n| CPU密集型 | 大于1  | 起多个goroutine，性能要好于起一个goroutine | 多个OS线程中可以并行计算。收益大于goroutine上下文切换        |\n| IO密集型  | 1      | 起多个goroutine，性能高于起一个goroutine   | 1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做 |\n| IO密集型  | 大于1  | 起多个goroutine，性能高于起一个goroutine   | 多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。 |\n\n该表格结论来自于[理解golang调度之三：并发](https://juejin.im/post/6844903847568080904)\n\n参考：\n\nhttps://qcrao.com/2019/09/02/dive-into-go-scheduler/\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\nhttps://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\n\nhttps://www.cnblogs.com/jiujuan/p/12735559.html\n\n","slug":"Goroutine & Scheduler","published":1,"updated":"2021-02-25T02:37:27.087Z","_id":"ckhvmkcwm0002dwym4gq4a8rw","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Goroutine-amp-Scheduler\"><a href=\"#Goroutine-amp-Scheduler\" class=\"headerlink\" title=\"Goroutine &amp; Scheduler\"></a>Goroutine &amp; Scheduler</h3><p>在上一篇的<a href=\"\">并发模型和线程模型概述</a>中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。</p>\n<p>每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。</p>\n<p>在了解golang的scheduler之前，我们先了解下os scheduler。</p>\n<h4 id=\"os-scheduler\"><a href=\"#os-scheduler\" class=\"headerlink\" title=\"os scheduler\"></a>os scheduler</h4><p>调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备</p>\n<p>os scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。</p>\n<p>当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。</p>\n<h4 id=\"Go-scheduler\"><a href=\"#Go-scheduler\" class=\"headerlink\" title=\"Go scheduler\"></a>Go scheduler</h4><p>今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从<a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">Go调度器</a> 了解</p>\n<h5 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h5><p>每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。</p>\n<p>先来了解下G-P- M</p>\n<ul>\n<li>G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。</li>\n<li>M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。</li>\n<li>P：Processor，表示逻辑处理器。</li>\n</ul>\n<p>在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。</p>\n<h5 id=\"G-P-M模型调度\"><a href=\"#G-P-M模型调度\" class=\"headerlink\" title=\"G-P-M模型调度\"></a>G-P-M模型调度</h5><p>根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。</p>\n<p>当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。</p>\n<p>如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为</p>\n<p>Go runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：</p>\n<ul>\n<li>blocking syscall (for example opening a file)</li>\n<li>network input</li>\n<li>channel operations</li>\n<li>primitives in the sync package</li>\n</ul>\n<p>这四种场景又可归类为两种类型：</p>\n<ol>\n<li><p>用户态阻塞/唤醒</p>\n<p>当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。</p>\n</li>\n<li><p>系统调用阻塞</p>\n<p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在<code>_Gsyscall</code>状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p>\n</li>\n</ol>\n<p>更多的调度过程可参考<a href=\"https://juejin.cn/post/6844903846825705485\">理解golang调度之二 ：Go调度器</a>含图解</p>\n<h4 id=\"工作负载\"><a href=\"#工作负载\" class=\"headerlink\" title=\"工作负载\"></a>工作负载</h4><p>如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。</p>\n<ul>\n<li>**CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。</li>\n<li>**IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。</li>\n</ul>\n<p><strong>cpu-bound的工作负载，你需要并行去使用并发</strong>。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。</p>\n<p><strong>在IO-Bound的workloads里，你不需要并行去使用并发</strong>。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。</p>\n<h4 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>线程数</th>\n<th>结论</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU密集型</td>\n<td>1</td>\n<td>起一个goroutine，性能要好于起多个goroutine</td>\n<td>1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗</td>\n</tr>\n<tr>\n<td>CPU密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能要好于起一个goroutine</td>\n<td>多个OS线程中可以并行计算。收益大于goroutine上下文切换</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。</td>\n</tr>\n</tbody></table>\n<p>该表格结论来自于<a href=\"https://juejin.im/post/6844903847568080904\">理解golang调度之三：并发</a></p>\n<p>参考：</p>\n<p><a href=\"https://qcrao.com/2019/09/02/dive-into-go-scheduler/\">https://qcrao.com/2019/09/02/dive-into-go-scheduler/</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n<p><a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</a></p>\n<p><a href=\"https://www.cnblogs.com/jiujuan/p/12735559.html\">https://www.cnblogs.com/jiujuan/p/12735559.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Goroutine-amp-Scheduler\"><a href=\"#Goroutine-amp-Scheduler\" class=\"headerlink\" title=\"Goroutine &amp; Scheduler\"></a>Goroutine &amp; Scheduler</h3><p>在上一篇的<a href=\"\">并发模型和线程模型概述</a>中我们了解到线程模型的分类。同时也知道了线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。</p>\n<p>每个程序启动的时候，都会创建一个初始进程，并启动一个线程。而线程可以取创建更多的线程。线程可以独立的执行。CPU 在这一层进行调度，而非进程。</p>\n<p>在了解golang的scheduler之前，我们先了解下os scheduler。</p>\n<h4 id=\"os-scheduler\"><a href=\"#os-scheduler\" class=\"headerlink\" title=\"os scheduler\"></a>os scheduler</h4><p>调度是一个非常广泛的概念，在很多领域中都会使用调度这个术语，在计算机科学中，调度就是将一种任务分配给资源的方法。调度的核心就是对有限资源进行分配以实现最大化资源利用率或者降低系统的尾延迟，调度系统面对的就是资源的需求和供给不平衡的问题。任务可能是计算机任务，如线程、进程或者数据流，这些任务会被调度到硬件资源上执行。例如CPU等硬件设备</p>\n<p>os scheduler 保证如果有可以执行的线程时，就不会让CPU闲着。并且还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。</p>\n<p>当然操作系统的调度器是十分复杂，它必须要考虑到底层的硬件结构，包括但不限于处理器数和内核数，cpu cache和NUMA。如果没有这些东西，调度器就没办法尽可能有效的工作。</p>\n<h4 id=\"Go-scheduler\"><a href=\"#Go-scheduler\" class=\"headerlink\" title=\"Go scheduler\"></a>Go scheduler</h4><p>今天的Go语言调度器有着非常优异的性能，但是在最初的调度器不仅实现非常简陋，也无法支撑高并发的服务。调度器经过几个大版本的迭代才有今天的优异性能。对于之前的调度器不做过多的赘述，我们主要学习下在go1.12之后基于抢占式的调度器。其他的调度可以从<a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">Go调度器</a> 了解</p>\n<h5 id=\"G-P-M-模型\"><a href=\"#G-P-M-模型\" class=\"headerlink\" title=\"G-P-M 模型\"></a>G-P-M 模型</h5><p>每个OS线程都有一个固定大小的内存块（一般是2M）来做栈，这个栈会用来存储当前正在被调用或者挂起的函数的内部变量。这个固定大小的栈同时很大又很小。因为2M的栈对于小小的Goroutine来说是很大的内存浪费，对于一些复杂的任务来说又显得太小。因此，Go语言做了自己的线程。Goroutine的栈初始仅为2K，随着任务执行按需增长，最大可达1G，完全由Go自己的调度器GoScheduler来调度。此外G C还会周期性的将不在使用的内存回收，收缩栈空间。</p>\n<p>先来了解下G-P- M</p>\n<ul>\n<li>G：表示Gorutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。</li>\n<li>M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环。</li>\n<li>P：Processor，表示逻辑处理器。</li>\n</ul>\n<p>在Go程序启动，主机上定义的每一个虚拟内核都会为它分配一个逻辑处理器(P)，比如我的机器上有4个物理核，每个物理核上有两个硬件线程（超线程），那么Go程序会分配4*2=8个逻辑处理器（P）。每个P会分配一个OS线程（M），这个现场时OS来处理，并且OS还负责把现场放置到Core上去执行。这意味着Go程序在我的机器上有8个可用的线程执行，每个线程单独连到一个P上。G并非执行体，每个G都要绑定到P才能被调度执行。</p>\n<h5 id=\"G-P-M模型调度\"><a href=\"#G-P-M模型调度\" class=\"headerlink\" title=\"G-P-M模型调度\"></a>G-P-M模型调度</h5><p>根据G- P- M模型我们知道，G的数量是可以成千上万个的。而P和M是和硬件相关的。所以延伸出两种用来保存G的任务队列：一种是Global任务队列，一种是每个P维护Local任务队列。</p>\n<p>当通过go 关键字创建一个新的Goroutine的时候，它会优先被放入P的本地队列。为了允许Goroutine，M需要持有一个P，接着M会启动一个OS线程，循环从P的本地队列取出一个Goroutine并执行。当M执行完了当前P的Local队列里所有的G后，P也不会就这个闲下来，它会先尝试从Global队列寻找G来执行，如果Global队列为空，它会随机挑选另外一个P，从它的队列里拿走一半的G到自己的队列中执行。</p>\n<p>如果一切正常，调度器会以上述的那种方式顺畅的运行，但是这个世界没这么美好，总有意外发生，以下分析Goroutine在两种例外情况下的行为</p>\n<p>Go runtime 会在下面的 Goroutine 被阻塞的情况下运行另外一个 Goroutine：</p>\n<ul>\n<li>blocking syscall (for example opening a file)</li>\n<li>network input</li>\n<li>channel operations</li>\n<li>primitives in the sync package</li>\n</ul>\n<p>这四种场景又可归类为两种类型：</p>\n<ol>\n<li><p>用户态阻塞/唤醒</p>\n<p>当 Goroutine 因为 channel 操作或者 network I/O 而阻塞时（实际上 Golang 已经用 netpoller 实现了 Goroutine 网络 I/O 阻塞不会导致 M 被阻塞，仅阻塞 G，这里仅仅是举个栗子），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq)，该 G 的状态由<code>_Gruning</code>变为<code>_Gwaitting</code>，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读/写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global 队列。</p>\n</li>\n<li><p>系统调用阻塞</p>\n<p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在<code>_Gsyscall</code>状态，M 也处于 block on syscall 状态，此时的 M 可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它 idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p>\n</li>\n</ol>\n<p>更多的调度过程可参考<a href=\"https://juejin.cn/post/6844903846825705485\">理解golang调度之二 ：Go调度器</a>含图解</p>\n<h4 id=\"工作负载\"><a href=\"#工作负载\" class=\"headerlink\" title=\"工作负载\"></a>工作负载</h4><p>如何知道无序执行(并发)是可行的呢？了解所处理问题的工作负载(workload)是一个起点。有两种类型的工作负载在并发的时候要考虑到。</p>\n<ul>\n<li>**CPU密集(CPU-Bound)**：这种工作负载情况不会有Goroutines自动切换到waiting状态的情况，也不会有自动从waiting状态切到其他状态的情况。这种情况发生在进行持续计算的时候。线程计算Pi值就是CPU-Bound。</li>\n<li>**IO密集(IO-Bound)**：这种工作负载会导致Goroutines自动进入等待状态。这种工作发生在持续地请求网络资源、或者是进行系统调用、或者是等待事件发生的情况。一个Goroutines需要读文件就是IO-Bound。我把同步事件(mutexes，atomic)类似导致Goroutine等待的情况归到此类。</li>\n</ul>\n<p><strong>cpu-bound的工作负载，你需要并行去使用并发</strong>。一个单独的OS/硬件线程处理多个Goroutines效率很低，因为Goroutines在这个工作负载里不会主动进入或者是离开等待状态。Goroutines数多于OS/硬件线程数的时候会降低工作负载的执行速度，因为从OS线程换上或者是换下Goroutines会有延迟(切换的时间)。上下文切换会在workload里创建出“一切都停止”事件，因为在切换的时候你的所有workload都不会执行。</p>\n<p><strong>在IO-Bound的workloads里，你不需要并行去使用并发</strong>。一个单独OS/硬件线程可以有效率地处理多个Goroutines，因为Goroutines作为它自己workload的一部分可以自动进入或者离开等待状态(waiting)。Goroutines数量多于OS/硬件线程数可以加速workload的执行,因为Goroutines在OS线程上切换不会创建“一切都停止”事件。你的workload会自然停止并且这会让一个不同的Goroutine去有效率地使用相同的OS/硬件线程，而不是让OS/硬件线程空闲下来。</p>\n<h4 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>线程数</th>\n<th>结论</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU密集型</td>\n<td>1</td>\n<td>起一个goroutine，性能要好于起多个goroutine</td>\n<td>1个OS线程中，无法并行计算。多个goroutine 上下文切换会增加性能损耗</td>\n</tr>\n<tr>\n<td>CPU密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能要好于起一个goroutine</td>\n<td>多个OS线程中可以并行计算。收益大于goroutine上下文切换</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>1个OS线程中，多个goroutine都能有效共享一个OS线程，每个goroutine能够自动进行上下文切换，OS线程一直有事情做</td>\n</tr>\n<tr>\n<td>IO密集型</td>\n<td>大于1</td>\n<td>起多个goroutine，性能高于起一个goroutine</td>\n<td>多个OS线程和1个OS线程相比差距不大，额外的OS/硬件线程并没有提供更好的性能。这是因为更多的goroutine会进入等待状态。</td>\n</tr>\n</tbody></table>\n<p>该表格结论来自于<a href=\"https://juejin.im/post/6844903847568080904\">理解golang调度之三：并发</a></p>\n<p>参考：</p>\n<p><a href=\"https://qcrao.com/2019/09/02/dive-into-go-scheduler/\">https://qcrao.com/2019/09/02/dive-into-go-scheduler/</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n<p><a href=\"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/\">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/</a></p>\n<p><a href=\"https://www.cnblogs.com/jiujuan/p/12735559.html\">https://www.cnblogs.com/jiujuan/p/12735559.html</a></p>\n"},{"title":"java 之 JNA","date":"2018-10-15T11:00:12.000Z","index_img":["/images/java/jna.jpg"],"_content":"\n我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步[官方文档](https://github.com/java-native-access/jna)。\n\n不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：\n\n| C基本类型 |    长度     |  Java类型  |       Windows类型       |\n| :-------: | :---------: | :--------: | :---------------------: |\n|   char    |   8位整型   |    byte    |       BYTE、TCHAR       |\n|   short   |  16位整型   |   short    |          WORD           |\n|  wchar_t  | 16/32位字符 |    char    |          TCHAR          |\n|    int    |  32位整型   |    int     |          DWORD          |\n|    int    |   布尔值    |  boolean   |          BOOL           |\n|   long    | 32/64位整型 | NativeLong |          LONG           |\n| long long |  64位整型   |    long    |         __int64         |\n|   float   | 32位浮点型  |   float    |                         |\n|  double   | 64位浮点型  |   double   |                         |\n|   char*   |   C字符串   |   String   |         LPTCSTR         |\n|   void*   |    指针     |  Pointer   | LPVOID、HANDLE、LP*XXX* |\n\n#### 开发过程\n\n我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。\n\n##### 定义一个接口和编写相应的结构体映射\n\n定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Library;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.Structure;\nimport com.sun.jna.Structure.ByValue;\nimport com.sun.jna.ptr.IntByReference;\nimport com.sun.jna.win32.StdCallLibrary.StdCallCallback;\nimport com.sun.jna.Callback;\n\npublic interface NVSSDK extends Library {\n  public static class PicTime extends Structure {\n\n        public int uiYear;\n        public int uiMonth;\n        public int uiDay;\n        public int uiWeek;\n        public int uiHour;\n        public int uiMinute;\n        public int uiSecondsr;\n        public int uiMilliseconds;\n    }\n\n    public static class PicData extends Structure {\n        public PicData(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n\n        public PicTime tPicTime;\n        public int iDataLen;\n        public Pointer pcPicData;\n    }\n  public static class FacePicStream extends Structure {\n        public FacePicStream(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n        public int iStructLen;\n        public int iSizeOfFull;        \n        public Pointer tFullData;\n        public int iFaceCount;\n        public int iSizeOfFace;        \n        public Pointer[] tPicData = new Pointer[32];\n        public int iFaceFrameId;       \n        public PicTime tNewPicTime;\n    }\n   public static interface NET_PICSTREAM_NOTIFY extends StdCallCallback {\n        int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen,\n                          Pointer _lpUserData);\n    }\n\t public static class NetPicPara extends Structure {\n        public int iStructLen;                //Structure length\n        public int iChannelNo;\n        public NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        public Pointer pvUser;\n    }\n    int NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID);\n\n```\n\n上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。\n\n在另外一个类中加载动态库\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Native;\nimport com.sun.jna.ptr.IntByReference;\npublic class NetClient {\n    private static NVSSDK nvssdk;\n    private static NetClient netClient;\n    private NetClient() {\n    }\n\n    public static NetClient getInstance() {\n        if (netClient == null) {\n            synchronized (NetClient.class) {\n                if (netClient == null) {\n                    netClient = new NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(\"NVSSDK\",\n                            NVSSDK.class);\n                }\n            }\n        }\n        return netClient;\n    }\n   //开始接收图片流\n    public int StartRecvNetPicStream(int _iLogonID, NVSSDK.NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID) {\n        return nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    }\n}\n```\n\n##### 相关的头文件\n\n```c\ntypedef struct tagFacePicStream\n{\n\tint \t\t\tiStructLen;\t\t\t//Structure length\n\tint\t\t\t\tiSizeOfFull;\t\t//The size of strcut PicData\n\tPicData*\t\tptFullData;\t\t\t//The data of full screen\n\tint\t\t\t\tiFaceCount;\t\t\t//The current frame detects the number of face\n\tint\t\t\t\tiSizeOfFace;\t\t//The size of strcut FacePicData\n\tFacePicData*\tptFaceData[108];\n\tint\t\t\t\tiFaceFrameId;\t\t//The face jpeg frame no\n\tPicTime\t\t\ttNewPicTime;\t\t//The picture capture time, ptFullData contain time is out of date\n} FacePicStream, *pFacePicStream;\n\ntypedef struct tagSnapPicData\n{\n\tint \t\tiSnapType;\t\t//Snap type\n\tint \t\tiWidth;\t\t\t//Picture wide\n\tint \t\tiHeight;\t\t//Picture high\n\tint\t\t\tiSize;\t\t\t//The size of strcut PicData\n\tPicData*\tptPicData;\n} SnapPicData, *pSnapPicData;\n\ntypedef struct tagPicTime\n{\n\tunsigned int uiYear;\n\tunsigned int uiMonth;\n\tunsigned int uiDay;\n\tunsigned int uiWeek;\n\tunsigned int uiHour;\n\tunsigned int uiMinute;\n\tunsigned int uiSecondsr;\n\tunsigned int uiMilliseconds;\n} PicTime, *pPicTime;\n//回调\ntypedef int (__stdcall *NET_PICSTREAM_NOTIFY)(unsigned int _uiRecvID, long _lCommand, void* _pvBuf, int _iBufLen, void* _pvUser);\ntypedef struct tagNetPicPara\n{\n\tint \t\t\t\t\tiStructLen;\t\t\t\t//Structure length\n\tint\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\tvoid*\t\t\t\t\tpvUser;\n\tint\t\t\t\t\t\tiPicType;\t\t\t\t//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit0£ºFace picture stream \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit1£ºpedestrian \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit2:plate number\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit3:motor vehicles\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit4:Non-motor vehicle\n} NetPicPara, *pNetPicPara;\n//方法\nint __stdcall NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara* _ptPara, int _iBufLen, unsigned int* _puiRecvID);\n```\n\n##### 使用过程\n\n需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将**指针转换成头文件中对应的结构体**。\n\n```java \nprivate void SetPicQueue(final C4SCamera camera) {\n        NVSSDK.NetPicPara picPara = new NVSSDK.NetPicPara();\n        picPara.iChannelNo = 0;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = new NVSSDK.NET_PICSTREAM_NOTIFY() {\n            public int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen, Pointer _lpUserData) {\n                if (_tInfo == null || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) {\n                    return 0;\n                }\n                if (!camera.capture.get()) {\n                    return 0;\n                }\n                NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n                if (picStream.tFullData != null) {\n                    NVSSDK.PicData fullData = new NVSSDK.PicData(picStream.tFullData);\n                    if (fullData != null && fullData.iDataLen > 0 && camera.capture.get()) {\n                        byte[] data = fullData.pcPicData.getByteArray(0, fullData.iDataLen);\n                        FaceInfo faceInfo = new FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    }\n                }\n                return 0;\n            }\n        };\n        IntByReference relsize = new IntByReference();\n        int iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    }\n```\n\n#### 遇到的问题\n\n1. **java.lang.UnsatisfiedLinkError: Unable to load library 'NVSSDK':**\n\n   这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能\n\n   - jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk\n\n   - 还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。\n\n     ```java\n     System.setProperty(\"jna.library.path\", dllPath);\n     ```\n\n2. 在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。\n\n   - 结构体的构造方法,添加useMemory(pointer);和read();\n\n     ```java\n       public static class FacePicStream extends Structure{\n     \t\tpublic FacePicStream(Pointer pointer) {\n                 super(pointer);\n                 useMemory(pointer);\n                 read();\n             }    \n       }\n     ```\n\n   - 使用\n\n     ```java\n     Pointer _tInfo;\n     NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n     ```\n   \n3. Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。\n\n   ","source":"_posts/java 之 JNA.md","raw":"---\ntitle: java 之 JNA\ndate: 2018-10-15 19:00:12\nindex_img:\n- /images/java/jna.jpg\ntags: \n- jna\ncategories:\n- Java\n---\n\n我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步[官方文档](https://github.com/java-native-access/jna)。\n\n不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：\n\n| C基本类型 |    长度     |  Java类型  |       Windows类型       |\n| :-------: | :---------: | :--------: | :---------------------: |\n|   char    |   8位整型   |    byte    |       BYTE、TCHAR       |\n|   short   |  16位整型   |   short    |          WORD           |\n|  wchar_t  | 16/32位字符 |    char    |          TCHAR          |\n|    int    |  32位整型   |    int     |          DWORD          |\n|    int    |   布尔值    |  boolean   |          BOOL           |\n|   long    | 32/64位整型 | NativeLong |          LONG           |\n| long long |  64位整型   |    long    |         __int64         |\n|   float   | 32位浮点型  |   float    |                         |\n|  double   | 64位浮点型  |   double   |                         |\n|   char*   |   C字符串   |   String   |         LPTCSTR         |\n|   void*   |    指针     |  Pointer   | LPVOID、HANDLE、LP*XXX* |\n\n#### 开发过程\n\n我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。\n\n##### 定义一个接口和编写相应的结构体映射\n\n定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Library;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.Structure;\nimport com.sun.jna.Structure.ByValue;\nimport com.sun.jna.ptr.IntByReference;\nimport com.sun.jna.win32.StdCallLibrary.StdCallCallback;\nimport com.sun.jna.Callback;\n\npublic interface NVSSDK extends Library {\n  public static class PicTime extends Structure {\n\n        public int uiYear;\n        public int uiMonth;\n        public int uiDay;\n        public int uiWeek;\n        public int uiHour;\n        public int uiMinute;\n        public int uiSecondsr;\n        public int uiMilliseconds;\n    }\n\n    public static class PicData extends Structure {\n        public PicData(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n\n        public PicTime tPicTime;\n        public int iDataLen;\n        public Pointer pcPicData;\n    }\n  public static class FacePicStream extends Structure {\n        public FacePicStream(Pointer pointer) {\n            super(pointer);\n            useMemory(pointer);\n            read();\n        }\n        public int iStructLen;\n        public int iSizeOfFull;        \n        public Pointer tFullData;\n        public int iFaceCount;\n        public int iSizeOfFace;        \n        public Pointer[] tPicData = new Pointer[32];\n        public int iFaceFrameId;       \n        public PicTime tNewPicTime;\n    }\n   public static interface NET_PICSTREAM_NOTIFY extends StdCallCallback {\n        int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen,\n                          Pointer _lpUserData);\n    }\n\t public static class NetPicPara extends Structure {\n        public int iStructLen;                //Structure length\n        public int iChannelNo;\n        public NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        public Pointer pvUser;\n    }\n    int NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID);\n\n```\n\n上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。\n\n在另外一个类中加载动态库\n\n```java\npackage com.megvii.camera.proxy;\n\nimport com.sun.jna.Native;\nimport com.sun.jna.ptr.IntByReference;\npublic class NetClient {\n    private static NVSSDK nvssdk;\n    private static NetClient netClient;\n    private NetClient() {\n    }\n\n    public static NetClient getInstance() {\n        if (netClient == null) {\n            synchronized (NetClient.class) {\n                if (netClient == null) {\n                    netClient = new NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(\"NVSSDK\",\n                            NVSSDK.class);\n                }\n            }\n        }\n        return netClient;\n    }\n   //开始接收图片流\n    public int StartRecvNetPicStream(int _iLogonID, NVSSDK.NetPicPara _ptPara, int _iBufLen, IntByReference _puiRecvID) {\n        return nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    }\n}\n```\n\n##### 相关的头文件\n\n```c\ntypedef struct tagFacePicStream\n{\n\tint \t\t\tiStructLen;\t\t\t//Structure length\n\tint\t\t\t\tiSizeOfFull;\t\t//The size of strcut PicData\n\tPicData*\t\tptFullData;\t\t\t//The data of full screen\n\tint\t\t\t\tiFaceCount;\t\t\t//The current frame detects the number of face\n\tint\t\t\t\tiSizeOfFace;\t\t//The size of strcut FacePicData\n\tFacePicData*\tptFaceData[108];\n\tint\t\t\t\tiFaceFrameId;\t\t//The face jpeg frame no\n\tPicTime\t\t\ttNewPicTime;\t\t//The picture capture time, ptFullData contain time is out of date\n} FacePicStream, *pFacePicStream;\n\ntypedef struct tagSnapPicData\n{\n\tint \t\tiSnapType;\t\t//Snap type\n\tint \t\tiWidth;\t\t\t//Picture wide\n\tint \t\tiHeight;\t\t//Picture high\n\tint\t\t\tiSize;\t\t\t//The size of strcut PicData\n\tPicData*\tptPicData;\n} SnapPicData, *pSnapPicData;\n\ntypedef struct tagPicTime\n{\n\tunsigned int uiYear;\n\tunsigned int uiMonth;\n\tunsigned int uiDay;\n\tunsigned int uiWeek;\n\tunsigned int uiHour;\n\tunsigned int uiMinute;\n\tunsigned int uiSecondsr;\n\tunsigned int uiMilliseconds;\n} PicTime, *pPicTime;\n//回调\ntypedef int (__stdcall *NET_PICSTREAM_NOTIFY)(unsigned int _uiRecvID, long _lCommand, void* _pvBuf, int _iBufLen, void* _pvUser);\ntypedef struct tagNetPicPara\n{\n\tint \t\t\t\t\tiStructLen;\t\t\t\t//Structure length\n\tint\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\tvoid*\t\t\t\t\tpvUser;\n\tint\t\t\t\t\t\tiPicType;\t\t\t\t//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit0£ºFace picture stream \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit1£ºpedestrian \n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit2:plate number\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit3:motor vehicles\n\t\t\t\t\t\t\t\t\t\t\t\t\t//bit4:Non-motor vehicle\n} NetPicPara, *pNetPicPara;\n//方法\nint __stdcall NetClient_StartRecvNetPicStream(int _iLogonID, NetPicPara* _ptPara, int _iBufLen, unsigned int* _puiRecvID);\n```\n\n##### 使用过程\n\n需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将**指针转换成头文件中对应的结构体**。\n\n```java \nprivate void SetPicQueue(final C4SCamera camera) {\n        NVSSDK.NetPicPara picPara = new NVSSDK.NetPicPara();\n        picPara.iChannelNo = 0;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = new NVSSDK.NET_PICSTREAM_NOTIFY() {\n            public int PicDataNotify(int _ulID, int _lCommand, Pointer _tInfo, int _iLen, Pointer _lpUserData) {\n                if (_tInfo == null || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) {\n                    return 0;\n                }\n                if (!camera.capture.get()) {\n                    return 0;\n                }\n                NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n                if (picStream.tFullData != null) {\n                    NVSSDK.PicData fullData = new NVSSDK.PicData(picStream.tFullData);\n                    if (fullData != null && fullData.iDataLen > 0 && camera.capture.get()) {\n                        byte[] data = fullData.pcPicData.getByteArray(0, fullData.iDataLen);\n                        FaceInfo faceInfo = new FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    }\n                }\n                return 0;\n            }\n        };\n        IntByReference relsize = new IntByReference();\n        int iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    }\n```\n\n#### 遇到的问题\n\n1. **java.lang.UnsatisfiedLinkError: Unable to load library 'NVSSDK':**\n\n   这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能\n\n   - jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk\n\n   - 还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。\n\n     ```java\n     System.setProperty(\"jna.library.path\", dllPath);\n     ```\n\n2. 在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。\n\n   - 结构体的构造方法,添加useMemory(pointer);和read();\n\n     ```java\n       public static class FacePicStream extends Structure{\n     \t\tpublic FacePicStream(Pointer pointer) {\n                 super(pointer);\n                 useMemory(pointer);\n                 read();\n             }    \n       }\n     ```\n\n   - 使用\n\n     ```java\n     Pointer _tInfo;\n     NVSSDK.FacePicStream picStream = new NVSSDK.FacePicStream(_tInfo);\n     ```\n   \n3. Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。\n\n   ","slug":"java 之 JNA","published":1,"updated":"2020-11-09T11:06:47.372Z","_id":"ckhvmkcx40011dwymdm28at48","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步<a href=\"https://github.com/java-native-access/jna\">官方文档</a>。</p>\n<p>不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">C基本类型</th>\n<th align=\"center\">长度</th>\n<th align=\"center\">Java类型</th>\n<th align=\"center\">Windows类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">8位整型</td>\n<td align=\"center\">byte</td>\n<td align=\"center\">BYTE、TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">16位整型</td>\n<td align=\"center\">short</td>\n<td align=\"center\">WORD</td>\n</tr>\n<tr>\n<td align=\"center\">wchar_t</td>\n<td align=\"center\">16/32位字符</td>\n<td align=\"center\">char</td>\n<td align=\"center\">TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">32位整型</td>\n<td align=\"center\">int</td>\n<td align=\"center\">DWORD</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">布尔值</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">BOOL</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">32/64位整型</td>\n<td align=\"center\">NativeLong</td>\n<td align=\"center\">LONG</td>\n</tr>\n<tr>\n<td align=\"center\">long long</td>\n<td align=\"center\">64位整型</td>\n<td align=\"center\">long</td>\n<td align=\"center\">__int64</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32位浮点型</td>\n<td align=\"center\">float</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">64位浮点型</td>\n<td align=\"center\">double</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">char*</td>\n<td align=\"center\">C字符串</td>\n<td align=\"center\">String</td>\n<td align=\"center\">LPTCSTR</td>\n</tr>\n<tr>\n<td align=\"center\">void*</td>\n<td align=\"center\">指针</td>\n<td align=\"center\">Pointer</td>\n<td align=\"center\">LPVOID、HANDLE、LP<em>XXX</em></td>\n</tr>\n</tbody></table>\n<h4 id=\"开发过程\"><a href=\"#开发过程\" class=\"headerlink\" title=\"开发过程\"></a>开发过程</h4><p>我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。</p>\n<h5 id=\"定义一个接口和编写相应的结构体映射\"><a href=\"#定义一个接口和编写相应的结构体映射\" class=\"headerlink\" title=\"定义一个接口和编写相应的结构体映射\"></a>定义一个接口和编写相应的结构体映射</h5><p>定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Library;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Pointer;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure.ByValue;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.win32.StdCallLibrary.StdCallCallback;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Callback;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NVSSDK</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Library</span> </span>&#123;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicTime</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiYear;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiDay;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiHour;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicData</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">PicData</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n\n        <span class=\"hljs-keyword\">public</span> PicTime tPicTime;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iDataLen;\n        <span class=\"hljs-keyword\">public</span> Pointer pcPicData;\n    &#125;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFull;        \n        <span class=\"hljs-keyword\">public</span> Pointer tFullData;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceCount;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFace;        \n        <span class=\"hljs-keyword\">public</span> Pointer[] tPicData = <span class=\"hljs-keyword\">new</span> Pointer[<span class=\"hljs-number\">32</span>];\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceFrameId;       \n        <span class=\"hljs-keyword\">public</span> PicTime tNewPicTime;\n    &#125;\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NET_PICSTREAM_NOTIFY</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StdCallCallback</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                          Pointer _lpUserData)</span></span>;\n    &#125;\n\t <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetPicPara</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;                <span class=\"hljs-comment\">//Structure length</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iChannelNo;\n        <span class=\"hljs-keyword\">public</span> NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        <span class=\"hljs-keyword\">public</span> Pointer pvUser;\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span></span>;\n</code></pre>\n\n<p>上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。</p>\n<p>在另外一个类中加载动态库</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Native;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetClient</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NVSSDK nvssdk;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NetClient netClient;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">NetClient</span><span class=\"hljs-params\">()</span> </span>&#123;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> NetClient <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">synchronized</span> (NetClient.class) &#123;\n                <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n                    netClient = <span class=\"hljs-keyword\">new</span> NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(<span class=\"hljs-string\">&quot;NVSSDK&quot;</span>,\n                            NVSSDK.class);\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> netClient;\n    &#125;\n   <span class=\"hljs-comment\">//开始接收图片流</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NVSSDK.NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"相关的头文件\"><a href=\"#相关的头文件\" class=\"headerlink\" title=\"相关的头文件\"></a>相关的头文件</h5><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagFacePicStream</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\tiStructLen;\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFull;\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\t\tptFullData;\t\t\t<span class=\"hljs-comment\">//The data of full screen</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceCount;\t\t\t<span class=\"hljs-comment\">//The current frame detects the number of face</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFace;\t\t<span class=\"hljs-comment\">//The size of strcut FacePicData</span>\n\tFacePicData*\tptFaceData[<span class=\"hljs-number\">108</span>];\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceFrameId;\t\t<span class=\"hljs-comment\">//The face jpeg frame no</span>\n\tPicTime\t\t\ttNewPicTime;\t\t<span class=\"hljs-comment\">//The picture capture time, ptFullData contain time is out of date</span>\n&#125; FacePicStream, *pFacePicStream;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagSnapPicData</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiSnapType;\t\t<span class=\"hljs-comment\">//Snap type</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiWidth;\t\t\t<span class=\"hljs-comment\">//Picture wide</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiHeight;\t\t<span class=\"hljs-comment\">//Picture high</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\tiSize;\t\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\tptPicData;\n&#125; SnapPicData, *pSnapPicData;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagPicTime</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiYear;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiDay;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiHour;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n&#125; PicTime, *pPicTime;\n<span class=\"hljs-comment\">//回调</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(__stdcall *NET_PICSTREAM_NOTIFY)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> _uiRecvID, <span class=\"hljs-keyword\">long</span> _lCommand, <span class=\"hljs-keyword\">void</span>* _pvBuf, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">void</span>* _pvUser)</span></span>;\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagNetPicPara</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\t\t\tiStructLen;\t\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\t<span class=\"hljs-keyword\">void</span>*\t\t\t\t\tpvUser;\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiPicType;\t\t\t\t<span class=\"hljs-comment\">//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit0£ºFace picture stream </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit1£ºpedestrian </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit2:plate number</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit3:motor vehicles</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit4:Non-motor vehicle</span>\n&#125; NetPicPara, *pNetPicPara;\n<span class=\"hljs-comment\">//方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> __stdcall <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara* _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>* _puiRecvID)</span></span>;</code></pre>\n\n<h5 id=\"使用过程\"><a href=\"#使用过程\" class=\"headerlink\" title=\"使用过程\"></a>使用过程</h5><p>需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将<strong>指针转换成头文件中对应的结构体</strong>。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SetPicQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> C4SCamera camera)</span> </span>&#123;\n        NVSSDK.NetPicPara picPara = <span class=\"hljs-keyword\">new</span> NVSSDK.NetPicPara();\n        picPara.iChannelNo = <span class=\"hljs-number\">0</span>;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = <span class=\"hljs-keyword\">new</span> NVSSDK.NET_PICSTREAM_NOTIFY() &#123;\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen, Pointer _lpUserData)</span> </span>&#123;\n                <span class=\"hljs-keyword\">if</span> (_tInfo == <span class=\"hljs-keyword\">null</span> || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (!camera.capture.get()) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                NVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);\n                <span class=\"hljs-keyword\">if</span> (picStream.tFullData != <span class=\"hljs-keyword\">null</span>) &#123;\n                    NVSSDK.PicData fullData = <span class=\"hljs-keyword\">new</span> NVSSDK.PicData(picStream.tFullData);\n                    <span class=\"hljs-keyword\">if</span> (fullData != <span class=\"hljs-keyword\">null</span> &amp;&amp; fullData.iDataLen &gt; <span class=\"hljs-number\">0</span> &amp;&amp; camera.capture.get()) &#123;\n                        <span class=\"hljs-keyword\">byte</span>[] data = fullData.pcPicData.getByteArray(<span class=\"hljs-number\">0</span>, fullData.iDataLen);\n                        FaceInfo faceInfo = <span class=\"hljs-keyword\">new</span> FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    &#125;\n                &#125;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n            &#125;\n        &#125;;\n        IntByReference relsize = <span class=\"hljs-keyword\">new</span> IntByReference();\n        <span class=\"hljs-keyword\">int</span> iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    &#125;</code></pre>\n\n<h4 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h4><ol>\n<li><p><strong>java.lang.UnsatisfiedLinkError: Unable to load library ‘NVSSDK’:</strong></p>\n<p>这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能</p>\n<ul>\n<li><p>jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk</p>\n</li>\n<li><p>还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。</p>\n<pre><code class=\"hljs java\">System.setProperty(<span class=\"hljs-string\">&quot;jna.library.path&quot;</span>, dllPath);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。</p>\n<ul>\n<li><p>结构体的构造方法,添加useMemory(pointer);和read();</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span></span>&#123;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n          <span class=\"hljs-keyword\">super</span>(pointer);\n          useMemory(pointer);\n          read();\n      &#125;    \n&#125;</code></pre>\n</li>\n<li><p>使用</p>\n<pre><code class=\"hljs java\">Pointer _tInfo;\nNVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道JAVA调用C和C++ 通常用是JNI，JNI虽然好用但是对于JAVA程序猿并不是很有友好，有更多的学习成本。对于java程序猿来说JNA的学习成本就低的多。在工程中只要引入一个jar包就可以非常方便的使用。对于官方的一些样例这里我也就不在重复了。主要还是从我自己这边使用遇到一些问题说起。官方入门的一些请移步<a href=\"https://github.com/java-native-access/jna\">官方文档</a>。</p>\n<p>不过在开始之前一定一定要了解的是类型映射关系。也就是在C或者C++ 中的类型在JAVA中对应的类型是什么？直接上表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">C基本类型</th>\n<th align=\"center\">长度</th>\n<th align=\"center\">Java类型</th>\n<th align=\"center\">Windows类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char</td>\n<td align=\"center\">8位整型</td>\n<td align=\"center\">byte</td>\n<td align=\"center\">BYTE、TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">16位整型</td>\n<td align=\"center\">short</td>\n<td align=\"center\">WORD</td>\n</tr>\n<tr>\n<td align=\"center\">wchar_t</td>\n<td align=\"center\">16/32位字符</td>\n<td align=\"center\">char</td>\n<td align=\"center\">TCHAR</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">32位整型</td>\n<td align=\"center\">int</td>\n<td align=\"center\">DWORD</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">布尔值</td>\n<td align=\"center\">boolean</td>\n<td align=\"center\">BOOL</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">32/64位整型</td>\n<td align=\"center\">NativeLong</td>\n<td align=\"center\">LONG</td>\n</tr>\n<tr>\n<td align=\"center\">long long</td>\n<td align=\"center\">64位整型</td>\n<td align=\"center\">long</td>\n<td align=\"center\">__int64</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">32位浮点型</td>\n<td align=\"center\">float</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">64位浮点型</td>\n<td align=\"center\">double</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">char*</td>\n<td align=\"center\">C字符串</td>\n<td align=\"center\">String</td>\n<td align=\"center\">LPTCSTR</td>\n</tr>\n<tr>\n<td align=\"center\">void*</td>\n<td align=\"center\">指针</td>\n<td align=\"center\">Pointer</td>\n<td align=\"center\">LPVOID、HANDLE、LP<em>XXX</em></td>\n</tr>\n</tbody></table>\n<h4 id=\"开发过程\"><a href=\"#开发过程\" class=\"headerlink\" title=\"开发过程\"></a>开发过程</h4><p>我这边接到一个另外一个部门提供的一个dll库和头文件，需要使用JNA的方式进行开发使用。提供一个NVSSDK.dll 和其他的一些依赖的dll库和头文件。</p>\n<h5 id=\"定义一个接口和编写相应的结构体映射\"><a href=\"#定义一个接口和编写相应的结构体映射\" class=\"headerlink\" title=\"定义一个接口和编写相应的结构体映射\"></a>定义一个接口和编写相应的结构体映射</h5><p>定义一个类编写要使用dll库中的方法和对应的结构体，具体可参考相关的头文件。简易是和头文件对应着看。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Library;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Pointer;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Structure.ByValue;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.win32.StdCallLibrary.StdCallCallback;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Callback;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NVSSDK</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Library</span> </span>&#123;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicTime</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiYear;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiDay;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiHour;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PicData</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">PicData</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n\n        <span class=\"hljs-keyword\">public</span> PicTime tPicTime;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iDataLen;\n        <span class=\"hljs-keyword\">public</span> Pointer pcPicData;\n    &#125;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>(pointer);\n            useMemory(pointer);\n            read();\n        &#125;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFull;        \n        <span class=\"hljs-keyword\">public</span> Pointer tFullData;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceCount;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iSizeOfFace;        \n        <span class=\"hljs-keyword\">public</span> Pointer[] tPicData = <span class=\"hljs-keyword\">new</span> Pointer[<span class=\"hljs-number\">32</span>];\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iFaceFrameId;       \n        <span class=\"hljs-keyword\">public</span> PicTime tNewPicTime;\n    &#125;\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NET_PICSTREAM_NOTIFY</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StdCallCallback</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                          Pointer _lpUserData)</span></span>;\n    &#125;\n\t <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetPicPara</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span> </span>&#123;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iStructLen;                <span class=\"hljs-comment\">//Structure length</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> iChannelNo;\n        <span class=\"hljs-keyword\">public</span> NET_PICSTREAM_NOTIFY cbkPicStreamNotify;\n        <span class=\"hljs-keyword\">public</span> Pointer pvUser;\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span></span>;\n</code></pre>\n\n<p>上面继承Structure的是C中的结构体，继承StdCallCallback的是C中回调方法，NetClient_StartRecvNetPicStream是C中我们要调用的方法。</p>\n<p>在另外一个类中加载动态库</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.megvii.camera.proxy;\n\n<span class=\"hljs-keyword\">import</span> com.sun.jna.Native;\n<span class=\"hljs-keyword\">import</span> com.sun.jna.ptr.IntByReference;\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NetClient</span> </span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NVSSDK nvssdk;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> NetClient netClient;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">NetClient</span><span class=\"hljs-params\">()</span> </span>&#123;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> NetClient <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">synchronized</span> (NetClient.class) &#123;\n                <span class=\"hljs-keyword\">if</span> (netClient == <span class=\"hljs-keyword\">null</span>) &#123;\n                    netClient = <span class=\"hljs-keyword\">new</span> NetClient();\n                    nvssdk = (NVSSDK) Native.loadLibrary(<span class=\"hljs-string\">&quot;NVSSDK&quot;</span>,\n                            NVSSDK.class);\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> netClient;\n    &#125;\n   <span class=\"hljs-comment\">//开始接收图片流</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NVSSDK.NetPicPara _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, IntByReference _puiRecvID)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> nvssdk.NetClient_StartRecvNetPicStream(_iLogonID, _ptPara, _iBufLen, _puiRecvID);\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"相关的头文件\"><a href=\"#相关的头文件\" class=\"headerlink\" title=\"相关的头文件\"></a>相关的头文件</h5><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagFacePicStream</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\tiStructLen;\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFull;\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\t\tptFullData;\t\t\t<span class=\"hljs-comment\">//The data of full screen</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceCount;\t\t\t<span class=\"hljs-comment\">//The current frame detects the number of face</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiSizeOfFace;\t\t<span class=\"hljs-comment\">//The size of strcut FacePicData</span>\n\tFacePicData*\tptFaceData[<span class=\"hljs-number\">108</span>];\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\tiFaceFrameId;\t\t<span class=\"hljs-comment\">//The face jpeg frame no</span>\n\tPicTime\t\t\ttNewPicTime;\t\t<span class=\"hljs-comment\">//The picture capture time, ptFullData contain time is out of date</span>\n&#125; FacePicStream, *pFacePicStream;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagSnapPicData</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiSnapType;\t\t<span class=\"hljs-comment\">//Snap type</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiWidth;\t\t\t<span class=\"hljs-comment\">//Picture wide</span>\n\t<span class=\"hljs-keyword\">int</span> \t\tiHeight;\t\t<span class=\"hljs-comment\">//Picture high</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\tiSize;\t\t\t<span class=\"hljs-comment\">//The size of strcut PicData</span>\n\tPicData*\tptPicData;\n&#125; SnapPicData, *pSnapPicData;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagPicTime</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiYear;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMonth;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiDay;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiWeek;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiHour;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMinute;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiSecondsr;\n\t<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> uiMilliseconds;\n&#125; PicTime, *pPicTime;\n<span class=\"hljs-comment\">//回调</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title\">int</span> <span class=\"hljs-params\">(__stdcall *NET_PICSTREAM_NOTIFY)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> _uiRecvID, <span class=\"hljs-keyword\">long</span> _lCommand, <span class=\"hljs-keyword\">void</span>* _pvBuf, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">void</span>* _pvUser)</span></span>;\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tagNetPicPara</span></span>\n<span class=\"hljs-class\">&#123;</span>\n\t<span class=\"hljs-keyword\">int</span> \t\t\t\t\tiStructLen;\t\t\t\t<span class=\"hljs-comment\">//Structure length</span>\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiChannelNo;\n\tNET_PICSTREAM_NOTIFY\tcbkPicStreamNotify;\n\t<span class=\"hljs-keyword\">void</span>*\t\t\t\t\tpvUser;\n\t<span class=\"hljs-keyword\">int</span>\t\t\t\t\t\tiPicType;\t\t\t\t<span class=\"hljs-comment\">//Client request picture stream type.Structured proprietary(This field is not sent or sent 0: indicates that the server is adaptively sent and sent based on the current configuration.)</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit0£ºFace picture stream </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit1£ºpedestrian </span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit2:plate number</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit3:motor vehicles</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//bit4:Non-motor vehicle</span>\n&#125; NetPicPara, *pNetPicPara;\n<span class=\"hljs-comment\">//方法</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> __stdcall <span class=\"hljs-title\">NetClient_StartRecvNetPicStream</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _iLogonID, NetPicPara* _ptPara, <span class=\"hljs-keyword\">int</span> _iBufLen, <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>* _puiRecvID)</span></span>;</code></pre>\n\n<h5 id=\"使用过程\"><a href=\"#使用过程\" class=\"headerlink\" title=\"使用过程\"></a>使用过程</h5><p>需要留意的是FacePicStream和PicData的构造方法，这个方法是和指针转换时使用的，如果没有这么写的话Java是无法获取到C中指针的值的。以下的回调方法中回调了一个指针，将<strong>指针转换成头文件中对应的结构体</strong>。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SetPicQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> C4SCamera camera)</span> </span>&#123;\n        NVSSDK.NetPicPara picPara = <span class=\"hljs-keyword\">new</span> NVSSDK.NetPicPara();\n        picPara.iChannelNo = <span class=\"hljs-number\">0</span>;\n        picPara.iStructLen = picPara.size();\n        picPara.cbkPicStreamNotify = <span class=\"hljs-keyword\">new</span> NVSSDK.NET_PICSTREAM_NOTIFY() &#123;\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">PicDataNotify</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> _ulID, <span class=\"hljs-keyword\">int</span> _lCommand, Pointer _tInfo, <span class=\"hljs-keyword\">int</span> _iLen, Pointer _lpUserData)</span> </span>&#123;\n                <span class=\"hljs-keyword\">if</span> (_tInfo == <span class=\"hljs-keyword\">null</span> || NVSSDK.NET_PICSTREAM_CMD_FACE != _lCommand) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (!camera.capture.get()) &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n                NVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);\n                <span class=\"hljs-keyword\">if</span> (picStream.tFullData != <span class=\"hljs-keyword\">null</span>) &#123;\n                    NVSSDK.PicData fullData = <span class=\"hljs-keyword\">new</span> NVSSDK.PicData(picStream.tFullData);\n                    <span class=\"hljs-keyword\">if</span> (fullData != <span class=\"hljs-keyword\">null</span> &amp;&amp; fullData.iDataLen &gt; <span class=\"hljs-number\">0</span> &amp;&amp; camera.capture.get()) &#123;\n                        <span class=\"hljs-keyword\">byte</span>[] data = fullData.pcPicData.getByteArray(<span class=\"hljs-number\">0</span>, fullData.iDataLen);\n                        FaceInfo faceInfo = <span class=\"hljs-keyword\">new</span> FaceInfo();\n                        faceInfo.faceData = data;\n                        faceInfo.cameraIP = camera.ip;\n                        faceInfo.cameraAlias = camera.alias;\n                        camera.captureQueue.offer(faceInfo);\n                    &#125;\n                &#125;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n            &#125;\n        &#125;;\n        IntByReference relsize = <span class=\"hljs-keyword\">new</span> IntByReference();\n        <span class=\"hljs-keyword\">int</span> iRet = NetClient.getInstance().StartRecvNetPicStream(camera.logonId, picPara, picPara.size(), relsize);\n    &#125;</code></pre>\n\n<h4 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h4><ol>\n<li><p><strong>java.lang.UnsatisfiedLinkError: Unable to load library ‘NVSSDK’:</strong></p>\n<p>这个错误是无法找到对应的dll库，也就是我前面提到的NVSSDK.dll。出现这个情况的有以下三种可能</p>\n<ul>\n<li><p>jdk版本的位数和dll库的位数不一致。比如你的jdk版本是32位的，但是你的dll库是64位，就会出现这个错误，反过来也一样。解决办法是更换同样位数的库或者jdk</p>\n</li>\n<li><p>还有一种你的环境变量中的path没有包含你要用的dll库路径。在JNA中查找动态库的顺序是，Java虚拟机中的jna.library.path，然后是Java虚机的java.library.path，最后才是系统环境变量下path。所以只要在这个三个路径只要有一个路径下有包含你的dll库路径就行。</p>\n<pre><code class=\"hljs java\">System.setProperty(<span class=\"hljs-string\">&quot;jna.library.path&quot;</span>, dllPath);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>在使用过程中指针和结构体之间的相互转换，发现值没有复制到Java过来。</p>\n<ul>\n<li><p>结构体的构造方法,添加useMemory(pointer);和read();</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FacePicStream</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Structure</span></span>&#123;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FacePicStream</span><span class=\"hljs-params\">(Pointer pointer)</span> </span>&#123;\n          <span class=\"hljs-keyword\">super</span>(pointer);\n          useMemory(pointer);\n          read();\n      &#125;    \n&#125;</code></pre>\n</li>\n<li><p>使用</p>\n<pre><code class=\"hljs java\">Pointer _tInfo;\nNVSSDK.FacePicStream picStream = <span class=\"hljs-keyword\">new</span> NVSSDK.FacePicStream(_tInfo);</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Java中的Structure和C结构体中的顺序写错了。如果是同样类型的不会出现编译错误，但是取到的值准确，类型不同则出现编译错误。</p>\n</li>\n</ol>\n"},{"title":"传统POS流程及名词解释","date":"2020-10-19T09:20:12.000Z","index_img":["/images/other/banner.png"],"_content":"\n### 传统POS流程及名词解释\n\n####  签到流程\n\nPOS机签到只要有两个目的：\n\n1. 链接主机证明该POS机设备是合法的\n2. 下载最新的工作密钥\n\n签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。\n\n\n\n```mermaid\ngraph TD\nEE{签到}--fail-->TT(退出应用)\nEE--success-->A{参数下载}--fail-->TT(退出应用)\nA--success-->B{AID参数下载}--fail-->TT(退出应用)\nB--success-->C{下载CA公钥}--fail-->TT(退出应用)\nC--success-->E(交易流程)\n    \n```\n\n#### 交易流程\n\n交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。\n\n名称解释：\n\n1. 消费：\n\n   包括正常刷卡/挥卡/插卡消费\n\n2. 消费撤销：\n\n   因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，**消费撤销必须是撤销消费所用POS机的当日当批次的消费交易**。\n\n3. 消费退货：\n\n   和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是\n\n   - 退货不要求当日当批次的消费\n   - 退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款\n\n4. 结算：\n\n   一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。\n\n5. 预授权：\n\n   就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点\n\n   - 预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已\n   - 必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码\n   - 预授权的小票需要客户签名\n   - 必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。\n   - 预授权有效期一般为30天（含），超过时间资金将自动解冻。\n   - 交易凭证上标有“预授权”字样。\n\n6. 预授权撤销：\n\n   预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。\n\n7. 预授权完成：\n\n   是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。\n\n8. 预授权完成撤销：\n\n   预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。\n\n```mermaid\ngraph TD\nEE(交易流程)-->A{消费}\nA-->D(撤销)\nA-->E(退货)\nD-->Y(结算)\nE-->Y(结算)\nEE-->B{预授权}\nB-->F(预授权撤销)\nF-->Y(结算)\nB-->G(预授权完成)\nG-->H(预授权完成撤销)\nH-->Y(结算)\nEE-->C(余额查询)\nC-->Y(结算)\nY-->Z(签退)\n    \n```\n\n#### 消费冲正流程\n\n名次解释：\n\n1. 冲正\n\n   当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。\n\n```mermaid\ngraph TD\nA(消费) --> B{是否有上一笔<br>的消费记录}\nB -->|是|C(请求冲正)\nC --> D{冲正成功 或<br>超过最大冲正次数}\nD --> |是|E(清除冲正记录)\nE --> F(结束)\nD --> |否|C\nB --> |否|G(保存此次消费记录)\nG --> K(请求交易)\nK --> H{响应交易}\nH --> |交易成功|I(交易成功)\nI --> L(清除此次消费记录)\nL --> F\nH --> |交易失败|J(交易失败)\nJ --> M(不清除本次消费记录<br>下次消费时冲正)\nM --> F\n```\n\n","source":"_posts/传统POS流程及名词解释.md","raw":"---\ntitle: 传统POS流程及名词解释\ndate: 2020-10-19 17:20:12\nindex_img:\n- /images/other/banner.png\ntags: \n- 随笔\ncategories:\n- 随笔\n---\n\n### 传统POS流程及名词解释\n\n####  签到流程\n\nPOS机签到只要有两个目的：\n\n1. 链接主机证明该POS机设备是合法的\n2. 下载最新的工作密钥\n\n签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。\n\n\n\n```mermaid\ngraph TD\nEE{签到}--fail-->TT(退出应用)\nEE--success-->A{参数下载}--fail-->TT(退出应用)\nA--success-->B{AID参数下载}--fail-->TT(退出应用)\nB--success-->C{下载CA公钥}--fail-->TT(退出应用)\nC--success-->E(交易流程)\n    \n```\n\n#### 交易流程\n\n交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。\n\n名称解释：\n\n1. 消费：\n\n   包括正常刷卡/挥卡/插卡消费\n\n2. 消费撤销：\n\n   因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，**消费撤销必须是撤销消费所用POS机的当日当批次的消费交易**。\n\n3. 消费退货：\n\n   和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是\n\n   - 退货不要求当日当批次的消费\n   - 退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款\n\n4. 结算：\n\n   一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。\n\n5. 预授权：\n\n   就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点\n\n   - 预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已\n   - 必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码\n   - 预授权的小票需要客户签名\n   - 必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。\n   - 预授权有效期一般为30天（含），超过时间资金将自动解冻。\n   - 交易凭证上标有“预授权”字样。\n\n6. 预授权撤销：\n\n   预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。\n\n7. 预授权完成：\n\n   是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。\n\n8. 预授权完成撤销：\n\n   预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。\n\n```mermaid\ngraph TD\nEE(交易流程)-->A{消费}\nA-->D(撤销)\nA-->E(退货)\nD-->Y(结算)\nE-->Y(结算)\nEE-->B{预授权}\nB-->F(预授权撤销)\nF-->Y(结算)\nB-->G(预授权完成)\nG-->H(预授权完成撤销)\nH-->Y(结算)\nEE-->C(余额查询)\nC-->Y(结算)\nY-->Z(签退)\n    \n```\n\n#### 消费冲正流程\n\n名次解释：\n\n1. 冲正\n\n   当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。\n\n```mermaid\ngraph TD\nA(消费) --> B{是否有上一笔<br>的消费记录}\nB -->|是|C(请求冲正)\nC --> D{冲正成功 或<br>超过最大冲正次数}\nD --> |是|E(清除冲正记录)\nE --> F(结束)\nD --> |否|C\nB --> |否|G(保存此次消费记录)\nG --> K(请求交易)\nK --> H{响应交易}\nH --> |交易成功|I(交易成功)\nI --> L(清除此次消费记录)\nL --> F\nH --> |交易失败|J(交易失败)\nJ --> M(不清除本次消费记录<br>下次消费时冲正)\nM --> F\n```\n\n","slug":"传统POS流程及名词解释","published":1,"updated":"2020-10-19T10:54:51.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhvmkcxa001ldwym1fm4402x","content":"<h3 id=\"传统POS流程及名词解释\"><a href=\"#传统POS流程及名词解释\" class=\"headerlink\" title=\"传统POS流程及名词解释\"></a>传统POS流程及名词解释</h3><h4 id=\"签到流程\"><a href=\"#签到流程\" class=\"headerlink\" title=\"签到流程\"></a>签到流程</h4><p>POS机签到只要有两个目的：</p>\n<ol>\n<li>链接主机证明该POS机设备是合法的</li>\n<li>下载最新的工作密钥</li>\n</ol>\n<p>签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。</p>\n<pre><code class=\"hljs mermaid\">graph TD\nEE&#123;签到&#125;--fail--&gt;TT(退出应用)\nEE--success--&gt;A&#123;参数下载&#125;--fail--&gt;TT(退出应用)\nA--success--&gt;B&#123;AID参数下载&#125;--fail--&gt;TT(退出应用)\nB--success--&gt;C&#123;下载CA公钥&#125;--fail--&gt;TT(退出应用)\nC--success--&gt;E(交易流程)</code></pre>\n\n<h4 id=\"交易流程\"><a href=\"#交易流程\" class=\"headerlink\" title=\"交易流程\"></a>交易流程</h4><p>交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。</p>\n<p>名称解释：</p>\n<ol>\n<li><p>消费：</p>\n<p>包括正常刷卡/挥卡/插卡消费</p>\n</li>\n<li><p>消费撤销：</p>\n<p>因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，<strong>消费撤销必须是撤销消费所用POS机的当日当批次的消费交易</strong>。</p>\n</li>\n<li><p>消费退货：</p>\n<p>和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是</p>\n<ul>\n<li>退货不要求当日当批次的消费</li>\n<li>退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款</li>\n</ul>\n</li>\n<li><p>结算：</p>\n<p>一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。</p>\n</li>\n<li><p>预授权：</p>\n<p>就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点</p>\n<ul>\n<li>预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已</li>\n<li>必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码</li>\n<li>预授权的小票需要客户签名</li>\n<li>必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。</li>\n<li>预授权有效期一般为30天（含），超过时间资金将自动解冻。</li>\n<li>交易凭证上标有“预授权”字样。</li>\n</ul>\n</li>\n<li><p>预授权撤销：</p>\n<p>预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。</p>\n</li>\n<li><p>预授权完成：</p>\n<p>是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。</p>\n</li>\n<li><p>预授权完成撤销：</p>\n<p>预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nEE(交易流程)--&gt;A&#123;消费&#125;\nA--&gt;D(撤销)\nA--&gt;E(退货)\nD--&gt;Y(结算)\nE--&gt;Y(结算)\nEE--&gt;B&#123;预授权&#125;\nB--&gt;F(预授权撤销)\nF--&gt;Y(结算)\nB--&gt;G(预授权完成)\nG--&gt;H(预授权完成撤销)\nH--&gt;Y(结算)\nEE--&gt;C(余额查询)\nC--&gt;Y(结算)\nY--&gt;Z(签退)</code></pre>\n\n<h4 id=\"消费冲正流程\"><a href=\"#消费冲正流程\" class=\"headerlink\" title=\"消费冲正流程\"></a>消费冲正流程</h4><p>名次解释：</p>\n<ol>\n<li><p>冲正</p>\n<p>当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nA(消费) --&gt; B&#123;是否有上一笔&lt;br&gt;的消费记录&#125;\nB --&gt;|是|C(请求冲正)\nC --&gt; D&#123;冲正成功 或&lt;br&gt;超过最大冲正次数&#125;\nD --&gt; |是|E(清除冲正记录)\nE --&gt; F(结束)\nD --&gt; |否|C\nB --&gt; |否|G(保存此次消费记录)\nG --&gt; K(请求交易)\nK --&gt; H&#123;响应交易&#125;\nH --&gt; |交易成功|I(交易成功)\nI --&gt; L(清除此次消费记录)\nL --&gt; F\nH --&gt; |交易失败|J(交易失败)\nJ --&gt; M(不清除本次消费记录&lt;br&gt;下次消费时冲正)\nM --&gt; F</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"传统POS流程及名词解释\"><a href=\"#传统POS流程及名词解释\" class=\"headerlink\" title=\"传统POS流程及名词解释\"></a>传统POS流程及名词解释</h3><h4 id=\"签到流程\"><a href=\"#签到流程\" class=\"headerlink\" title=\"签到流程\"></a>签到流程</h4><p>POS机签到只要有两个目的：</p>\n<ol>\n<li>链接主机证明该POS机设备是合法的</li>\n<li>下载最新的工作密钥</li>\n</ol>\n<p>签到就是POS设备向服务器发起签到请求，然后让服务器返回三个工作密钥，分别用于加密POS传输给服务器的银行卡的三个信息。三个工作密钥是通过POS设备硬件芯片内的密钥（在服务器端也有）进行加密的。</p>\n<pre><code class=\"hljs mermaid\">graph TD\nEE&#123;签到&#125;--fail--&gt;TT(退出应用)\nEE--success--&gt;A&#123;参数下载&#125;--fail--&gt;TT(退出应用)\nA--success--&gt;B&#123;AID参数下载&#125;--fail--&gt;TT(退出应用)\nB--success--&gt;C&#123;下载CA公钥&#125;--fail--&gt;TT(退出应用)\nC--success--&gt;E(交易流程)</code></pre>\n\n<h4 id=\"交易流程\"><a href=\"#交易流程\" class=\"headerlink\" title=\"交易流程\"></a>交易流程</h4><p>交易流程是在签到成功之后才能进行，交易流程包括正常消费/预授权流程/余额查询。</p>\n<p>名称解释：</p>\n<ol>\n<li><p>消费：</p>\n<p>包括正常刷卡/挥卡/插卡消费</p>\n</li>\n<li><p>消费撤销：</p>\n<p>因为某种原因已经进行过消费的一笔交易，请求撤销。需要注意的是，<strong>消费撤销必须是撤销消费所用POS机的当日当批次的消费交易</strong>。</p>\n</li>\n<li><p>消费退货：</p>\n<p>和消费撤销类似，退货也是对一笔消费交易进行退款。不同的是</p>\n<ul>\n<li>退货不要求当日当批次的消费</li>\n<li>退货一般支持部分退货，多次退货，而消费撤销一般都是直接退全款</li>\n</ul>\n</li>\n<li><p>结算：</p>\n<p>一般POS机在每天的工作结束之后，应进行结算操作（分为手动结算和自动结算）结算会将当日POS机中存储的所有笔交易（包含消费、消费撤销）上传至后台并清空，然后进行签退。一个结算周期内所有的交易使用的是同一个批次号，即同一批次。因此可以简单的理解为结算之前只能消费撤销，因为消费数据在POS机里面存着；结算之后只能退货，此时原消费数据已从POS机里面清除。</p>\n</li>\n<li><p>预授权：</p>\n<p>就是商户通过POS机申请的方式向发卡行申请冻结持卡人借记卡或贷记卡中一部分金额或额度作为抵押的一种交易，也可以解释为商户在客户的授权下向发卡行申请的在一定时限、一定金额内扣收一笔客户款项的许可，这个款项的许可呈现，就是欠账单上的授权码。理解预授权要注意一下几点</p>\n<ul>\n<li>预授权不是扣款，并没有产生实际交易，只是这部分钱在商户进一步处理前，客户无法去操作而已</li>\n<li>必须验证客户卡片的有效性，包括卡号、有效期、发卡行、客户签名、密码</li>\n<li>预授权的小票需要客户签名</li>\n<li>必须注意保存预授权单据，因为在预授权完成时要求必须输入预授权号，预授权日期等信息，否则预授权完成交易无法成功完成，商户无法收到结算资金。</li>\n<li>预授权有效期一般为30天（含），超过时间资金将自动解冻。</li>\n<li>交易凭证上标有“预授权”字样。</li>\n</ul>\n</li>\n<li><p>预授权撤销：</p>\n<p>预授权以后如果想取消怎么办？一是等30天后预授权自动取消，二就是做预授权撤销，预授权撤销是只商户未进行预授权完成前，客户不想使用这张卡进行消费时商家进行的操作。</p>\n</li>\n<li><p>预授权完成：</p>\n<p>是指特约商户对已取得预授权的交易，在预授权金额或超出预授权金额一定比例范围内，通过POS终端或手工方式完成持卡人付款的过程，因为在预授权是客户已经输入过密码了，表示商家可处理预授权的资金，所以预授权完成时无需输入密码。预授权是可以超额扣款的，最大扣款金额是预授权金额的115%。</p>\n</li>\n<li><p>预授权完成撤销：</p>\n<p>预授权完成撤销，是指商户已经进行预授权完成，但是发现完成金额与实际消费金额不符时进行的操作，预授权完成撤销会取消预授权完成的凭证，把预授权恢复到初始状态，注意，预授权完成撤销后是可以再次发起预授权完成的，并且整个过程无需客户再次输密。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nEE(交易流程)--&gt;A&#123;消费&#125;\nA--&gt;D(撤销)\nA--&gt;E(退货)\nD--&gt;Y(结算)\nE--&gt;Y(结算)\nEE--&gt;B&#123;预授权&#125;\nB--&gt;F(预授权撤销)\nF--&gt;Y(结算)\nB--&gt;G(预授权完成)\nG--&gt;H(预授权完成撤销)\nH--&gt;Y(结算)\nEE--&gt;C(余额查询)\nC--&gt;Y(结算)\nY--&gt;Z(签退)</code></pre>\n\n<h4 id=\"消费冲正流程\"><a href=\"#消费冲正流程\" class=\"headerlink\" title=\"消费冲正流程\"></a>消费冲正流程</h4><p>名次解释：</p>\n<ol>\n<li><p>冲正</p>\n<p>当POS机终端将一笔交易的报文发往后台，但是没有收到返回最终超时时，POS机无法确定后台是否成功的完成了这笔交易。因此，当下笔交易发生前，POS机会先向后台请求撤销该笔不确定的交易，如果后台记录该笔交易成功，则回滚及撤销该笔交易，否则不处理，此为冲正成功；如果POS机与银联结算中间在数据传输过程中发生故障，则冲正不成功，此时刷卡方卡里的钱已经被扣，需要进行人工冲正。</p>\n</li>\n</ol>\n<pre><code class=\"hljs mermaid\">graph TD\nA(消费) --&gt; B&#123;是否有上一笔&lt;br&gt;的消费记录&#125;\nB --&gt;|是|C(请求冲正)\nC --&gt; D&#123;冲正成功 或&lt;br&gt;超过最大冲正次数&#125;\nD --&gt; |是|E(清除冲正记录)\nE --&gt; F(结束)\nD --&gt; |否|C\nB --&gt; |否|G(保存此次消费记录)\nG --&gt; K(请求交易)\nK --&gt; H&#123;响应交易&#125;\nH --&gt; |交易成功|I(交易成功)\nI --&gt; L(清除此次消费记录)\nL --&gt; F\nH --&gt; |交易失败|J(交易失败)\nJ --&gt; M(不清除本次消费记录&lt;br&gt;下次消费时冲正)\nM --&gt; F</code></pre>\n\n"},{"title":"并发模型及线程模型概述","date":"2020-07-08T10:50:22.000Z","index_img":["/images/other/wm.jpg"],"_content":"\n### 同步异步\n\n要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？\n\n举一个例子说明，领导安排小东开发：\n\n**同步阻塞：**领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。\n\n**同步不阻塞：**领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。\n\n**异步阻塞：**领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。\n\n**异步不阻塞：**领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。\n\n**总结：**\n\n同步，是调用者主动去查看调用的状态；\n\n异步，则是被调用者来通知调用者；\n\n阻塞和非阻塞的区别是调用后是否立即返回\n\n### 并发模型\n\n#### 进程和线程的区别\n\n进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。\n\n进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。\n\n线程的上下文切换代价比进程要小的多。\n进程之间强调的是通信，线程之间强调的是同步（数据安全）。\n\n[转自链接](https://learnku.com/articles/32807)\n\n#### 并发模型\n\n1. 单进/线程-循环处理任务\n\n   单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。\n\n2. 多进程单线程\n\n   主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重\n\n3. 单进程多线程\n\n   单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。\n\n4. 多进程多线程\n\n   这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在**CPU密集型作业**下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。\n\n5. IO多路复用\n\n   IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。\n\n   [彻底理解 IO多路复用](https://juejin.im/post/6844904200141438984)\n   \n6. 协程\n\n   协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地`yield`进行切换，golang 则是用 go 语法来开启`goroutine`，具体的调度由语言层面提供的运行时执行。\n\n### 线程模型\n\n线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。\n\n以下内容摘抄自[Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池](https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst)\n\n**[内核调度实体（KSE，Kernel Scheduling Entity）](https://helix979.github.io/jkoo/post/os-scheduler/)**\n\n1. 内核级线程模型\n\n   用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。\n\n   这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   C[内核线程] -->D(用户线程)\n   E[内核线程] -->F(用户线程)\n    \n   ```\n\n   \n\n2. 用户级线程模型\n\n   用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 **协程库**基本上都属于这种方式（比如python的gevent）。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   ```\n\n   由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。\n\n   但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的**协程库**会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。\n\n3. 两级线程模型（混合型线程模型）\n\n   两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。\n\n   在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   K[内核线程] -->B\n   K-->D\n   K-->F\n   Z[内核线程] -->B\n   Z-->D\n   Z-->F\n   ```\n\n   所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？**即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』**\n\n   \n\n参考链接:\n\nhttps://juejin.im/entry/6844903680651558919\n\nhttps://juejin.im/post/6844904200141438984\n\nhttps://learnku.com/articles/32807\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\n","source":"_posts/并发模型及线程模型概述.md","raw":"---\ntitle: 并发模型及线程模型概述\ndate: 2020-07-08 18:50:22\nindex_img:\n- /images/other/wm.jpg\ntags: \n- 扩展\ncategories:\n- 随笔\n---\n\n### 同步异步\n\n要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？\n\n举一个例子说明，领导安排小东开发：\n\n**同步阻塞：**领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。\n\n**同步不阻塞：**领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。\n\n**异步阻塞：**领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。\n\n**异步不阻塞：**领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。\n\n**总结：**\n\n同步，是调用者主动去查看调用的状态；\n\n异步，则是被调用者来通知调用者；\n\n阻塞和非阻塞的区别是调用后是否立即返回\n\n### 并发模型\n\n#### 进程和线程的区别\n\n进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。\n\n进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。\n\n线程的上下文切换代价比进程要小的多。\n进程之间强调的是通信，线程之间强调的是同步（数据安全）。\n\n[转自链接](https://learnku.com/articles/32807)\n\n#### 并发模型\n\n1. 单进/线程-循环处理任务\n\n   单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。\n\n2. 多进程单线程\n\n   主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重\n\n3. 单进程多线程\n\n   单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。\n\n4. 多进程多线程\n\n   这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在**CPU密集型作业**下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。\n\n5. IO多路复用\n\n   IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。\n\n   [彻底理解 IO多路复用](https://juejin.im/post/6844904200141438984)\n   \n6. 协程\n\n   协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地`yield`进行切换，golang 则是用 go 语法来开启`goroutine`，具体的调度由语言层面提供的运行时执行。\n\n### 线程模型\n\n线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。\n\n以下内容摘抄自[Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池](https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst)\n\n**[内核调度实体（KSE，Kernel Scheduling Entity）](https://helix979.github.io/jkoo/post/os-scheduler/)**\n\n1. 内核级线程模型\n\n   用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。\n\n   这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   C[内核线程] -->D(用户线程)\n   E[内核线程] -->F(用户线程)\n    \n   ```\n\n   \n\n2. 用户级线程模型\n\n   用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 **协程库**基本上都属于这种方式（比如python的gevent）。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   ```\n\n   由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。\n\n   但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的**协程库**会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。\n\n3. 两级线程模型（混合型线程模型）\n\n   两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。\n\n   在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。\n\n   ```mermaid\n   graph BT\n   A[内核线程] -->B(用户线程)\n   A-->D(用户线程)\n   A -->F(用户线程)\n   K[内核线程] -->B\n   K-->D\n   K-->F\n   Z[内核线程] -->B\n   Z-->D\n   Z-->F\n   ```\n\n   所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？**即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』**\n\n   \n\n参考链接:\n\nhttps://juejin.im/entry/6844903680651558919\n\nhttps://juejin.im/post/6844904200141438984\n\nhttps://learnku.com/articles/32807\n\nhttps://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\n\n","slug":"并发模型及线程模型概述","published":1,"updated":"2020-11-09T11:06:24.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhvmkcxh0023dwymgasxc6j0","content":"<h3 id=\"同步异步\"><a href=\"#同步异步\" class=\"headerlink\" title=\"同步异步\"></a>同步异步</h3><p>要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？</p>\n<p>举一个例子说明，领导安排小东开发：</p>\n<p><strong>同步阻塞：</strong>领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。</p>\n<p><strong>同步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。</p>\n<p><strong>异步阻塞：</strong>领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。</p>\n<p><strong>异步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。</p>\n<p><strong>总结：</strong></p>\n<p>同步，是调用者主动去查看调用的状态；</p>\n<p>异步，则是被调用者来通知调用者；</p>\n<p>阻塞和非阻塞的区别是调用后是否立即返回</p>\n<h3 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h3><h4 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h4><p>进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。</p>\n<p>进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。</p>\n<p>线程的上下文切换代价比进程要小的多。<br>进程之间强调的是通信，线程之间强调的是同步（数据安全）。</p>\n<p><a href=\"https://learnku.com/articles/32807\">转自链接</a></p>\n<h4 id=\"并发模型-1\"><a href=\"#并发模型-1\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h4><ol>\n<li><p>单进/线程-循环处理任务</p>\n<p>单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。</p>\n</li>\n<li><p>多进程单线程</p>\n<p>主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重</p>\n</li>\n<li><p>单进程多线程</p>\n<p>单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。</p>\n</li>\n<li><p>多进程多线程</p>\n<p>这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在<strong>CPU密集型作业</strong>下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。</p>\n</li>\n<li><p>IO多路复用</p>\n<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。</p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">彻底理解 IO多路复用</a></p>\n</li>\n<li><p>协程</p>\n<p>协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地<code>yield</code>进行切换，golang 则是用 go 语法来开启<code>goroutine</code>，具体的调度由语言层面提供的运行时执行。</p>\n</li>\n</ol>\n<h3 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h3><p>线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。</p>\n<p>以下内容摘抄自<a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池</a></p>\n<p><strong><a href=\"https://helix979.github.io/jkoo/post/os-scheduler/\">内核调度实体（KSE，Kernel Scheduling Entity）</a></strong></p>\n<ol>\n<li><p>内核级线程模型</p>\n<p>用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。</p>\n<p>这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nC[内核线程] --&gt;D(用户线程)\nE[内核线程] --&gt;F(用户线程)</code></pre>\n\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>用户级线程模型</p>\n<p>用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 <strong>协程库</strong>基本上都属于这种方式（比如python的gevent）。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)</code></pre>\n\n<p>由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。</p>\n<p>但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的<strong>协程库</strong>会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p>\n</li>\n<li><p>两级线程模型（混合型线程模型）</p>\n<p>两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。</p>\n<p>在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)\nK[内核线程] --&gt;B\nK--&gt;D\nK--&gt;F\nZ[内核线程] --&gt;B\nZ--&gt;D\nZ--&gt;F</code></pre>\n\n<p>所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？<strong>即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』</strong></p>\n</li>\n</ol>\n<p>参考链接:</p>\n<p><a href=\"https://juejin.im/entry/6844903680651558919\">https://juejin.im/entry/6844903680651558919</a></p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">https://juejin.im/post/6844904200141438984</a></p>\n<p><a href=\"https://learnku.com/articles/32807\">https://learnku.com/articles/32807</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"同步异步\"><a href=\"#同步异步\" class=\"headerlink\" title=\"同步异步\"></a>同步异步</h3><p>要了解各种并发模型思想，首先要了解什么是同步，什么是异步？什么是阻塞，什么是非阻塞？</p>\n<p>举一个例子说明，领导安排小东开发：</p>\n<p><strong>同步阻塞：</strong>领导安排小东开发后，一直盯着小东开发，直到小东开发完成之后，才去干其它活。</p>\n<p><strong>同步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，每隔一会儿就过来询问小东是否完成了没。</p>\n<p><strong>异步阻塞：</strong>领导安排小东开发后，不盯着小东，也不会忙其他事，小东开发完成后就通知领导。</p>\n<p><strong>异步不阻塞：</strong>领导安排小东开发后，就忙自己的事情去了，小东开发完成后就通知领导。</p>\n<p><strong>总结：</strong></p>\n<p>同步，是调用者主动去查看调用的状态；</p>\n<p>异步，则是被调用者来通知调用者；</p>\n<p>阻塞和非阻塞的区别是调用后是否立即返回</p>\n<h3 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h3><h4 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h4><p>进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位。从操作系统层面去看是进程，从 CPU 层面去看是线程。</p>\n<p>进程的空间是独立，各个进程相互不干扰，每个进程拥有自己的进程内存，上下文环境，进程控制块，一个进程至少有一个或者多个线程。线程属于进程，线程要存在必须依赖于进程，线程共享进程的内存，但线程有自己的栈空间，能创建多少个线程也取决于进程内存的大小。</p>\n<p>线程的上下文切换代价比进程要小的多。<br>进程之间强调的是通信，线程之间强调的是同步（数据安全）。</p>\n<p><a href=\"https://learnku.com/articles/32807\">转自链接</a></p>\n<h4 id=\"并发模型-1\"><a href=\"#并发模型-1\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h4><ol>\n<li><p>单进/线程-循环处理任务</p>\n<p>单进程和单线程本质是一样的，不具备并发处理的能力，只能串行处理任务。</p>\n</li>\n<li><p>多进程单线程</p>\n<p>主进程负责监听和管理连接，当有客户端请求来时，就fork一个子进程来处理连接。这种模型会比较稳定，最大的好处是隔离性，子进程万一 crash 并不会影响到父进程，也不会产生线程安全问题。但是创建进程对内存消耗会比较，并且CPU在多个进程间来回切换开销也大，所以子进程不适合过多，总的来说这种模型对系统的负担过重</p>\n</li>\n<li><p>单进程多线程</p>\n<p>单进程多线程和多进程单线程的方式类似，只不过是替换成线程。主线程负责监听，管理连接，子线程负责处理业务逻辑。多线程提高了响应速度，让IO和计算相互重叠，降低延时。但是也带来了频繁地创建、销毁线程，这对系统也是个不小的开销。同时也要处理同步的问题，当多个线程请求同一个资源时，需要用锁之类的手段来保证线程安全。最后一个是线程的奔溃会影响整个进程，稳定性不如多进程。</p>\n</li>\n<li><p>多进程多线程</p>\n<p>这种并发模型是在开启多个子进程后，每个子进程下面又会开启多个线程。这种模式下并发承受能力会比单纯的多进程好许多，但是这个也分情况，比如在<strong>CPU密集型作业</strong>下未必会比多进程好，因为每一个进程下的多线程上下文不断切换的开销是非常大的。cpu 本来就在多个进程间切换，现在又要在单个进程下的多个线程间切换，cpu 大部分时间都在切换上下文了，真正用于计算的时间反而很少，因此影响了其性能。</p>\n</li>\n<li><p>IO多路复用</p>\n<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。</p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">彻底理解 IO多路复用</a></p>\n</li>\n<li><p>协程</p>\n<p>协程基于用户空间的调度器，具体的调度算法由具体的编译器和开发者实现，相比多线程和事件回调的方式，更加灵活可控。不同语言协程的调度方式也不一样，python 是在代码里显式地<code>yield</code>进行切换，golang 则是用 go 语法来开启<code>goroutine</code>，具体的调度由语言层面提供的运行时执行。</p>\n</li>\n</ol>\n<h3 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h3><p>线程的实现可以分为三类，内核级线程，用户级线程，以及混合型线程。</p>\n<p>以下内容摘抄自<a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">Goroutine并发调度模型深度解析之手撸一个高性能Goroutine池</a></p>\n<p><strong><a href=\"https://helix979.github.io/jkoo/post/os-scheduler/\">内核调度实体（KSE，Kernel Scheduling Entity）</a></strong></p>\n<ol>\n<li><p>内核级线程模型</p>\n<p>用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。</p>\n<p>这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nC[内核线程] --&gt;D(用户线程)\nE[内核线程] --&gt;F(用户线程)</code></pre>\n\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>用户级线程模型</p>\n<p>用户线程与内核线程KSE是多对一（N : 1）的映射模型，多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的 <strong>协程库</strong>基本上都属于这种方式（比如python的gevent）。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)</code></pre>\n\n<p>由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让CPU在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。</p>\n<p>但该模型有个原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。所以很多的<strong>协程库</strong>会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了。</p>\n</li>\n<li><p>两级线程模型（混合型线程模型）</p>\n<p>两级线程模型是博采众长之后的产物，充分吸收前两种线程模型的优点且尽量规避它们的缺点。</p>\n<p>在此模型下，用户线程与内核KSE是多对多（N : M）的映射模型：首先，区别于用户级线程模型，两级线程模型中的一个进程可以与多个内核线程KSE关联，也就是说一个进程内的多个线程可以分别绑定一个自己的KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与KSE唯一绑定，而是可以多个用户线程映射到同一个KSE，当某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行。</p>\n<pre><code class=\"hljs mermaid\">graph BT\nA[内核线程] --&gt;B(用户线程)\nA--&gt;D(用户线程)\nA --&gt;F(用户线程)\nK[内核线程] --&gt;B\nK--&gt;D\nK--&gt;F\nZ[内核线程] --&gt;B\nZ--&gt;D\nZ--&gt;F</code></pre>\n\n<p>所以，两级线程模型既不是用户级线程模型那种完全靠自己调度的也不是内核级线程模型完全靠操作系统调度的，而是中间态（自身调度与系统调度协同工作），也就是 — 『薛定谔的模型』（误），因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联，不过Go语言的实现更加高级和优雅；该模型为何被称为两级？<strong>即用户调度器实现用户线程到KSE的『调度』，内核调度器实现KSE到CPU上的『调度』</strong></p>\n</li>\n</ol>\n<p>参考链接:</p>\n<p><a href=\"https://juejin.im/entry/6844903680651558919\">https://juejin.im/entry/6844903680651558919</a></p>\n<p><a href=\"https://juejin.im/post/6844904200141438984\">https://juejin.im/post/6844904200141438984</a></p>\n<p><a href=\"https://learnku.com/articles/32807\">https://learnku.com/articles/32807</a></p>\n<p><a href=\"https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst\">https://www.infoq.cn/article/XF6v3Vapqsqt17FuTVst</a></p>\n"},{"title":"ssh 免密登录","date":"2017-07-05T05:45:12.000Z","index_img":["/images/shell/001_ssh_1.jpg"],"_content":"\n 做后端开发经常遇到一个情况是使用公司的虚拟机很多，每次都要记住用户名密码和IP是一件很麻烦的事情，所以在想有没有一种能够免密快速ssh的方式？\n\n### 什么是SSH\n\n简单来说SSH 是一种网络协议，用于计算机之间的加密登录，早起的互联网通信都是明文通信的，一旦被截获密码就泄露出去了。于是就有了SSH协议，将登录信息全部加密。目前SSH协议已经在全世界广泛使用了，且成为各个L inux发行版本的标配。（桌面版本的Linux不支持SSH，需要安装OpenSSH）\n\n### SSH的过程\n\nSSH 默认使用的是RSA加密算法\n\n1. 请求主机Client用户使用`ssh user@host`命令对远程Server发起登录\n2. 远程主机将自己的公钥返回给请求主机\n3. 请求主机使用公钥对用户输入的密码进行加密\n4. 请求主机将加密后的信息发送给远程主机\n5. 远程主机使用私钥对密码进行解密\n6. 最后，远程主机判断解密后的密码是否与用户密码一致，一致就同意登陆，否则反之\n\n```mermaid\nsequenceDiagram\n    autonumber\n    Client->>Server: ssh user@host\n    Server->>Client: return public_key\n    Client->>Client: use public_key encrypt password\n    Client->>Server: send encrypted password\n    Server->>Server: use private_key decrypt password\n    Server->>Server: check password\n```\n\n整个过程看上去没啥问题，但是相比HTTPS 协议安全性是稍差的，那是因为SSH协议没用CA证书签发机构，很容利用自签的证书来截获请求冒充远程主机来取得登录密码的。SSH发现这个问题之后，想了一个办法来绕开这个问题。引入了know_hosts。\n\n### know_hosts作用\n\n在第一次ssh的时候我们都会看到这样的一个提示\n\n```shell\nThe authenticity of host '10.122.48.130 (10.122.48.130)' can't be established.\nRSA key fingerprint is ee:6e:68:7d:91:8c:d8:d9:1d:ab:61:9b:5f:53:68:d3.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '10.122.48.130' (RSA) to the list of known hosts.\n```\n\n这句话提示的是：无法确认主机的真实性，只知道它的公钥指纹，是否建立连接？这个方式就将主机被冒充的风险抛给了使用者。当然对公钥的核对也是一个问题，这就需要远程主机公开公钥。在上面的提示中输入`yes`之后，s sh就会将远程主机的公钥写入本地的know_hosts文件中。第二次ssh的时候就会核对这个公钥指纹，如果不一致则无法ssh 成功。\n\n具体的know_hosts内容样例，IP 加密算法 指纹信息\n\n```shell\n10.122.48.130 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6G4lMkyH4O2IcWxRmbecn6aMTi3r3+eS2W05CLT7zl3EgWyx7nYEXzWeGl7OMhW+OBDsukuMCOApcG+ge4EaQEqVEWAFn+/Dr5HwUyFFTeEj/fP/3/Xq6/3rt277iJHHSyXsWW29+e2w3OjB/eJJ20lJ4nC7fdghZw4AFSP5YVwhXPtTs2I2cX5ziP4guvpNJPCQq/DNt1uZvvsEt7jmQW8K6YixcHNTipKvhAZGZlx/soamu60WAMr8nmhLy4Svc56rLZYTYIkIvZqRzSDfqDCo9/NcOh2oaa1LBUJBD3hZ9F7lpxnfS6tpHEnowGb1wQtdFhLfJ7gGvTzGeAFRow==\n```\n\n之前遇到过这样的一个问题，以前已经添加了know_hosts的IP，发现远程主机指纹变化了，导致无法ssh，这时需要将对应IP的这样一行删除即可。主机指纹变化有可能是系统重装，也有可能是IP被其他机器获取了。\n\nKnow_hosts文件是在没用用户下的`～/.ssh/know_hosts`\n\n### 别名免密登录\n\n#### 免密登录的公钥认证过程\n\n1. 请求机Client将自己的公钥存储在远程机Server的authorized_keys中\n2. 远程机在收到请求机的请求后，会在 authorized_keys 中匹配到 Client 的公钥 pubKey，并生成随机数 R，用 Client 的公钥对该随机数进行加密得到 pubKey(R)，然后将加密后信息发送给 Client。\n3. Client 端通过私钥进行解密得到随机数 R，然后对随机数 R 和本次会话的 SessionKey 利用 MD5 生成摘要 Digest1，发送给 Server 端。\n4. Server 端会也会对 R 和 SessionKey 利用同样摘要算法生成 Digest2。\n5. Server 端会最后比较 Digest1 和 Digest2 是否相同，完成认证过程。\n\n```mermaid\nsequenceDiagram\n    Client -->>Server: add client public_key to server\n    Server->>Client: return client public_key(R)\n    Client->>Client: private_key decrypt R\n    Client->>Server: send MD5(R+sessionKey)\n    Server->>Server: MD5(R+sessionKey)\n    Server->>Server: check Digest1 Digest2\n```\n\n#### ssh 免密登录应用\n\n1. 请求端Client生成自己的公私钥\n\n   ```shell\n   # 如果不想设置指定信息，一路回车即可\n   ssh-keygen\n   ```\n\n   可以在请求端Client的当前用户目录下的.ssh文件下看到id_rsa 和id_rsa.pub文件\n\n2. 将自己的公钥添加到远程主机Server上\n\n   ```shell\n   ssh-copy-id -i ~/.ssh/id_rsa.pub user@host\n   ```\n\n   在远处主机的用户目录下的.ssh 下有authorized_keys文件\n\n3. 在上面两步完成后已经可以进行免密登录了，但是还是需要指定用户和IP。想要添加别名登录的话，需要在请求端Client的～/.ssh下创建config文件。config文件配置如下\n\n   ```shell\n   # 服务器1\n   Host 130\n       HostName 10.122.48.130\n       Port 22\n       User root\n       IdentityFile /home/test/.ssh/id_rsa\n       \n   # 服务器2\n   Host 131\n       HostName 10.122.48.131\n       Port 22\n       User root\n       IdentityFile /home/test/.ssh/id_rsa\n   ```\n\n   在请求端Client上执行 `ssh 130`相当于执行`ssh root@10.122.48.130`并且不需要密码。\n\n### AutoSSH \n\nssh的反向穿透技术，可以实现内网服务在公网上提供服务。ssh一般用来客户端远程登录到服务器上，而ssh反向穿透“反其道而行之”，由服务端主动发起请求连接客户端，然后在客户端打开一个端口，之后发往客户端的数据包将会转发到服务端。但是ssh不支持自动重连功能，这时我们就可以用上autossh了。\n\n我们可以利用autossh将内网端口映射到外网上。由于autossh 并不是Linux自带的，所以需要自己编译安装。\n\n在内网机器B上进行编译安装\n\n```shell\n#1.将autossh下载到服务器B上\nwget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n#2.解压\ntar xzvf autossh-1.4e.tgz\n#3. 编译安装\n cd autossh-1.4e\n ./configure\n make\n make install\n```\n\n将内网机器B的公钥添加到公网机器A上\n\n```shell\n# 如果没生成过公钥执行生成公钥\nssh-keygen\n# 将内网机器B的公钥添加到公网机器上\nssh-copy-id -i ~/.ssh/id_rsa.pub user@hostA\n```\n\n在内网机器使用autossh\n\n```shell\nautossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa use@hostA\n```\n\n参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连\n\n后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口\n\n到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。","source":"_posts/001_ssh免密登录.md","raw":"---\ntitle: ssh 免密登录\ndate: 2017-07-05 13:45:12\nindex_img:\n- /images/shell/001_ssh_1.jpg\ntags: \n- shell\ncategories:\n- Linux\n---\n\n 做后端开发经常遇到一个情况是使用公司的虚拟机很多，每次都要记住用户名密码和IP是一件很麻烦的事情，所以在想有没有一种能够免密快速ssh的方式？\n\n### 什么是SSH\n\n简单来说SSH 是一种网络协议，用于计算机之间的加密登录，早起的互联网通信都是明文通信的，一旦被截获密码就泄露出去了。于是就有了SSH协议，将登录信息全部加密。目前SSH协议已经在全世界广泛使用了，且成为各个L inux发行版本的标配。（桌面版本的Linux不支持SSH，需要安装OpenSSH）\n\n### SSH的过程\n\nSSH 默认使用的是RSA加密算法\n\n1. 请求主机Client用户使用`ssh user@host`命令对远程Server发起登录\n2. 远程主机将自己的公钥返回给请求主机\n3. 请求主机使用公钥对用户输入的密码进行加密\n4. 请求主机将加密后的信息发送给远程主机\n5. 远程主机使用私钥对密码进行解密\n6. 最后，远程主机判断解密后的密码是否与用户密码一致，一致就同意登陆，否则反之\n\n```mermaid\nsequenceDiagram\n    autonumber\n    Client->>Server: ssh user@host\n    Server->>Client: return public_key\n    Client->>Client: use public_key encrypt password\n    Client->>Server: send encrypted password\n    Server->>Server: use private_key decrypt password\n    Server->>Server: check password\n```\n\n整个过程看上去没啥问题，但是相比HTTPS 协议安全性是稍差的，那是因为SSH协议没用CA证书签发机构，很容利用自签的证书来截获请求冒充远程主机来取得登录密码的。SSH发现这个问题之后，想了一个办法来绕开这个问题。引入了know_hosts。\n\n### know_hosts作用\n\n在第一次ssh的时候我们都会看到这样的一个提示\n\n```shell\nThe authenticity of host '10.122.48.130 (10.122.48.130)' can't be established.\nRSA key fingerprint is ee:6e:68:7d:91:8c:d8:d9:1d:ab:61:9b:5f:53:68:d3.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '10.122.48.130' (RSA) to the list of known hosts.\n```\n\n这句话提示的是：无法确认主机的真实性，只知道它的公钥指纹，是否建立连接？这个方式就将主机被冒充的风险抛给了使用者。当然对公钥的核对也是一个问题，这就需要远程主机公开公钥。在上面的提示中输入`yes`之后，s sh就会将远程主机的公钥写入本地的know_hosts文件中。第二次ssh的时候就会核对这个公钥指纹，如果不一致则无法ssh 成功。\n\n具体的know_hosts内容样例，IP 加密算法 指纹信息\n\n```shell\n10.122.48.130 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6G4lMkyH4O2IcWxRmbecn6aMTi3r3+eS2W05CLT7zl3EgWyx7nYEXzWeGl7OMhW+OBDsukuMCOApcG+ge4EaQEqVEWAFn+/Dr5HwUyFFTeEj/fP/3/Xq6/3rt277iJHHSyXsWW29+e2w3OjB/eJJ20lJ4nC7fdghZw4AFSP5YVwhXPtTs2I2cX5ziP4guvpNJPCQq/DNt1uZvvsEt7jmQW8K6YixcHNTipKvhAZGZlx/soamu60WAMr8nmhLy4Svc56rLZYTYIkIvZqRzSDfqDCo9/NcOh2oaa1LBUJBD3hZ9F7lpxnfS6tpHEnowGb1wQtdFhLfJ7gGvTzGeAFRow==\n```\n\n之前遇到过这样的一个问题，以前已经添加了know_hosts的IP，发现远程主机指纹变化了，导致无法ssh，这时需要将对应IP的这样一行删除即可。主机指纹变化有可能是系统重装，也有可能是IP被其他机器获取了。\n\nKnow_hosts文件是在没用用户下的`～/.ssh/know_hosts`\n\n### 别名免密登录\n\n#### 免密登录的公钥认证过程\n\n1. 请求机Client将自己的公钥存储在远程机Server的authorized_keys中\n2. 远程机在收到请求机的请求后，会在 authorized_keys 中匹配到 Client 的公钥 pubKey，并生成随机数 R，用 Client 的公钥对该随机数进行加密得到 pubKey(R)，然后将加密后信息发送给 Client。\n3. Client 端通过私钥进行解密得到随机数 R，然后对随机数 R 和本次会话的 SessionKey 利用 MD5 生成摘要 Digest1，发送给 Server 端。\n4. Server 端会也会对 R 和 SessionKey 利用同样摘要算法生成 Digest2。\n5. Server 端会最后比较 Digest1 和 Digest2 是否相同，完成认证过程。\n\n```mermaid\nsequenceDiagram\n    Client -->>Server: add client public_key to server\n    Server->>Client: return client public_key(R)\n    Client->>Client: private_key decrypt R\n    Client->>Server: send MD5(R+sessionKey)\n    Server->>Server: MD5(R+sessionKey)\n    Server->>Server: check Digest1 Digest2\n```\n\n#### ssh 免密登录应用\n\n1. 请求端Client生成自己的公私钥\n\n   ```shell\n   # 如果不想设置指定信息，一路回车即可\n   ssh-keygen\n   ```\n\n   可以在请求端Client的当前用户目录下的.ssh文件下看到id_rsa 和id_rsa.pub文件\n\n2. 将自己的公钥添加到远程主机Server上\n\n   ```shell\n   ssh-copy-id -i ~/.ssh/id_rsa.pub user@host\n   ```\n\n   在远处主机的用户目录下的.ssh 下有authorized_keys文件\n\n3. 在上面两步完成后已经可以进行免密登录了，但是还是需要指定用户和IP。想要添加别名登录的话，需要在请求端Client的～/.ssh下创建config文件。config文件配置如下\n\n   ```shell\n   # 服务器1\n   Host 130\n       HostName 10.122.48.130\n       Port 22\n       User root\n       IdentityFile /home/test/.ssh/id_rsa\n       \n   # 服务器2\n   Host 131\n       HostName 10.122.48.131\n       Port 22\n       User root\n       IdentityFile /home/test/.ssh/id_rsa\n   ```\n\n   在请求端Client上执行 `ssh 130`相当于执行`ssh root@10.122.48.130`并且不需要密码。\n\n### AutoSSH \n\nssh的反向穿透技术，可以实现内网服务在公网上提供服务。ssh一般用来客户端远程登录到服务器上，而ssh反向穿透“反其道而行之”，由服务端主动发起请求连接客户端，然后在客户端打开一个端口，之后发往客户端的数据包将会转发到服务端。但是ssh不支持自动重连功能，这时我们就可以用上autossh了。\n\n我们可以利用autossh将内网端口映射到外网上。由于autossh 并不是Linux自带的，所以需要自己编译安装。\n\n在内网机器B上进行编译安装\n\n```shell\n#1.将autossh下载到服务器B上\nwget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n#2.解压\ntar xzvf autossh-1.4e.tgz\n#3. 编译安装\n cd autossh-1.4e\n ./configure\n make\n make install\n```\n\n将内网机器B的公钥添加到公网机器A上\n\n```shell\n# 如果没生成过公钥执行生成公钥\nssh-keygen\n# 将内网机器B的公钥添加到公网机器上\nssh-copy-id -i ~/.ssh/id_rsa.pub user@hostA\n```\n\n在内网机器使用autossh\n\n```shell\nautossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa use@hostA\n```\n\n参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连\n\n后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口\n\n到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。","slug":"001_ssh免密登录","published":1,"updated":"2021-03-09T06:56:28.938Z","_id":"ckm0gaqs20000mjyma9m06wty","comments":1,"layout":"post","photos":[],"link":"","content":"<p> 做后端开发经常遇到一个情况是使用公司的虚拟机很多，每次都要记住用户名密码和IP是一件很麻烦的事情，所以在想有没有一种能够免密快速ssh的方式？</p>\n<h3 id=\"什么是SSH\"><a href=\"#什么是SSH\" class=\"headerlink\" title=\"什么是SSH\"></a>什么是SSH</h3><p>简单来说SSH 是一种网络协议，用于计算机之间的加密登录，早起的互联网通信都是明文通信的，一旦被截获密码就泄露出去了。于是就有了SSH协议，将登录信息全部加密。目前SSH协议已经在全世界广泛使用了，且成为各个L inux发行版本的标配。（桌面版本的Linux不支持SSH，需要安装OpenSSH）</p>\n<h3 id=\"SSH的过程\"><a href=\"#SSH的过程\" class=\"headerlink\" title=\"SSH的过程\"></a>SSH的过程</h3><p>SSH 默认使用的是RSA加密算法</p>\n<ol>\n<li>请求主机Client用户使用<code>ssh user@host</code>命令对远程Server发起登录</li>\n<li>远程主机将自己的公钥返回给请求主机</li>\n<li>请求主机使用公钥对用户输入的密码进行加密</li>\n<li>请求主机将加密后的信息发送给远程主机</li>\n<li>远程主机使用私钥对密码进行解密</li>\n<li>最后，远程主机判断解密后的密码是否与用户密码一致，一致就同意登陆，否则反之</li>\n</ol>\n<pre><code class=\"hljs mermaid\">sequenceDiagram\n    autonumber\n    Client-&gt;&gt;Server: ssh user@host\n    Server-&gt;&gt;Client: return public_key\n    Client-&gt;&gt;Client: use public_key encrypt password\n    Client-&gt;&gt;Server: send encrypted password\n    Server-&gt;&gt;Server: use private_key decrypt password\n    Server-&gt;&gt;Server: check password</code></pre>\n\n<p>整个过程看上去没啥问题，但是相比HTTPS 协议安全性是稍差的，那是因为SSH协议没用CA证书签发机构，很容利用自签的证书来截获请求冒充远程主机来取得登录密码的。SSH发现这个问题之后，想了一个办法来绕开这个问题。引入了know_hosts。</p>\n<h3 id=\"know-hosts作用\"><a href=\"#know-hosts作用\" class=\"headerlink\" title=\"know_hosts作用\"></a>know_hosts作用</h3><p>在第一次ssh的时候我们都会看到这样的一个提示</p>\n<pre><code class=\"hljs shell\">The authenticity of host &#x27;10.122.48.130 (10.122.48.130)&#x27; can&#x27;t be established.\nRSA key fingerprint is ee:6e:68:7d:91:8c:d8:d9:1d:ab:61:9b:5f:53:68:d3.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added &#x27;10.122.48.130&#x27; (RSA) to the list of known hosts.</code></pre>\n\n<p>这句话提示的是：无法确认主机的真实性，只知道它的公钥指纹，是否建立连接？这个方式就将主机被冒充的风险抛给了使用者。当然对公钥的核对也是一个问题，这就需要远程主机公开公钥。在上面的提示中输入<code>yes</code>之后，s sh就会将远程主机的公钥写入本地的know_hosts文件中。第二次ssh的时候就会核对这个公钥指纹，如果不一致则无法ssh 成功。</p>\n<p>具体的know_hosts内容样例，IP 加密算法 指纹信息</p>\n<pre><code class=\"hljs shell\">10.122.48.130 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6G4lMkyH4O2IcWxRmbecn6aMTi3r3+eS2W05CLT7zl3EgWyx7nYEXzWeGl7OMhW+OBDsukuMCOApcG+ge4EaQEqVEWAFn+/Dr5HwUyFFTeEj/fP/3/Xq6/3rt277iJHHSyXsWW29+e2w3OjB/eJJ20lJ4nC7fdghZw4AFSP5YVwhXPtTs2I2cX5ziP4guvpNJPCQq/DNt1uZvvsEt7jmQW8K6YixcHNTipKvhAZGZlx/soamu60WAMr8nmhLy4Svc56rLZYTYIkIvZqRzSDfqDCo9/NcOh2oaa1LBUJBD3hZ9F7lpxnfS6tpHEnowGb1wQtdFhLfJ7gGvTzGeAFRow==</code></pre>\n\n<p>之前遇到过这样的一个问题，以前已经添加了know_hosts的IP，发现远程主机指纹变化了，导致无法ssh，这时需要将对应IP的这样一行删除即可。主机指纹变化有可能是系统重装，也有可能是IP被其他机器获取了。</p>\n<p>Know_hosts文件是在没用用户下的<code>～/.ssh/know_hosts</code></p>\n<h3 id=\"别名免密登录\"><a href=\"#别名免密登录\" class=\"headerlink\" title=\"别名免密登录\"></a>别名免密登录</h3><h4 id=\"免密登录的公钥认证过程\"><a href=\"#免密登录的公钥认证过程\" class=\"headerlink\" title=\"免密登录的公钥认证过程\"></a>免密登录的公钥认证过程</h4><ol>\n<li>请求机Client将自己的公钥存储在远程机Server的authorized_keys中</li>\n<li>远程机在收到请求机的请求后，会在 authorized_keys 中匹配到 Client 的公钥 pubKey，并生成随机数 R，用 Client 的公钥对该随机数进行加密得到 pubKey(R)，然后将加密后信息发送给 Client。</li>\n<li>Client 端通过私钥进行解密得到随机数 R，然后对随机数 R 和本次会话的 SessionKey 利用 MD5 生成摘要 Digest1，发送给 Server 端。</li>\n<li>Server 端会也会对 R 和 SessionKey 利用同样摘要算法生成 Digest2。</li>\n<li>Server 端会最后比较 Digest1 和 Digest2 是否相同，完成认证过程。</li>\n</ol>\n<pre><code class=\"hljs mermaid\">sequenceDiagram\n    Client --&gt;&gt;Server: add client public_key to server\n    Server-&gt;&gt;Client: return client public_key(R)\n    Client-&gt;&gt;Client: private_key decrypt R\n    Client-&gt;&gt;Server: send MD5(R+sessionKey)\n    Server-&gt;&gt;Server: MD5(R+sessionKey)\n    Server-&gt;&gt;Server: check Digest1 Digest2</code></pre>\n\n<h4 id=\"ssh-免密登录应用\"><a href=\"#ssh-免密登录应用\" class=\"headerlink\" title=\"ssh 免密登录应用\"></a>ssh 免密登录应用</h4><ol>\n<li><p>请求端Client生成自己的公私钥</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 如果不想设置指定信息，一路回车即可</span>\nssh-keygen</code></pre>\n\n<p>可以在请求端Client的当前用户目录下的.ssh文件下看到id_rsa 和id_rsa.pub文件</p>\n</li>\n<li><p>将自己的公钥添加到远程主机Server上</p>\n<pre><code class=\"hljs shell\">ssh-copy-id -i ~/.ssh/id_rsa.pub user@host</code></pre>\n\n<p>在远处主机的用户目录下的.ssh 下有authorized_keys文件</p>\n</li>\n<li><p>在上面两步完成后已经可以进行免密登录了，但是还是需要指定用户和IP。想要添加别名登录的话，需要在请求端Client的～/.ssh下创建config文件。config文件配置如下</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 服务器1</span>\nHost 130\n    HostName 10.122.48.130\n    Port 22\n    User root\n    IdentityFile /home/test/.ssh/id_rsa\n    \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 服务器2</span>\nHost 131\n    HostName 10.122.48.131\n    Port 22\n    User root\n    IdentityFile /home/test/.ssh/id_rsa</code></pre>\n\n<p>在请求端Client上执行 <code>ssh 130</code>相当于执行<code>ssh root@10.122.48.130</code>并且不需要密码。</p>\n</li>\n</ol>\n<h3 id=\"AutoSSH\"><a href=\"#AutoSSH\" class=\"headerlink\" title=\"AutoSSH\"></a>AutoSSH</h3><p>ssh的反向穿透技术，可以实现内网服务在公网上提供服务。ssh一般用来客户端远程登录到服务器上，而ssh反向穿透“反其道而行之”，由服务端主动发起请求连接客户端，然后在客户端打开一个端口，之后发往客户端的数据包将会转发到服务端。但是ssh不支持自动重连功能，这时我们就可以用上autossh了。</p>\n<p>我们可以利用autossh将内网端口映射到外网上。由于autossh 并不是Linux自带的，所以需要自己编译安装。</p>\n<p>在内网机器B上进行编译安装</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">1.将autossh下载到服务器B上</span>\nwget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n<span class=\"hljs-meta\">#</span><span class=\"bash\">2.解压</span>\ntar xzvf autossh-1.4e.tgz\n<span class=\"hljs-meta\">#</span><span class=\"bash\">3. 编译安装</span>\n cd autossh-1.4e\n ./configure\n make\n make install</code></pre>\n\n<p>将内网机器B的公钥添加到公网机器A上</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 如果没生成过公钥执行生成公钥</span>\nssh-keygen\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 将内网机器B的公钥添加到公网机器上</span>\nssh-copy-id -i ~/.ssh/id_rsa.pub user@hostA</code></pre>\n\n<p>在内网机器使用autossh</p>\n<pre><code class=\"hljs shell\">autossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa use@hostA</code></pre>\n\n<p>参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连</p>\n<p>后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口</p>\n<p>到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。</p>\n","site":{"data":{}},"excerpt":"","more":"<p> 做后端开发经常遇到一个情况是使用公司的虚拟机很多，每次都要记住用户名密码和IP是一件很麻烦的事情，所以在想有没有一种能够免密快速ssh的方式？</p>\n<h3 id=\"什么是SSH\"><a href=\"#什么是SSH\" class=\"headerlink\" title=\"什么是SSH\"></a>什么是SSH</h3><p>简单来说SSH 是一种网络协议，用于计算机之间的加密登录，早起的互联网通信都是明文通信的，一旦被截获密码就泄露出去了。于是就有了SSH协议，将登录信息全部加密。目前SSH协议已经在全世界广泛使用了，且成为各个L inux发行版本的标配。（桌面版本的Linux不支持SSH，需要安装OpenSSH）</p>\n<h3 id=\"SSH的过程\"><a href=\"#SSH的过程\" class=\"headerlink\" title=\"SSH的过程\"></a>SSH的过程</h3><p>SSH 默认使用的是RSA加密算法</p>\n<ol>\n<li>请求主机Client用户使用<code>ssh user@host</code>命令对远程Server发起登录</li>\n<li>远程主机将自己的公钥返回给请求主机</li>\n<li>请求主机使用公钥对用户输入的密码进行加密</li>\n<li>请求主机将加密后的信息发送给远程主机</li>\n<li>远程主机使用私钥对密码进行解密</li>\n<li>最后，远程主机判断解密后的密码是否与用户密码一致，一致就同意登陆，否则反之</li>\n</ol>\n<pre><code class=\"hljs mermaid\">sequenceDiagram\n    autonumber\n    Client-&gt;&gt;Server: ssh user@host\n    Server-&gt;&gt;Client: return public_key\n    Client-&gt;&gt;Client: use public_key encrypt password\n    Client-&gt;&gt;Server: send encrypted password\n    Server-&gt;&gt;Server: use private_key decrypt password\n    Server-&gt;&gt;Server: check password</code></pre>\n\n<p>整个过程看上去没啥问题，但是相比HTTPS 协议安全性是稍差的，那是因为SSH协议没用CA证书签发机构，很容利用自签的证书来截获请求冒充远程主机来取得登录密码的。SSH发现这个问题之后，想了一个办法来绕开这个问题。引入了know_hosts。</p>\n<h3 id=\"know-hosts作用\"><a href=\"#know-hosts作用\" class=\"headerlink\" title=\"know_hosts作用\"></a>know_hosts作用</h3><p>在第一次ssh的时候我们都会看到这样的一个提示</p>\n<pre><code class=\"hljs shell\">The authenticity of host &#x27;10.122.48.130 (10.122.48.130)&#x27; can&#x27;t be established.\nRSA key fingerprint is ee:6e:68:7d:91:8c:d8:d9:1d:ab:61:9b:5f:53:68:d3.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added &#x27;10.122.48.130&#x27; (RSA) to the list of known hosts.</code></pre>\n\n<p>这句话提示的是：无法确认主机的真实性，只知道它的公钥指纹，是否建立连接？这个方式就将主机被冒充的风险抛给了使用者。当然对公钥的核对也是一个问题，这就需要远程主机公开公钥。在上面的提示中输入<code>yes</code>之后，s sh就会将远程主机的公钥写入本地的know_hosts文件中。第二次ssh的时候就会核对这个公钥指纹，如果不一致则无法ssh 成功。</p>\n<p>具体的know_hosts内容样例，IP 加密算法 指纹信息</p>\n<pre><code class=\"hljs shell\">10.122.48.130 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6G4lMkyH4O2IcWxRmbecn6aMTi3r3+eS2W05CLT7zl3EgWyx7nYEXzWeGl7OMhW+OBDsukuMCOApcG+ge4EaQEqVEWAFn+/Dr5HwUyFFTeEj/fP/3/Xq6/3rt277iJHHSyXsWW29+e2w3OjB/eJJ20lJ4nC7fdghZw4AFSP5YVwhXPtTs2I2cX5ziP4guvpNJPCQq/DNt1uZvvsEt7jmQW8K6YixcHNTipKvhAZGZlx/soamu60WAMr8nmhLy4Svc56rLZYTYIkIvZqRzSDfqDCo9/NcOh2oaa1LBUJBD3hZ9F7lpxnfS6tpHEnowGb1wQtdFhLfJ7gGvTzGeAFRow==</code></pre>\n\n<p>之前遇到过这样的一个问题，以前已经添加了know_hosts的IP，发现远程主机指纹变化了，导致无法ssh，这时需要将对应IP的这样一行删除即可。主机指纹变化有可能是系统重装，也有可能是IP被其他机器获取了。</p>\n<p>Know_hosts文件是在没用用户下的<code>～/.ssh/know_hosts</code></p>\n<h3 id=\"别名免密登录\"><a href=\"#别名免密登录\" class=\"headerlink\" title=\"别名免密登录\"></a>别名免密登录</h3><h4 id=\"免密登录的公钥认证过程\"><a href=\"#免密登录的公钥认证过程\" class=\"headerlink\" title=\"免密登录的公钥认证过程\"></a>免密登录的公钥认证过程</h4><ol>\n<li>请求机Client将自己的公钥存储在远程机Server的authorized_keys中</li>\n<li>远程机在收到请求机的请求后，会在 authorized_keys 中匹配到 Client 的公钥 pubKey，并生成随机数 R，用 Client 的公钥对该随机数进行加密得到 pubKey(R)，然后将加密后信息发送给 Client。</li>\n<li>Client 端通过私钥进行解密得到随机数 R，然后对随机数 R 和本次会话的 SessionKey 利用 MD5 生成摘要 Digest1，发送给 Server 端。</li>\n<li>Server 端会也会对 R 和 SessionKey 利用同样摘要算法生成 Digest2。</li>\n<li>Server 端会最后比较 Digest1 和 Digest2 是否相同，完成认证过程。</li>\n</ol>\n<pre><code class=\"hljs mermaid\">sequenceDiagram\n    Client --&gt;&gt;Server: add client public_key to server\n    Server-&gt;&gt;Client: return client public_key(R)\n    Client-&gt;&gt;Client: private_key decrypt R\n    Client-&gt;&gt;Server: send MD5(R+sessionKey)\n    Server-&gt;&gt;Server: MD5(R+sessionKey)\n    Server-&gt;&gt;Server: check Digest1 Digest2</code></pre>\n\n<h4 id=\"ssh-免密登录应用\"><a href=\"#ssh-免密登录应用\" class=\"headerlink\" title=\"ssh 免密登录应用\"></a>ssh 免密登录应用</h4><ol>\n<li><p>请求端Client生成自己的公私钥</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 如果不想设置指定信息，一路回车即可</span>\nssh-keygen</code></pre>\n\n<p>可以在请求端Client的当前用户目录下的.ssh文件下看到id_rsa 和id_rsa.pub文件</p>\n</li>\n<li><p>将自己的公钥添加到远程主机Server上</p>\n<pre><code class=\"hljs shell\">ssh-copy-id -i ~/.ssh/id_rsa.pub user@host</code></pre>\n\n<p>在远处主机的用户目录下的.ssh 下有authorized_keys文件</p>\n</li>\n<li><p>在上面两步完成后已经可以进行免密登录了，但是还是需要指定用户和IP。想要添加别名登录的话，需要在请求端Client的～/.ssh下创建config文件。config文件配置如下</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 服务器1</span>\nHost 130\n    HostName 10.122.48.130\n    Port 22\n    User root\n    IdentityFile /home/test/.ssh/id_rsa\n    \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 服务器2</span>\nHost 131\n    HostName 10.122.48.131\n    Port 22\n    User root\n    IdentityFile /home/test/.ssh/id_rsa</code></pre>\n\n<p>在请求端Client上执行 <code>ssh 130</code>相当于执行<code>ssh root@10.122.48.130</code>并且不需要密码。</p>\n</li>\n</ol>\n<h3 id=\"AutoSSH\"><a href=\"#AutoSSH\" class=\"headerlink\" title=\"AutoSSH\"></a>AutoSSH</h3><p>ssh的反向穿透技术，可以实现内网服务在公网上提供服务。ssh一般用来客户端远程登录到服务器上，而ssh反向穿透“反其道而行之”，由服务端主动发起请求连接客户端，然后在客户端打开一个端口，之后发往客户端的数据包将会转发到服务端。但是ssh不支持自动重连功能，这时我们就可以用上autossh了。</p>\n<p>我们可以利用autossh将内网端口映射到外网上。由于autossh 并不是Linux自带的，所以需要自己编译安装。</p>\n<p>在内网机器B上进行编译安装</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">1.将autossh下载到服务器B上</span>\nwget http://fossies.org/Linux/privat/autossh-1.4e.tgz\n<span class=\"hljs-meta\">#</span><span class=\"bash\">2.解压</span>\ntar xzvf autossh-1.4e.tgz\n<span class=\"hljs-meta\">#</span><span class=\"bash\">3. 编译安装</span>\n cd autossh-1.4e\n ./configure\n make\n make install</code></pre>\n\n<p>将内网机器B的公钥添加到公网机器A上</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 如果没生成过公钥执行生成公钥</span>\nssh-keygen\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 将内网机器B的公钥添加到公网机器上</span>\nssh-copy-id -i ~/.ssh/id_rsa.pub user@hostA</code></pre>\n\n<p>在内网机器使用autossh</p>\n<pre><code class=\"hljs shell\">autossh -M 10000 -NR 9200:localhost:9200 -i ~/.ssh/id_rsa use@hostA</code></pre>\n\n<p>参数说明：-M 参数指定监听这个反向链接的端口，如果断了会自动重连</p>\n<p>后面的两个9200端口分别是指定公网上暴露的端口后内网暴露的端口</p>\n<p>到了这个整个工作就完成了，这时访问公网IP的9200端口，就会访问内网中9200端口的服务。</p>\n"},{"title":"supervisor","date":"2017-04-28T03:24:12.000Z","index_img":["/images/shell/002_supervisor_1.jpg"],"_content":"\n###  简介\n\nSupervisor 是一个客户端/服务器系统，允许其用户监视和控制类似UNIX的操作系统上的多个进程。说的简单一点就是可以将supervisor 来启动/停止子进程。子进程退出了，supervisor 可以将子进程重新拉起。\n\n### 介绍\n\n具体的安装方式参考[官网](http://supervisord.org/installing.html)\n\n#### 组成\n\nsupervisor工具分两个\n\n一个是supervisord，supervisord  是父进程，如果这个进程没有启动整个supervisor是无法使用的。\n\n一个是supervisorctl ，这个是管理的命令工具，管理子进程都是用该工具进行管理。\n\n#### supervisord的配置文件\n\nsupervisord的配置文件一般是在 `/etc/supervisord.conf`中，如果不知道配置文件位置，可以在/etc/init.d/supervisord中start函数中查看到。\n\n```shell\nstart()\n{\n       echo -n $\"Starting $prog: \"\n       touch $PIDFILE\n       daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE\n       sleep 1\n       [ -f $PIDFILE ] && success $\"$prog startup\" || failure $\"$prog startup\"\n       echo\n}\n```\n\n/etc/supervisord.conf 中可以将supervisord要监听的端口关闭，使得supervisord不占用端口。\n\n```shell\n;[inet_http_server]\n;port=127.0.0.1:9001\n```\n\n/etc/supervisord.conf  也可以配置子进程的配置文件路径，这里默认的是在/etc/supervisord.conf.d/目录下\n\n```shell\n[include]\nfiles = /etc/supervisord.conf.d/*.conf\n```\n\n#### supervisor子进程的配置文件\n\n子进程的配置文件，位置是在/etc/supervisord.conf中设置的，具体看子进程的配置文件如下\n\n```shell\n[program:liveness] # 子进程的标识\ndirectory= /opt/faceid/worker#子进程的工作目录\ncommand= /opt/faceid/worker/start.sh#子进程的启动命令或脚本\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=7#启动时间\nnumprocs= 1 # 启动这个进程的数量，一般不写，\nprocess_name=%(program_name)s_%(process_num)s # 如果numprocs设置了多个，这里就可以区分多个名称liveness:liveness_0\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=500MB\nstdout_logfile_backups=10\nstdout_logfile=/var/log/megvii/%(program_name)s_%(process_num)02d.log#日志路径\n```\n\n当然一个配置文件，可以写很多个进程启动配置。格式和上面一样。\n\n#### supervisorctl 命令使用\n\n- supervisorctl status 查看各个进程的状态\n- supervisorctl reload 重启supervisor 下的所有进程\n- supervisorctl stop name 停止指定进程\n- supervisorctl start name 启动指定进程\n- supervisorctl restart all  重启supervisor 下的所有进程\n\n### 遇到过的问题\n\n1. 遇到一个情况，明明已经通过supervisorctl stop all把服务全部停了，然后还是发现端口还在被占用，服务还正常提供\n\n   这个是应为supervisord 除了当前用户在用外，还有其他用户在使用。导致这个问题的出现。解决办法是明确supervisord是有多个用户在使用。将其他用户的supervisord停止即可。\n\n2. 给普通用户添加supervisorctl 管理权限\n\n   - 修改supervisor.sock 文件的权限，该文件supervisorctl用XML_RPC和supervisord通信就是通过它进行的。如果不设置的话，supervisorctl也就不能用了\n\n     如果需要给所有用户权限则修改/etc/supervisord.conf中[unix_http_server]\n     ;chmod=0700\n     去掉;， 修改为chmod=0777\n\n   - 给普通用户添加supervisorctl  执行权限出现supervisorctl 命令不可用\n\n     root用户下执行 **chmod 707 /usr/bin/supervisorctl**\n\n     **chmod -R 707 /usr/lib/python2.7/sit-package**\n\n   - 然后使用supervisorctl status 出现pkg_resources.DistributionNotFound:supervisor==3.2.0错误\n\n     chmod -R 705 /usr/lib/python2.6/site-packages/*.egg\n\n3. 找不到`unix:///tmp/supervisor.sock no such file`\n\n   重启supervisord 服务，service 或者systemctl 命令都行\n\n","source":"_posts/002_supervisor.md","raw":"---\ntitle: supervisor\ndate: 2017-04-28 11:24:12\nindex_img:\n- /images/shell/002_supervisor_1.jpg\ntags: \n- Python\ncategories:\n- 开源工具\n---\n\n###  简介\n\nSupervisor 是一个客户端/服务器系统，允许其用户监视和控制类似UNIX的操作系统上的多个进程。说的简单一点就是可以将supervisor 来启动/停止子进程。子进程退出了，supervisor 可以将子进程重新拉起。\n\n### 介绍\n\n具体的安装方式参考[官网](http://supervisord.org/installing.html)\n\n#### 组成\n\nsupervisor工具分两个\n\n一个是supervisord，supervisord  是父进程，如果这个进程没有启动整个supervisor是无法使用的。\n\n一个是supervisorctl ，这个是管理的命令工具，管理子进程都是用该工具进行管理。\n\n#### supervisord的配置文件\n\nsupervisord的配置文件一般是在 `/etc/supervisord.conf`中，如果不知道配置文件位置，可以在/etc/init.d/supervisord中start函数中查看到。\n\n```shell\nstart()\n{\n       echo -n $\"Starting $prog: \"\n       touch $PIDFILE\n       daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE\n       sleep 1\n       [ -f $PIDFILE ] && success $\"$prog startup\" || failure $\"$prog startup\"\n       echo\n}\n```\n\n/etc/supervisord.conf 中可以将supervisord要监听的端口关闭，使得supervisord不占用端口。\n\n```shell\n;[inet_http_server]\n;port=127.0.0.1:9001\n```\n\n/etc/supervisord.conf  也可以配置子进程的配置文件路径，这里默认的是在/etc/supervisord.conf.d/目录下\n\n```shell\n[include]\nfiles = /etc/supervisord.conf.d/*.conf\n```\n\n#### supervisor子进程的配置文件\n\n子进程的配置文件，位置是在/etc/supervisord.conf中设置的，具体看子进程的配置文件如下\n\n```shell\n[program:liveness] # 子进程的标识\ndirectory= /opt/faceid/worker#子进程的工作目录\ncommand= /opt/faceid/worker/start.sh#子进程的启动命令或脚本\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=7#启动时间\nnumprocs= 1 # 启动这个进程的数量，一般不写，\nprocess_name=%(program_name)s_%(process_num)s # 如果numprocs设置了多个，这里就可以区分多个名称liveness:liveness_0\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=500MB\nstdout_logfile_backups=10\nstdout_logfile=/var/log/megvii/%(program_name)s_%(process_num)02d.log#日志路径\n```\n\n当然一个配置文件，可以写很多个进程启动配置。格式和上面一样。\n\n#### supervisorctl 命令使用\n\n- supervisorctl status 查看各个进程的状态\n- supervisorctl reload 重启supervisor 下的所有进程\n- supervisorctl stop name 停止指定进程\n- supervisorctl start name 启动指定进程\n- supervisorctl restart all  重启supervisor 下的所有进程\n\n### 遇到过的问题\n\n1. 遇到一个情况，明明已经通过supervisorctl stop all把服务全部停了，然后还是发现端口还在被占用，服务还正常提供\n\n   这个是应为supervisord 除了当前用户在用外，还有其他用户在使用。导致这个问题的出现。解决办法是明确supervisord是有多个用户在使用。将其他用户的supervisord停止即可。\n\n2. 给普通用户添加supervisorctl 管理权限\n\n   - 修改supervisor.sock 文件的权限，该文件supervisorctl用XML_RPC和supervisord通信就是通过它进行的。如果不设置的话，supervisorctl也就不能用了\n\n     如果需要给所有用户权限则修改/etc/supervisord.conf中[unix_http_server]\n     ;chmod=0700\n     去掉;， 修改为chmod=0777\n\n   - 给普通用户添加supervisorctl  执行权限出现supervisorctl 命令不可用\n\n     root用户下执行 **chmod 707 /usr/bin/supervisorctl**\n\n     **chmod -R 707 /usr/lib/python2.7/sit-package**\n\n   - 然后使用supervisorctl status 出现pkg_resources.DistributionNotFound:supervisor==3.2.0错误\n\n     chmod -R 705 /usr/lib/python2.6/site-packages/*.egg\n\n3. 找不到`unix:///tmp/supervisor.sock no such file`\n\n   重启supervisord 服务，service 或者systemctl 命令都行\n\n","slug":"002_supervisor","published":1,"updated":"2021-03-08T11:00:36.872Z","_id":"ckm0h4bfu000019ym8pk6cdzt","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Supervisor 是一个客户端/服务器系统，允许其用户监视和控制类似UNIX的操作系统上的多个进程。说的简单一点就是可以将supervisor 来启动/停止子进程。子进程退出了，supervisor 可以将子进程重新拉起。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>具体的安装方式参考<a href=\"http://supervisord.org/installing.html\">官网</a></p>\n<h4 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h4><p>supervisor工具分两个</p>\n<p>一个是supervisord，supervisord  是父进程，如果这个进程没有启动整个supervisor是无法使用的。</p>\n<p>一个是supervisorctl ，这个是管理的命令工具，管理子进程都是用该工具进行管理。</p>\n<h4 id=\"supervisord的配置文件\"><a href=\"#supervisord的配置文件\" class=\"headerlink\" title=\"supervisord的配置文件\"></a>supervisord的配置文件</h4><p>supervisord的配置文件一般是在 <code>/etc/supervisord.conf</code>中，如果不知道配置文件位置，可以在/etc/init.d/supervisord中start函数中查看到。</p>\n<pre><code class=\"hljs shell\">start()\n&#123;\n       echo -n $&quot;Starting $prog: &quot;\n       touch $PIDFILE\n       daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE\n       sleep 1\n       [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;\n       echo\n&#125;</code></pre>\n\n<p>/etc/supervisord.conf 中可以将supervisord要监听的端口关闭，使得supervisord不占用端口。</p>\n<pre><code class=\"hljs shell\">;[inet_http_server]\n;port=127.0.0.1:9001</code></pre>\n\n<p>/etc/supervisord.conf  也可以配置子进程的配置文件路径，这里默认的是在/etc/supervisord.conf.d/目录下</p>\n<pre><code class=\"hljs shell\">[include]\nfiles = /etc/supervisord.conf.d/*.conf</code></pre>\n\n<h4 id=\"supervisor子进程的配置文件\"><a href=\"#supervisor子进程的配置文件\" class=\"headerlink\" title=\"supervisor子进程的配置文件\"></a>supervisor子进程的配置文件</h4><p>子进程的配置文件，位置是在/etc/supervisord.conf中设置的，具体看子进程的配置文件如下</p>\n<pre><code class=\"hljs shell\">[program:liveness] # 子进程的标识\ndirectory= /opt/faceid/worker#子进程的工作目录\ncommand= /opt/faceid/worker/start.sh#子进程的启动命令或脚本\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=7#启动时间\nnumprocs= 1 # 启动这个进程的数量，一般不写，\nprocess_name=%(program_name)s_%(process_num)s # 如果numprocs设置了多个，这里就可以区分多个名称liveness:liveness_0\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=500MB\nstdout_logfile_backups=10\nstdout_logfile=/var/log/megvii/%(program_name)s_%(process_num)02d.log#日志路径</code></pre>\n\n<p>当然一个配置文件，可以写很多个进程启动配置。格式和上面一样。</p>\n<h4 id=\"supervisorctl-命令使用\"><a href=\"#supervisorctl-命令使用\" class=\"headerlink\" title=\"supervisorctl 命令使用\"></a>supervisorctl 命令使用</h4><ul>\n<li>supervisorctl status 查看各个进程的状态</li>\n<li>supervisorctl reload 重启supervisor 下的所有进程</li>\n<li>supervisorctl stop name 停止指定进程</li>\n<li>supervisorctl start name 启动指定进程</li>\n<li>supervisorctl restart all  重启supervisor 下的所有进程</li>\n</ul>\n<h3 id=\"遇到过的问题\"><a href=\"#遇到过的问题\" class=\"headerlink\" title=\"遇到过的问题\"></a>遇到过的问题</h3><ol>\n<li><p>遇到一个情况，明明已经通过supervisorctl stop all把服务全部停了，然后还是发现端口还在被占用，服务还正常提供</p>\n<p>这个是应为supervisord 除了当前用户在用外，还有其他用户在使用。导致这个问题的出现。解决办法是明确supervisord是有多个用户在使用。将其他用户的supervisord停止即可。</p>\n</li>\n<li><p>给普通用户添加supervisorctl 管理权限</p>\n<ul>\n<li><p>修改supervisor.sock 文件的权限，该文件supervisorctl用XML_RPC和supervisord通信就是通过它进行的。如果不设置的话，supervisorctl也就不能用了</p>\n<p>如果需要给所有用户权限则修改/etc/supervisord.conf中[unix_http_server]<br>;chmod=0700<br>去掉;， 修改为chmod=0777</p>\n</li>\n<li><p>给普通用户添加supervisorctl  执行权限出现supervisorctl 命令不可用</p>\n<p>root用户下执行 <strong>chmod 707 /usr/bin/supervisorctl</strong></p>\n<p><strong>chmod -R 707 /usr/lib/python2.7/sit-package</strong></p>\n</li>\n<li><p>然后使用supervisorctl status 出现pkg_resources.DistributionNotFound:supervisor==3.2.0错误</p>\n<p>chmod -R 705 /usr/lib/python2.6/site-packages/*.egg</p>\n</li>\n</ul>\n</li>\n<li><p>找不到<code>unix:///tmp/supervisor.sock no such file</code></p>\n<p>重启supervisord 服务，service 或者systemctl 命令都行</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Supervisor 是一个客户端/服务器系统，允许其用户监视和控制类似UNIX的操作系统上的多个进程。说的简单一点就是可以将supervisor 来启动/停止子进程。子进程退出了，supervisor 可以将子进程重新拉起。</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>具体的安装方式参考<a href=\"http://supervisord.org/installing.html\">官网</a></p>\n<h4 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h4><p>supervisor工具分两个</p>\n<p>一个是supervisord，supervisord  是父进程，如果这个进程没有启动整个supervisor是无法使用的。</p>\n<p>一个是supervisorctl ，这个是管理的命令工具，管理子进程都是用该工具进行管理。</p>\n<h4 id=\"supervisord的配置文件\"><a href=\"#supervisord的配置文件\" class=\"headerlink\" title=\"supervisord的配置文件\"></a>supervisord的配置文件</h4><p>supervisord的配置文件一般是在 <code>/etc/supervisord.conf</code>中，如果不知道配置文件位置，可以在/etc/init.d/supervisord中start函数中查看到。</p>\n<pre><code class=\"hljs shell\">start()\n&#123;\n       echo -n $&quot;Starting $prog: &quot;\n       touch $PIDFILE\n       daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE\n       sleep 1\n       [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;\n       echo\n&#125;</code></pre>\n\n<p>/etc/supervisord.conf 中可以将supervisord要监听的端口关闭，使得supervisord不占用端口。</p>\n<pre><code class=\"hljs shell\">;[inet_http_server]\n;port=127.0.0.1:9001</code></pre>\n\n<p>/etc/supervisord.conf  也可以配置子进程的配置文件路径，这里默认的是在/etc/supervisord.conf.d/目录下</p>\n<pre><code class=\"hljs shell\">[include]\nfiles = /etc/supervisord.conf.d/*.conf</code></pre>\n\n<h4 id=\"supervisor子进程的配置文件\"><a href=\"#supervisor子进程的配置文件\" class=\"headerlink\" title=\"supervisor子进程的配置文件\"></a>supervisor子进程的配置文件</h4><p>子进程的配置文件，位置是在/etc/supervisord.conf中设置的，具体看子进程的配置文件如下</p>\n<pre><code class=\"hljs shell\">[program:liveness] # 子进程的标识\ndirectory= /opt/faceid/worker#子进程的工作目录\ncommand= /opt/faceid/worker/start.sh#子进程的启动命令或脚本\nautostart=true#是否自启\nautorestart=true#是否自动重启\nstartretries= 10000#重试次数\nstartsecs=7#启动时间\nnumprocs= 1 # 启动这个进程的数量，一般不写，\nprocess_name=%(program_name)s_%(process_num)s # 如果numprocs设置了多个，这里就可以区分多个名称liveness:liveness_0\nstopasgroup=true\nkillasgroup=true\nstdout_logfile_maxbytes=500MB\nstdout_logfile_backups=10\nstdout_logfile=/var/log/megvii/%(program_name)s_%(process_num)02d.log#日志路径</code></pre>\n\n<p>当然一个配置文件，可以写很多个进程启动配置。格式和上面一样。</p>\n<h4 id=\"supervisorctl-命令使用\"><a href=\"#supervisorctl-命令使用\" class=\"headerlink\" title=\"supervisorctl 命令使用\"></a>supervisorctl 命令使用</h4><ul>\n<li>supervisorctl status 查看各个进程的状态</li>\n<li>supervisorctl reload 重启supervisor 下的所有进程</li>\n<li>supervisorctl stop name 停止指定进程</li>\n<li>supervisorctl start name 启动指定进程</li>\n<li>supervisorctl restart all  重启supervisor 下的所有进程</li>\n</ul>\n<h3 id=\"遇到过的问题\"><a href=\"#遇到过的问题\" class=\"headerlink\" title=\"遇到过的问题\"></a>遇到过的问题</h3><ol>\n<li><p>遇到一个情况，明明已经通过supervisorctl stop all把服务全部停了，然后还是发现端口还在被占用，服务还正常提供</p>\n<p>这个是应为supervisord 除了当前用户在用外，还有其他用户在使用。导致这个问题的出现。解决办法是明确supervisord是有多个用户在使用。将其他用户的supervisord停止即可。</p>\n</li>\n<li><p>给普通用户添加supervisorctl 管理权限</p>\n<ul>\n<li><p>修改supervisor.sock 文件的权限，该文件supervisorctl用XML_RPC和supervisord通信就是通过它进行的。如果不设置的话，supervisorctl也就不能用了</p>\n<p>如果需要给所有用户权限则修改/etc/supervisord.conf中[unix_http_server]<br>;chmod=0700<br>去掉;， 修改为chmod=0777</p>\n</li>\n<li><p>给普通用户添加supervisorctl  执行权限出现supervisorctl 命令不可用</p>\n<p>root用户下执行 <strong>chmod 707 /usr/bin/supervisorctl</strong></p>\n<p><strong>chmod -R 707 /usr/lib/python2.7/sit-package</strong></p>\n</li>\n<li><p>然后使用supervisorctl status 出现pkg_resources.DistributionNotFound:supervisor==3.2.0错误</p>\n<p>chmod -R 705 /usr/lib/python2.6/site-packages/*.egg</p>\n</li>\n</ul>\n</li>\n<li><p>找不到<code>unix:///tmp/supervisor.sock no such file</code></p>\n<p>重启supervisord 服务，service 或者systemctl 命令都行</p>\n</li>\n</ol>\n"},{"title":"ffmpeg","date":"2017-05-22T06:34:12.000Z","index_img":["/images/shell/003_ffmpeg_1.jpg"],"_content":"\n### 音视频的基础概念\n\n在开始使用ffmpeg 之前，我们需要对音视频一些基本概念有一定的了解。\n\n1. 编码和格式\n\n   很多人会把这两个概念混淆在一起，因为编码和格式有不少相同的命名，但他们是两个概念。\n\n   - **编码codec :**是对图像和声音进行压缩的方法。与之对应的是**解码**。常见的编码有H264，H265，MPEG等\n   - **格式（容器）**：是将不同编码后的信息打包在一起。常用的格式有mp4，avi，mkv等\n\n2. 流\n\n   一般来说，视频文件很大，很难全部一次性读进内存，只能一点一点的读。操作系统对文件的操作就是基于**流**的抽象。\n\n3. 帧\n\n   我们知道传统的动画是有一张一张图画持续滚动的。基于这个原理我们能够理解帧其实就是这一张一张的图画。当然这只是一个基本的概念，实际上的ffmpeg上的帧有更多的含义。\n\n### ffmpeg是什么 \n\nffmpeg 是一个命令行工具同时也是一个开源库，开发者可以基于现有的库进行二次开发。\n\nFfmpeg 安装可以自行下载使用系统安装对应的安装包[官网下载](https://ffmpeg.org/download.html)\n\n### 命令行使用\n\n**关于FFmpeg的具体技术及参数细节，可以参考**[**ffmpeg官方文档**](https://ffmpeg.org/documentation.html)**，以下介绍一些常用的ffmpeg命令。**\n\n1. 打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用\n\n   ```shell\n   # 查看ffmpeg 帮助信息\n   ffmpeg -help\n   # 查看ffmpeg 支持的格式\n   ffmpeg -formats\n   # 查看ffmpeg支持的编码格式\n   ffmpeg -codecs\n   ```\n\n    usage: ffmpeg [options][[infile options] -i infile]... {[outfile options] outfile}… 这句是说ffmpeg 的主要用法\n\n2. H264编码的其他格式转换TS\n\n   ```shell\n   ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\n   ffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts\n   ```\n\n   说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。\n\n   -vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。\n\n3. 视频转帧图片\n\n   ```shell\n   ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png\n   ```\n\n   将视频中每一帧切出来，可用作测试人脸检测模块。\n\n   -r：表示帧率，25即每秒25帧来处理帧。\n\n   -f：表示输出格式，此处为image2格式。\n\n    ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。\n\n   批量转图：\n\n   ```shell\n   find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -r 25 -f image2 ./path/%05d{}.png\n   ```\n\n   视频帧转YUV数据\n\n   ```shell\n   ffmpeg -i a.mp4 -f segment -segment_time 0.01 -r 30 -pix_fmt nv21 ./path\n   ```\n\n4. 帧图片转视频\n\n      ```shell\n      ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts\n      ```\n\n      将连续的帧图片，转制为视频。\n\n5. 视频帧率处理\n\n      ```shell\n      ffmpeg -i input.ts -vcode h264 -r 20 output.ts\n      ```\n\n      模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。\n\n6. 从相机视频流录制ts或mp4格式的视频\n\n      ```shell\n      ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts\n      ```\n\n      说明：tcp协议\n\n7. 截取视频指令\n\n      ```shell\n      ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT\n      ```\n\n      说明：\n\n      ​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05\n\n      ​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10\n\n8. 合并视频指令\n\n      ```shell\n      ffmpeg -i \"concat:intermediate1.ts|intermediate2.ts\" -c copy -bsf:a aac_adtstoasc output.ts\n      ```\n\n9. 视频旋转\n\n   ```shell\n   find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -vf \"transpose=1\" -vcodec libx264 -an ./rota/{}\n   ```\n\n10. 图片旋转\n\n      ```shell\n      convert example.jpg -rotate 90 example-rotated.jpg\n      ```\n\n11. 图片等比缩小\n\n       ```shell\n       convert k.jpg -resize 50% k2.jpg\n       ```\n12. 获取视频文件的帧数\n       ```shell\n          ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2>&1 | grep 'frame='\n       ```\n\n   [文章参考](https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh) \n\n### 搭建rtsp视频流服务\n\n利用live555工具提供rtsp服务，需要从官网下载[live555源码](http://www.live555.com/liveMedia/public/live555-latest.tar.gz)进行编译成可执行文件。\n\n```shell\n# 将源码解压\ntar xzf live555-latest.tar.gz\ncd live\n# 生成编译Linux 64位执行程序的Makefile。编译macos ./genMakefiles macosx\n./genMakefiles linux-64bit \n# 编译\nmake\n```\n\n编译完成后会在当前目录下生成`live555MediaServer`可执行文件。该文件可以放到任何一个Linux64位系统下使用。通过执行`live555MediaServer`可提供服务。\n\n举个例子\n利用ffmpeg 将一个mp4 文件转成ts格式文件\n\n```shell\nffmpeg -i a.mp4 -vcodec copy a.ts\n```\n\n将a.ts 和 `live555MediaServer`放在同一个文件夹下就可对外提供rtsp服务。具体地址**rtsp://ip/a.st**\n\n\n","source":"_posts/003_ffmpeg.md","raw":"---\ntitle: ffmpeg\ndate: 2017-05-22 14:34:12\nindex_img:\n- /images/shell/003_ffmpeg_1.jpg\ntags: \n- shell\ncategories:\n- 开源工具\n---\n\n### 音视频的基础概念\n\n在开始使用ffmpeg 之前，我们需要对音视频一些基本概念有一定的了解。\n\n1. 编码和格式\n\n   很多人会把这两个概念混淆在一起，因为编码和格式有不少相同的命名，但他们是两个概念。\n\n   - **编码codec :**是对图像和声音进行压缩的方法。与之对应的是**解码**。常见的编码有H264，H265，MPEG等\n   - **格式（容器）**：是将不同编码后的信息打包在一起。常用的格式有mp4，avi，mkv等\n\n2. 流\n\n   一般来说，视频文件很大，很难全部一次性读进内存，只能一点一点的读。操作系统对文件的操作就是基于**流**的抽象。\n\n3. 帧\n\n   我们知道传统的动画是有一张一张图画持续滚动的。基于这个原理我们能够理解帧其实就是这一张一张的图画。当然这只是一个基本的概念，实际上的ffmpeg上的帧有更多的含义。\n\n### ffmpeg是什么 \n\nffmpeg 是一个命令行工具同时也是一个开源库，开发者可以基于现有的库进行二次开发。\n\nFfmpeg 安装可以自行下载使用系统安装对应的安装包[官网下载](https://ffmpeg.org/download.html)\n\n### 命令行使用\n\n**关于FFmpeg的具体技术及参数细节，可以参考**[**ffmpeg官方文档**](https://ffmpeg.org/documentation.html)**，以下介绍一些常用的ffmpeg命令。**\n\n1. 打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用\n\n   ```shell\n   # 查看ffmpeg 帮助信息\n   ffmpeg -help\n   # 查看ffmpeg 支持的格式\n   ffmpeg -formats\n   # 查看ffmpeg支持的编码格式\n   ffmpeg -codecs\n   ```\n\n    usage: ffmpeg [options][[infile options] -i infile]... {[outfile options] outfile}… 这句是说ffmpeg 的主要用法\n\n2. H264编码的其他格式转换TS\n\n   ```shell\n   ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\n   ffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts\n   ```\n\n   说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。\n\n   -vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。\n\n3. 视频转帧图片\n\n   ```shell\n   ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png\n   ```\n\n   将视频中每一帧切出来，可用作测试人脸检测模块。\n\n   -r：表示帧率，25即每秒25帧来处理帧。\n\n   -f：表示输出格式，此处为image2格式。\n\n    ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。\n\n   批量转图：\n\n   ```shell\n   find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -r 25 -f image2 ./path/%05d{}.png\n   ```\n\n   视频帧转YUV数据\n\n   ```shell\n   ffmpeg -i a.mp4 -f segment -segment_time 0.01 -r 30 -pix_fmt nv21 ./path\n   ```\n\n4. 帧图片转视频\n\n      ```shell\n      ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts\n      ```\n\n      将连续的帧图片，转制为视频。\n\n5. 视频帧率处理\n\n      ```shell\n      ffmpeg -i input.ts -vcode h264 -r 20 output.ts\n      ```\n\n      模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。\n\n6. 从相机视频流录制ts或mp4格式的视频\n\n      ```shell\n      ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts\n      ```\n\n      说明：tcp协议\n\n7. 截取视频指令\n\n      ```shell\n      ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT\n      ```\n\n      说明：\n\n      ​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05\n\n      ​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10\n\n8. 合并视频指令\n\n      ```shell\n      ffmpeg -i \"concat:intermediate1.ts|intermediate2.ts\" -c copy -bsf:a aac_adtstoasc output.ts\n      ```\n\n9. 视频旋转\n\n   ```shell\n   find ./ -name \"*.mp4\" | cut -c 3- | xargs -i ffmpeg -i ./{} -vf \"transpose=1\" -vcodec libx264 -an ./rota/{}\n   ```\n\n10. 图片旋转\n\n      ```shell\n      convert example.jpg -rotate 90 example-rotated.jpg\n      ```\n\n11. 图片等比缩小\n\n       ```shell\n       convert k.jpg -resize 50% k2.jpg\n       ```\n12. 获取视频文件的帧数\n       ```shell\n          ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2>&1 | grep 'frame='\n       ```\n\n   [文章参考](https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh) \n\n### 搭建rtsp视频流服务\n\n利用live555工具提供rtsp服务，需要从官网下载[live555源码](http://www.live555.com/liveMedia/public/live555-latest.tar.gz)进行编译成可执行文件。\n\n```shell\n# 将源码解压\ntar xzf live555-latest.tar.gz\ncd live\n# 生成编译Linux 64位执行程序的Makefile。编译macos ./genMakefiles macosx\n./genMakefiles linux-64bit \n# 编译\nmake\n```\n\n编译完成后会在当前目录下生成`live555MediaServer`可执行文件。该文件可以放到任何一个Linux64位系统下使用。通过执行`live555MediaServer`可提供服务。\n\n举个例子\n利用ffmpeg 将一个mp4 文件转成ts格式文件\n\n```shell\nffmpeg -i a.mp4 -vcodec copy a.ts\n```\n\n将a.ts 和 `live555MediaServer`放在同一个文件夹下就可对外提供rtsp服务。具体地址**rtsp://ip/a.st**\n\n\n","slug":"003_ffmpeg","published":1,"updated":"2021-03-10T05:46:19.969Z","_id":"ckm1g7wpm000022ymd4f9dt6h","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"音视频的基础概念\"><a href=\"#音视频的基础概念\" class=\"headerlink\" title=\"音视频的基础概念\"></a>音视频的基础概念</h3><p>在开始使用ffmpeg 之前，我们需要对音视频一些基本概念有一定的了解。</p>\n<ol>\n<li><p>编码和格式</p>\n<p>很多人会把这两个概念混淆在一起，因为编码和格式有不少相同的命名，但他们是两个概念。</p>\n<ul>\n<li><strong>编码codec :**是对图像和声音进行压缩的方法。与之对应的是</strong>解码**。常见的编码有H264，H265，MPEG等</li>\n<li><strong>格式（容器）</strong>：是将不同编码后的信息打包在一起。常用的格式有mp4，avi，mkv等</li>\n</ul>\n</li>\n<li><p>流</p>\n<p>一般来说，视频文件很大，很难全部一次性读进内存，只能一点一点的读。操作系统对文件的操作就是基于<strong>流</strong>的抽象。</p>\n</li>\n<li><p>帧</p>\n<p>我们知道传统的动画是有一张一张图画持续滚动的。基于这个原理我们能够理解帧其实就是这一张一张的图画。当然这只是一个基本的概念，实际上的ffmpeg上的帧有更多的含义。</p>\n</li>\n</ol>\n<h3 id=\"ffmpeg是什么\"><a href=\"#ffmpeg是什么\" class=\"headerlink\" title=\"ffmpeg是什么\"></a>ffmpeg是什么</h3><p>ffmpeg 是一个命令行工具同时也是一个开源库，开发者可以基于现有的库进行二次开发。</p>\n<p>Ffmpeg 安装可以自行下载使用系统安装对应的安装包<a href=\"https://ffmpeg.org/download.html\">官网下载</a></p>\n<h3 id=\"命令行使用\"><a href=\"#命令行使用\" class=\"headerlink\" title=\"命令行使用\"></a>命令行使用</h3><p><strong>关于FFmpeg的具体技术及参数细节，可以参考</strong><a href=\"https://ffmpeg.org/documentation.html\"><strong>ffmpeg官方文档</strong></a><strong>，以下介绍一些常用的ffmpeg命令。</strong></p>\n<ol>\n<li><p>打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 查看ffmpeg 帮助信息</span>\nffmpeg -help\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 查看ffmpeg 支持的格式</span>\nffmpeg -formats\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 查看ffmpeg支持的编码格式</span>\nffmpeg -codecs</code></pre>\n\n<p> usage: ffmpeg [options][[infile options] -i infile]… {[outfile options] outfile}… 这句是说ffmpeg 的主要用法</p>\n</li>\n<li><p>H264编码的其他格式转换TS</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\nffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts</code></pre>\n\n<p>说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。</p>\n<p>-vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。</p>\n</li>\n<li><p>视频转帧图片</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png</code></pre>\n\n<p>将视频中每一帧切出来，可用作测试人脸检测模块。</p>\n<p>-r：表示帧率，25即每秒25帧来处理帧。</p>\n<p>-f：表示输出格式，此处为image2格式。</p>\n<p> ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。</p>\n<p>批量转图：</p>\n<pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -r 25 -f image2 ./path/%05d&#123;&#125;.png</code></pre>\n\n<p>视频帧转YUV数据</p>\n<pre><code class=\"hljs shell\">ffmpeg -i a.mp4 -f segment -segment_time 0.01 -r 30 -pix_fmt nv21 ./path</code></pre>\n</li>\n<li><p>帧图片转视频</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts</code></pre>\n\n<p>   将连续的帧图片，转制为视频。</p>\n</li>\n<li><p>视频帧率处理</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i input.ts -vcode h264 -r 20 output.ts</code></pre>\n\n<p>   模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。</p>\n</li>\n<li><p>从相机视频流录制ts或mp4格式的视频</p>\n   <pre><code class=\"hljs shell\">ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts</code></pre>\n\n<p>   说明：tcp协议</p>\n</li>\n<li><p>截取视频指令</p>\n   <pre><code class=\"hljs shell\">ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT</code></pre>\n\n<p>   说明：</p>\n<p>   ​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05</p>\n<p>   ​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10</p>\n</li>\n<li><p>合并视频指令</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i &quot;concat:intermediate1.ts|intermediate2.ts&quot; -c copy -bsf:a aac_adtstoasc output.ts</code></pre>\n</li>\n<li><p>视频旋转</p>\n<pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -vf &quot;transpose=1&quot; -vcodec libx264 -an ./rota/&#123;&#125;</code></pre>\n</li>\n<li><p>图片旋转</p>\n  <pre><code class=\"hljs shell\">convert example.jpg -rotate 90 example-rotated.jpg</code></pre>\n</li>\n<li><p>图片等比缩小</p>\n   <pre><code class=\"hljs shell\">convert k.jpg -resize 50% k2.jpg</code></pre></li>\n<li><p>获取视频文件的帧数</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2&gt;&amp;1 | grep &#x27;frame=&#x27;</code></pre>\n\n<p><a href=\"https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh\">文章参考</a> </p>\n</li>\n</ol>\n<h3 id=\"搭建rtsp视频流服务\"><a href=\"#搭建rtsp视频流服务\" class=\"headerlink\" title=\"搭建rtsp视频流服务\"></a>搭建rtsp视频流服务</h3><p>利用live555工具提供rtsp服务，需要从官网下载<a href=\"http://www.live555.com/liveMedia/public/live555-latest.tar.gz\">live555源码</a>进行编译成可执行文件。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 将源码解压</span>\ntar xzf live555-latest.tar.gz\ncd live\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 生成编译Linux 64位执行程序的Makefile。编译macos ./genMakefiles macosx</span>\n./genMakefiles linux-64bit \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 编译</span>\nmake</code></pre>\n\n<p>编译完成后会在当前目录下生成<code>live555MediaServer</code>可执行文件。该文件可以放到任何一个Linux64位系统下使用。通过执行<code>live555MediaServer</code>可提供服务。</p>\n<p>举个例子<br>利用ffmpeg 将一个mp4 文件转成ts格式文件</p>\n<pre><code class=\"hljs shell\">ffmpeg -i a.mp4 -vcodec copy a.ts</code></pre>\n\n<p>将a.ts 和 <code>live555MediaServer</code>放在同一个文件夹下就可对外提供rtsp服务。具体地址<strong>rtsp://ip/a.st</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"音视频的基础概念\"><a href=\"#音视频的基础概念\" class=\"headerlink\" title=\"音视频的基础概念\"></a>音视频的基础概念</h3><p>在开始使用ffmpeg 之前，我们需要对音视频一些基本概念有一定的了解。</p>\n<ol>\n<li><p>编码和格式</p>\n<p>很多人会把这两个概念混淆在一起，因为编码和格式有不少相同的命名，但他们是两个概念。</p>\n<ul>\n<li><strong>编码codec :**是对图像和声音进行压缩的方法。与之对应的是</strong>解码**。常见的编码有H264，H265，MPEG等</li>\n<li><strong>格式（容器）</strong>：是将不同编码后的信息打包在一起。常用的格式有mp4，avi，mkv等</li>\n</ul>\n</li>\n<li><p>流</p>\n<p>一般来说，视频文件很大，很难全部一次性读进内存，只能一点一点的读。操作系统对文件的操作就是基于<strong>流</strong>的抽象。</p>\n</li>\n<li><p>帧</p>\n<p>我们知道传统的动画是有一张一张图画持续滚动的。基于这个原理我们能够理解帧其实就是这一张一张的图画。当然这只是一个基本的概念，实际上的ffmpeg上的帧有更多的含义。</p>\n</li>\n</ol>\n<h3 id=\"ffmpeg是什么\"><a href=\"#ffmpeg是什么\" class=\"headerlink\" title=\"ffmpeg是什么\"></a>ffmpeg是什么</h3><p>ffmpeg 是一个命令行工具同时也是一个开源库，开发者可以基于现有的库进行二次开发。</p>\n<p>Ffmpeg 安装可以自行下载使用系统安装对应的安装包<a href=\"https://ffmpeg.org/download.html\">官网下载</a></p>\n<h3 id=\"命令行使用\"><a href=\"#命令行使用\" class=\"headerlink\" title=\"命令行使用\"></a>命令行使用</h3><p><strong>关于FFmpeg的具体技术及参数细节，可以参考</strong><a href=\"https://ffmpeg.org/documentation.html\"><strong>ffmpeg官方文档</strong></a><strong>，以下介绍一些常用的ffmpeg命令。</strong></p>\n<ol>\n<li><p>打开终端，查看ffmpeg帮助文档，简要了解ffmpeg的使用</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 查看ffmpeg 帮助信息</span>\nffmpeg -help\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 查看ffmpeg 支持的格式</span>\nffmpeg -formats\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 查看ffmpeg支持的编码格式</span>\nffmpeg -codecs</code></pre>\n\n<p> usage: ffmpeg [options][[infile options] -i infile]… {[outfile options] outfile}… 这句是说ffmpeg 的主要用法</p>\n</li>\n<li><p>H264编码的其他格式转换TS</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -vcodec copy output.ts\nffmpeg -i input.(mp4、aiv、264) -vcodec libx264 -an out.ts</code></pre>\n\n<p>说明： 一般转换格式用于离线视频识别和live555转发，多数因使用ts格式文件，故需要使用ffmpeg进行转换。</p>\n<p>-vcodec： vcodec 参数使用copy，表示复制原编码，而不进行重编码，效率比较高，默认都是h264编码视频。</p>\n</li>\n<li><p>视频转帧图片</p>\n<pre><code class=\"hljs shell\">ffmpeg -i input.(mp4、avi、264) -r 25 -f image2 ./path/%05d.png</code></pre>\n\n<p>将视频中每一帧切出来，可用作测试人脸检测模块。</p>\n<p>-r：表示帧率，25即每秒25帧来处理帧。</p>\n<p>-f：表示输出格式，此处为image2格式。</p>\n<p> ./path/%05d.png：以png格式输出，path为路径，%05d为通配符，表示以5位数字命名。</p>\n<p>批量转图：</p>\n<pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -r 25 -f image2 ./path/%05d&#123;&#125;.png</code></pre>\n\n<p>视频帧转YUV数据</p>\n<pre><code class=\"hljs shell\">ffmpeg -i a.mp4 -f segment -segment_time 0.01 -r 30 -pix_fmt nv21 ./path</code></pre>\n</li>\n<li><p>帧图片转视频</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i ./path/%05d.png -r 25 -vcodec h264 output.ts</code></pre>\n\n<p>   将连续的帧图片，转制为视频。</p>\n</li>\n<li><p>视频帧率处理</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i input.ts -vcode h264 -r 20 output.ts</code></pre>\n\n<p>   模拟不同帧率下的视频。根据参数-r，决定处理帧率的数值。</p>\n</li>\n<li><p>从相机视频流录制ts或mp4格式的视频</p>\n   <pre><code class=\"hljs shell\">ffmpeg -t 3600 -rtsp_transport tcp -i rtsp://10.201.105.51/live1.sdp -vcodec copy test06223600.ts</code></pre>\n\n<p>   说明：tcp协议</p>\n</li>\n<li><p>截取视频指令</p>\n   <pre><code class=\"hljs shell\">ffmpeg -ss START -vsync 0 -t DURATION -i INPUT -vcodec VIDEOCODEC-acodec AUDIOCODEC OUTPUT</code></pre>\n\n<p>   说明：</p>\n<p>   ​     -ss 视频开始时刻，格式为00:00:00，比如，从第5秒开始录制，则为00:00:05</p>\n<p>   ​     -t 视频持续时长，格式为00:00:00，比如，要录制10秒钟的视频，则为00:00:10</p>\n</li>\n<li><p>合并视频指令</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i &quot;concat:intermediate1.ts|intermediate2.ts&quot; -c copy -bsf:a aac_adtstoasc output.ts</code></pre>\n</li>\n<li><p>视频旋转</p>\n<pre><code class=\"hljs shell\">find ./ -name &quot;*.mp4&quot; | cut -c 3- | xargs -i ffmpeg -i ./&#123;&#125; -vf &quot;transpose=1&quot; -vcodec libx264 -an ./rota/&#123;&#125;</code></pre>\n</li>\n<li><p>图片旋转</p>\n  <pre><code class=\"hljs shell\">convert example.jpg -rotate 90 example-rotated.jpg</code></pre>\n</li>\n<li><p>图片等比缩小</p>\n   <pre><code class=\"hljs shell\">convert k.jpg -resize 50% k2.jpg</code></pre></li>\n<li><p>获取视频文件的帧数</p>\n   <pre><code class=\"hljs shell\">ffmpeg -i 1234.mp4 -vcodec copy -acodec copy -f null /dev/null 2&gt;&amp;1 | grep &#x27;frame=&#x27;</code></pre>\n\n<p><a href=\"https://github.com/FiveYellowMice/how-to-convert-videos-with-ffmpeg-zh\">文章参考</a> </p>\n</li>\n</ol>\n<h3 id=\"搭建rtsp视频流服务\"><a href=\"#搭建rtsp视频流服务\" class=\"headerlink\" title=\"搭建rtsp视频流服务\"></a>搭建rtsp视频流服务</h3><p>利用live555工具提供rtsp服务，需要从官网下载<a href=\"http://www.live555.com/liveMedia/public/live555-latest.tar.gz\">live555源码</a>进行编译成可执行文件。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 将源码解压</span>\ntar xzf live555-latest.tar.gz\ncd live\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 生成编译Linux 64位执行程序的Makefile。编译macos ./genMakefiles macosx</span>\n./genMakefiles linux-64bit \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 编译</span>\nmake</code></pre>\n\n<p>编译完成后会在当前目录下生成<code>live555MediaServer</code>可执行文件。该文件可以放到任何一个Linux64位系统下使用。通过执行<code>live555MediaServer</code>可提供服务。</p>\n<p>举个例子<br>利用ffmpeg 将一个mp4 文件转成ts格式文件</p>\n<pre><code class=\"hljs shell\">ffmpeg -i a.mp4 -vcodec copy a.ts</code></pre>\n\n<p>将a.ts 和 <code>live555MediaServer</code>放在同一个文件夹下就可对外提供rtsp服务。具体地址<strong>rtsp://ip/a.st</strong></p>\n"},{"title":"shell 笔记","date":"2017-05-25T03:14:12.000Z","index_img":["/images/shell/004_shell_1.jpg"],"_content":"\n### xargs\n\n一个例子来认识`xargs`这个Linux 自带的命令。一个文件夹下有十万的.log文件和.txt文件。这时候我们要删除所有的.log文件，很多脑子想到的就是`rm -rf *.log`。这时候你会发现报一个错误`Argument list too long`。这时你又不想写一个for 循环来删，我们就可以利用xargs 这个命令来解决。xargs 一般是和管道一起使用也就是这个`|`\n\n```shell\nls *.log | xargs rm -rf \n```\n\nls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。\n\n**注：** 遇到过一个问题，Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：`rm -rf -xxxx.log`是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。这时候只要在文件名前加两个减号即可`rm -rf -- -xxx.log`\n\n##### 参数\n\nxargs  常用的几个参数也就那几个，其中一个是`-I`设置占位符。具体例子如下\n\n```shell\nls *.log | xargs -I {} cp {}  /var/log/\n```\n\n 将log文件一个一个的复制到/var/log/目录下。\n\nxargs还有一个-P的参数，是指定xargs同时处理多少个命令，也就是设置多少个并发。可以加快处理的速度\n\n```shell\nls *.log | xargs -P 8 -i cp {} /var/log/\n```\n\n[更多参数使用](https://www.runoob.com/linux/linux-comm-xargs.html)\n\n### awk\n\nawk 是一种处理文本文件的语言，是一个强大的文本分析工具。相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。awk一般是和管道一起使用。\n\n具体例子我有一个a.csv文件，我想要第一列和第三列的数据生成一个b.csv\n\na.csv\n\n```shell\na,b,c\nd,e,f\nh,i,j\n```\n\n```shell\ncat a.csv | awk -F , '{print $1,$3 }' >> b.csv\n```\n\nb.csv\n\n```shell\na,c\nd,f\nh,j\n```\n\n我们将awk 和 xargs统一利用起来。现在我用一个测试程序起了多个进程。想要一次性将测试的这些进程一次kill掉。思路是将进程号输出，然后利用xargs 一个一个进程kill，最后的命令如下\n\n```shell\nps -ef | grep test-awk | awk '{print $2}'| xagrs kill -9 \n```\n\nAwk 很强大，功能远不止上面的两个例子。更多的参考[awk命令](https://www.runoob.com/linux/linux-comm-awk.html)\n\n### curl\n\n这个命令基本都很熟悉，这里记录几个实用的样例。\n\n发送post json 数据\n\n```shell\ncurl -H \"Content-Type: application/json\" -X POST -d '{\"seq\":\"xxxxxxxx\",\"policy\":\"free\"}' \"http://127.0.0.1:8080/reliablePhoto\"\n```\n\n将报文json 写好在一个a.json文件，然后post，这样就不用每次在终端里拼写报文了\n\n```shell\ncurl -H \"Content-Type: application/json\" -X POST --data-binary \"@a.json\" \"http://127.0.0.1:8080/reliablePhoto\"\n```\n\n发送post form-data数据\n\n```shell\ncurl -F seq=xxxxxx -F img=@a.jpg http://127.0.0.1:8080/reliableImg\n```\n\nCurl 还有更多的参数，具体可以通过`man curl` 来获取帮助\n\n### jq\n\n通常后端开发使用curl 命令，请求的接口返回是json数据，默认的并没有对json 格式化，这时我们可以使用jq来格式化报文，当然也可以进行json数据解析。jq 命令并不是Linux系统自带的，所以我们需要格外安装。[下载的地址](https://stedolan.github.io/jq/download/)\n\njq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。[ 官方教程](https://stedolan.github.io/jq/tutorial/)\n\n### shell 脚本读取命令行参数\n\nshell 脚本中读取参数值\n\n通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了\n\n#### 根据参数位置直接获取\n\n1. 先定义一个脚本test.sh，打印位置参数\n\n   ```shell\n   #!/bin/bash\necho $1\n   echo $2\n   ```\n   \n2. 执行test.sh脚本\n\n   ```shell\n   ./test.sh haha hehehe\n   ```\n\n   执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。\n\n\n#### 指定key 获取参数\n\n1. 一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义\n\n   ```shell\n   #!/bin/bash\n\n   #先定义接收各个参数值的变量\n   IP_VALUE=\"\"; NODE_VALUE=\"\";VIP_VALUE=\"\";\n\n   while true;do \n   \tif [ ! $2 ]; then break; fi\n   \tcase $1 in\n   \t\t-i|--ip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")IP_VALUE=\"\";shift 2;;\n   \t\t\t*)IP_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-n|--node)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-v|--vip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t --) shift ;break ;;\n   \t\t *) break;;\n   \t\tesac\n   done\n\n   if [ -z \"${IP_VALUE}\" ];    then echo \"error: ip is not found.\";             exit 1; fi\n   if [ -z \"${NODE_VALUE}\" ];  then echo \"error: node is not found.\";           exit 1; fi\n   if [ -z \"${VIP_VALUE}\" ];   then echo \"error: vip is not found.\";            exit 1; fi\n   ```\n\n   - 通过while 循环参数的$1 和$2 取key 和 value。\n   - case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:`./test.sh -v kkk -n bbbb` 读取到如果执行了 shift 2,它就会把-v kkk 给扔了\n   - 底下的if 是判断有没有读取到想要的值\n\n2. 其他的方式去根据key获取参数\n\n   - 一个是getopts 但是getopts不支持长选项，具体可以参考[getopts命令行参数处理](http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html)\n   - 另一个是getopt，[shell中使用getopts 和 getopt](http://blog.csdn.net/wh211212/article/details/53750366)\n\n个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！","source":"_posts/004_shell笔记.md","raw":"---\ntitle: shell 笔记\ndate: 2017-05-25 11:14:12\nindex_img:\n- /images/shell/004_shell_1.jpg\ntags: \n- shell\ncategories:\n- Linux\n---\n\n### xargs\n\n一个例子来认识`xargs`这个Linux 自带的命令。一个文件夹下有十万的.log文件和.txt文件。这时候我们要删除所有的.log文件，很多脑子想到的就是`rm -rf *.log`。这时候你会发现报一个错误`Argument list too long`。这时你又不想写一个for 循环来删，我们就可以利用xargs 这个命令来解决。xargs 一般是和管道一起使用也就是这个`|`\n\n```shell\nls *.log | xargs rm -rf \n```\n\nls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。\n\n**注：** 遇到过一个问题，Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：`rm -rf -xxxx.log`是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。这时候只要在文件名前加两个减号即可`rm -rf -- -xxx.log`\n\n##### 参数\n\nxargs  常用的几个参数也就那几个，其中一个是`-I`设置占位符。具体例子如下\n\n```shell\nls *.log | xargs -I {} cp {}  /var/log/\n```\n\n 将log文件一个一个的复制到/var/log/目录下。\n\nxargs还有一个-P的参数，是指定xargs同时处理多少个命令，也就是设置多少个并发。可以加快处理的速度\n\n```shell\nls *.log | xargs -P 8 -i cp {} /var/log/\n```\n\n[更多参数使用](https://www.runoob.com/linux/linux-comm-xargs.html)\n\n### awk\n\nawk 是一种处理文本文件的语言，是一个强大的文本分析工具。相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。awk一般是和管道一起使用。\n\n具体例子我有一个a.csv文件，我想要第一列和第三列的数据生成一个b.csv\n\na.csv\n\n```shell\na,b,c\nd,e,f\nh,i,j\n```\n\n```shell\ncat a.csv | awk -F , '{print $1,$3 }' >> b.csv\n```\n\nb.csv\n\n```shell\na,c\nd,f\nh,j\n```\n\n我们将awk 和 xargs统一利用起来。现在我用一个测试程序起了多个进程。想要一次性将测试的这些进程一次kill掉。思路是将进程号输出，然后利用xargs 一个一个进程kill，最后的命令如下\n\n```shell\nps -ef | grep test-awk | awk '{print $2}'| xagrs kill -9 \n```\n\nAwk 很强大，功能远不止上面的两个例子。更多的参考[awk命令](https://www.runoob.com/linux/linux-comm-awk.html)\n\n### curl\n\n这个命令基本都很熟悉，这里记录几个实用的样例。\n\n发送post json 数据\n\n```shell\ncurl -H \"Content-Type: application/json\" -X POST -d '{\"seq\":\"xxxxxxxx\",\"policy\":\"free\"}' \"http://127.0.0.1:8080/reliablePhoto\"\n```\n\n将报文json 写好在一个a.json文件，然后post，这样就不用每次在终端里拼写报文了\n\n```shell\ncurl -H \"Content-Type: application/json\" -X POST --data-binary \"@a.json\" \"http://127.0.0.1:8080/reliablePhoto\"\n```\n\n发送post form-data数据\n\n```shell\ncurl -F seq=xxxxxx -F img=@a.jpg http://127.0.0.1:8080/reliableImg\n```\n\nCurl 还有更多的参数，具体可以通过`man curl` 来获取帮助\n\n### jq\n\n通常后端开发使用curl 命令，请求的接口返回是json数据，默认的并没有对json 格式化，这时我们可以使用jq来格式化报文，当然也可以进行json数据解析。jq 命令并不是Linux系统自带的，所以我们需要格外安装。[下载的地址](https://stedolan.github.io/jq/download/)\n\njq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。[ 官方教程](https://stedolan.github.io/jq/tutorial/)\n\n### shell 脚本读取命令行参数\n\nshell 脚本中读取参数值\n\n通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了\n\n#### 根据参数位置直接获取\n\n1. 先定义一个脚本test.sh，打印位置参数\n\n   ```shell\n   #!/bin/bash\necho $1\n   echo $2\n   ```\n   \n2. 执行test.sh脚本\n\n   ```shell\n   ./test.sh haha hehehe\n   ```\n\n   执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。\n\n\n#### 指定key 获取参数\n\n1. 一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义\n\n   ```shell\n   #!/bin/bash\n\n   #先定义接收各个参数值的变量\n   IP_VALUE=\"\"; NODE_VALUE=\"\";VIP_VALUE=\"\";\n\n   while true;do \n   \tif [ ! $2 ]; then break; fi\n   \tcase $1 in\n   \t\t-i|--ip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")IP_VALUE=\"\";shift 2;;\n   \t\t\t*)IP_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-n|--node)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t-v|--vip)\n   \t\t\tcase $2 in\n   \t\t\t\"\")NODE_VALUE=\"\";shift 2;;\n   \t\t\t*)NODE_VALUE=$2;shift 2;;\n   \t\t\tesac;;\n   \t\t --) shift ;break ;;\n   \t\t *) break;;\n   \t\tesac\n   done\n\n   if [ -z \"${IP_VALUE}\" ];    then echo \"error: ip is not found.\";             exit 1; fi\n   if [ -z \"${NODE_VALUE}\" ];  then echo \"error: node is not found.\";           exit 1; fi\n   if [ -z \"${VIP_VALUE}\" ];   then echo \"error: vip is not found.\";            exit 1; fi\n   ```\n\n   - 通过while 循环参数的$1 和$2 取key 和 value。\n   - case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:`./test.sh -v kkk -n bbbb` 读取到如果执行了 shift 2,它就会把-v kkk 给扔了\n   - 底下的if 是判断有没有读取到想要的值\n\n2. 其他的方式去根据key获取参数\n\n   - 一个是getopts 但是getopts不支持长选项，具体可以参考[getopts命令行参数处理](http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html)\n   - 另一个是getopt，[shell中使用getopts 和 getopt](http://blog.csdn.net/wh211212/article/details/53750366)\n\n个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！","slug":"004_shell笔记","published":1,"updated":"2021-03-09T06:31:44.371Z","_id":"ckm1nvl4g0000qjym3m7gdltq","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"xargs\"><a href=\"#xargs\" class=\"headerlink\" title=\"xargs\"></a>xargs</h3><p>一个例子来认识<code>xargs</code>这个Linux 自带的命令。一个文件夹下有十万的.log文件和.txt文件。这时候我们要删除所有的.log文件，很多脑子想到的就是<code>rm -rf *.log</code>。这时候你会发现报一个错误<code>Argument list too long</code>。这时你又不想写一个for 循环来删，我们就可以利用xargs 这个命令来解决。xargs 一般是和管道一起使用也就是这个<code>|</code></p>\n<pre><code class=\"hljs shell\">ls *.log | xargs rm -rf</code></pre>\n\n<p>ls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。</p>\n<p><strong>注：</strong> 遇到过一个问题，Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：<code>rm -rf -xxxx.log</code>是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。这时候只要在文件名前加两个减号即可<code>rm -rf -- -xxx.log</code></p>\n<h5 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h5><p>xargs  常用的几个参数也就那几个，其中一个是<code>-I</code>设置占位符。具体例子如下</p>\n<pre><code class=\"hljs shell\">ls *.log | xargs -I &#123;&#125; cp &#123;&#125;  /var/log/</code></pre>\n\n<p> 将log文件一个一个的复制到/var/log/目录下。</p>\n<p>xargs还有一个-P的参数，是指定xargs同时处理多少个命令，也就是设置多少个并发。可以加快处理的速度</p>\n<pre><code class=\"hljs shell\">ls *.log | xargs -P 8 -i cp &#123;&#125; /var/log/</code></pre>\n\n<p><a href=\"https://www.runoob.com/linux/linux-comm-xargs.html\">更多参数使用</a></p>\n<h3 id=\"awk\"><a href=\"#awk\" class=\"headerlink\" title=\"awk\"></a>awk</h3><p>awk 是一种处理文本文件的语言，是一个强大的文本分析工具。相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。awk一般是和管道一起使用。</p>\n<p>具体例子我有一个a.csv文件，我想要第一列和第三列的数据生成一个b.csv</p>\n<p>a.csv</p>\n<pre><code class=\"hljs shell\">a,b,c\nd,e,f\nh,i,j</code></pre>\n\n<pre><code class=\"hljs shell\">cat a.csv | awk -F , &#x27;&#123;print $1,$3 &#125;&#x27; &gt;&gt; b.csv</code></pre>\n\n<p>b.csv</p>\n<pre><code class=\"hljs shell\">a,c\nd,f\nh,j</code></pre>\n\n<p>我们将awk 和 xargs统一利用起来。现在我用一个测试程序起了多个进程。想要一次性将测试的这些进程一次kill掉。思路是将进程号输出，然后利用xargs 一个一个进程kill，最后的命令如下</p>\n<pre><code class=\"hljs shell\">ps -ef | grep test-awk | awk &#x27;&#123;print $2&#125;&#x27;| xagrs kill -9</code></pre>\n\n<p>Awk 很强大，功能远不止上面的两个例子。更多的参考<a href=\"https://www.runoob.com/linux/linux-comm-awk.html\">awk命令</a></p>\n<h3 id=\"curl\"><a href=\"#curl\" class=\"headerlink\" title=\"curl\"></a>curl</h3><p>这个命令基本都很熟悉，这里记录几个实用的样例。</p>\n<p>发送post json 数据</p>\n<pre><code class=\"hljs shell\">curl -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;seq&quot;:&quot;xxxxxxxx&quot;,&quot;policy&quot;:&quot;free&quot;&#125;&#x27; &quot;http://127.0.0.1:8080/reliablePhoto&quot;</code></pre>\n\n<p>将报文json 写好在一个a.json文件，然后post，这样就不用每次在终端里拼写报文了</p>\n<pre><code class=\"hljs shell\">curl -H &quot;Content-Type: application/json&quot; -X POST --data-binary &quot;@a.json&quot; &quot;http://127.0.0.1:8080/reliablePhoto&quot;</code></pre>\n\n<p>发送post form-data数据</p>\n<pre><code class=\"hljs shell\">curl -F seq=xxxxxx -F img=@a.jpg http://127.0.0.1:8080/reliableImg</code></pre>\n\n<p>Curl 还有更多的参数，具体可以通过<code>man curl</code> 来获取帮助</p>\n<h3 id=\"jq\"><a href=\"#jq\" class=\"headerlink\" title=\"jq\"></a>jq</h3><p>通常后端开发使用curl 命令，请求的接口返回是json数据，默认的并没有对json 格式化，这时我们可以使用jq来格式化报文，当然也可以进行json数据解析。jq 命令并不是Linux系统自带的，所以我们需要格外安装。<a href=\"https://stedolan.github.io/jq/download/\">下载的地址</a></p>\n<p>jq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。<a href=\"https://stedolan.github.io/jq/tutorial/\"> 官方教程</a></p>\n<h3 id=\"shell-脚本读取命令行参数\"><a href=\"#shell-脚本读取命令行参数\" class=\"headerlink\" title=\"shell 脚本读取命令行参数\"></a>shell 脚本读取命令行参数</h3><p>shell 脚本中读取参数值</p>\n<p>通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了</p>\n<h4 id=\"根据参数位置直接获取\"><a href=\"#根据参数位置直接获取\" class=\"headerlink\" title=\"根据参数位置直接获取\"></a>根据参数位置直接获取</h4><ol>\n<li><p>先定义一个脚本test.sh，打印位置参数</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">   #</span><span class=\"bash\">!/bin/bash</span>\necho $1\n   echo $2</code></pre>\n</li>\n<li><p>执行test.sh脚本</p>\n<pre><code class=\"hljs shell\">./test.sh haha hehehe</code></pre>\n\n<p>执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。</p>\n</li>\n</ol>\n<h4 id=\"指定key-获取参数\"><a href=\"#指定key-获取参数\" class=\"headerlink\" title=\"指定key 获取参数\"></a>指定key 获取参数</h4><ol>\n<li><p>一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\n\n<span class=\"hljs-meta\">#</span><span class=\"bash\">先定义接收各个参数值的变量</span>\nIP_VALUE=&quot;&quot;; NODE_VALUE=&quot;&quot;;VIP_VALUE=&quot;&quot;;\n\nwhile true;do \n\tif [ ! $2 ]; then break; fi\n\tcase $1 in\n\t\t-i|--ip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)IP_VALUE=&quot;&quot;;shift 2;;\n\t\t\t*)IP_VALUE=$2;shift 2;;\n\t\t\tesac;;\n\t\t-n|--node)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE=$2;shift 2;;\n\t\t\tesac;;\n\t\t-v|--vip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE=$2;shift 2;;\n\t\t\tesac;;\n\t\t --) shift ;break ;;\n\t\t *) break;;\n\t\tesac\ndone\n\nif [ -z &quot;$&#123;IP_VALUE&#125;&quot; ];    then echo &quot;error: ip is not found.&quot;;             exit 1; fi\nif [ -z &quot;$&#123;NODE_VALUE&#125;&quot; ];  then echo &quot;error: node is not found.&quot;;           exit 1; fi\nif [ -z &quot;$&#123;VIP_VALUE&#125;&quot; ];   then echo &quot;error: vip is not found.&quot;;            exit 1; fi</code></pre>\n\n<ul>\n<li>通过while 循环参数的$1 和$2 取key 和 value。</li>\n<li>case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:<code>./test.sh -v kkk -n bbbb</code> 读取到如果执行了 shift 2,它就会把-v kkk 给扔了</li>\n<li>底下的if 是判断有没有读取到想要的值</li>\n</ul>\n</li>\n<li><p>其他的方式去根据key获取参数</p>\n<ul>\n<li>一个是getopts 但是getopts不支持长选项，具体可以参考<a href=\"http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html\">getopts命令行参数处理</a></li>\n<li>另一个是getopt，<a href=\"http://blog.csdn.net/wh211212/article/details/53750366\">shell中使用getopts 和 getopt</a></li>\n</ul>\n</li>\n</ol>\n<p>个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"xargs\"><a href=\"#xargs\" class=\"headerlink\" title=\"xargs\"></a>xargs</h3><p>一个例子来认识<code>xargs</code>这个Linux 自带的命令。一个文件夹下有十万的.log文件和.txt文件。这时候我们要删除所有的.log文件，很多脑子想到的就是<code>rm -rf *.log</code>。这时候你会发现报一个错误<code>Argument list too long</code>。这时你又不想写一个for 循环来删，我们就可以利用xargs 这个命令来解决。xargs 一般是和管道一起使用也就是这个<code>|</code></p>\n<pre><code class=\"hljs shell\">ls *.log | xargs rm -rf</code></pre>\n\n<p>ls 将当前目录下的log文件名标准输出，通过管道传递给xargs 过滤，然后进行删除。</p>\n<p><strong>注：</strong> 遇到过一个问题，Linux上一些以减号开头的文件，会将这个文件认为是一个参数，如：<code>rm -rf -xxxx.log</code>是无法执行的，无论是其他的什么命令去处理类似文件名的文件，都会有这个问题。这时候只要在文件名前加两个减号即可<code>rm -rf -- -xxx.log</code></p>\n<h5 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h5><p>xargs  常用的几个参数也就那几个，其中一个是<code>-I</code>设置占位符。具体例子如下</p>\n<pre><code class=\"hljs shell\">ls *.log | xargs -I &#123;&#125; cp &#123;&#125;  /var/log/</code></pre>\n\n<p> 将log文件一个一个的复制到/var/log/目录下。</p>\n<p>xargs还有一个-P的参数，是指定xargs同时处理多少个命令，也就是设置多少个并发。可以加快处理的速度</p>\n<pre><code class=\"hljs shell\">ls *.log | xargs -P 8 -i cp &#123;&#125; /var/log/</code></pre>\n\n<p><a href=\"https://www.runoob.com/linux/linux-comm-xargs.html\">更多参数使用</a></p>\n<h3 id=\"awk\"><a href=\"#awk\" class=\"headerlink\" title=\"awk\"></a>awk</h3><p>awk 是一种处理文本文件的语言，是一个强大的文本分析工具。相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。awk一般是和管道一起使用。</p>\n<p>具体例子我有一个a.csv文件，我想要第一列和第三列的数据生成一个b.csv</p>\n<p>a.csv</p>\n<pre><code class=\"hljs shell\">a,b,c\nd,e,f\nh,i,j</code></pre>\n\n<pre><code class=\"hljs shell\">cat a.csv | awk -F , &#x27;&#123;print $1,$3 &#125;&#x27; &gt;&gt; b.csv</code></pre>\n\n<p>b.csv</p>\n<pre><code class=\"hljs shell\">a,c\nd,f\nh,j</code></pre>\n\n<p>我们将awk 和 xargs统一利用起来。现在我用一个测试程序起了多个进程。想要一次性将测试的这些进程一次kill掉。思路是将进程号输出，然后利用xargs 一个一个进程kill，最后的命令如下</p>\n<pre><code class=\"hljs shell\">ps -ef | grep test-awk | awk &#x27;&#123;print $2&#125;&#x27;| xagrs kill -9</code></pre>\n\n<p>Awk 很强大，功能远不止上面的两个例子。更多的参考<a href=\"https://www.runoob.com/linux/linux-comm-awk.html\">awk命令</a></p>\n<h3 id=\"curl\"><a href=\"#curl\" class=\"headerlink\" title=\"curl\"></a>curl</h3><p>这个命令基本都很熟悉，这里记录几个实用的样例。</p>\n<p>发送post json 数据</p>\n<pre><code class=\"hljs shell\">curl -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;seq&quot;:&quot;xxxxxxxx&quot;,&quot;policy&quot;:&quot;free&quot;&#125;&#x27; &quot;http://127.0.0.1:8080/reliablePhoto&quot;</code></pre>\n\n<p>将报文json 写好在一个a.json文件，然后post，这样就不用每次在终端里拼写报文了</p>\n<pre><code class=\"hljs shell\">curl -H &quot;Content-Type: application/json&quot; -X POST --data-binary &quot;@a.json&quot; &quot;http://127.0.0.1:8080/reliablePhoto&quot;</code></pre>\n\n<p>发送post form-data数据</p>\n<pre><code class=\"hljs shell\">curl -F seq=xxxxxx -F img=@a.jpg http://127.0.0.1:8080/reliableImg</code></pre>\n\n<p>Curl 还有更多的参数，具体可以通过<code>man curl</code> 来获取帮助</p>\n<h3 id=\"jq\"><a href=\"#jq\" class=\"headerlink\" title=\"jq\"></a>jq</h3><p>通常后端开发使用curl 命令，请求的接口返回是json数据，默认的并没有对json 格式化，这时我们可以使用jq来格式化报文，当然也可以进行json数据解析。jq 命令并不是Linux系统自带的，所以我们需要格外安装。<a href=\"https://stedolan.github.io/jq/download/\">下载的地址</a></p>\n<p>jq的用法也很简单，而且官方的例子也很全。这里主要是记录下有这么一个好用的东西。<a href=\"https://stedolan.github.io/jq/tutorial/\"> 官方教程</a></p>\n<h3 id=\"shell-脚本读取命令行参数\"><a href=\"#shell-脚本读取命令行参数\" class=\"headerlink\" title=\"shell 脚本读取命令行参数\"></a>shell 脚本读取命令行参数</h3><p>shell 脚本中读取参数值</p>\n<p>通常读取命令行中带过来的参数有两种方式，一直是直接根据参数位置直接获取，还有一种根据指定的key，去获取指定的值。第一种方式可以说是根本没有可读性，使用的人如果参数位置写错了，传入的值就全错了</p>\n<h4 id=\"根据参数位置直接获取\"><a href=\"#根据参数位置直接获取\" class=\"headerlink\" title=\"根据参数位置直接获取\"></a>根据参数位置直接获取</h4><ol>\n<li><p>先定义一个脚本test.sh，打印位置参数</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">   #</span><span class=\"bash\">!/bin/bash</span>\necho $1\n   echo $2</code></pre>\n</li>\n<li><p>执行test.sh脚本</p>\n<pre><code class=\"hljs shell\">./test.sh haha hehehe</code></pre>\n\n<p>执行的结果就是打印了两个参数，这个种方式的弊端就是，如果参数的位置传错了，那么$1 的值就不是haha了，当然可以使用这种方式写，就是可读性不太高 哈。</p>\n</li>\n</ol>\n<h4 id=\"指定key-获取参数\"><a href=\"#指定key-获取参数\" class=\"headerlink\" title=\"指定key 获取参数\"></a>指定key 获取参数</h4><ol>\n<li><p>一样的我们先定义脚本test.sh，一会儿我们在解读shell脚本中的含义</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\">!/bin/bash</span>\n\n<span class=\"hljs-meta\">#</span><span class=\"bash\">先定义接收各个参数值的变量</span>\nIP_VALUE=&quot;&quot;; NODE_VALUE=&quot;&quot;;VIP_VALUE=&quot;&quot;;\n\nwhile true;do \n\tif [ ! $2 ]; then break; fi\n\tcase $1 in\n\t\t-i|--ip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)IP_VALUE=&quot;&quot;;shift 2;;\n\t\t\t*)IP_VALUE=$2;shift 2;;\n\t\t\tesac;;\n\t\t-n|--node)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE=$2;shift 2;;\n\t\t\tesac;;\n\t\t-v|--vip)\n\t\t\tcase $2 in\n\t\t\t&quot;&quot;)NODE_VALUE=&quot;&quot;;shift 2;;\n\t\t\t*)NODE_VALUE=$2;shift 2;;\n\t\t\tesac;;\n\t\t --) shift ;break ;;\n\t\t *) break;;\n\t\tesac\ndone\n\nif [ -z &quot;$&#123;IP_VALUE&#125;&quot; ];    then echo &quot;error: ip is not found.&quot;;             exit 1; fi\nif [ -z &quot;$&#123;NODE_VALUE&#125;&quot; ];  then echo &quot;error: node is not found.&quot;;           exit 1; fi\nif [ -z &quot;$&#123;VIP_VALUE&#125;&quot; ];   then echo &quot;error: vip is not found.&quot;;            exit 1; fi</code></pre>\n\n<ul>\n<li>通过while 循环参数的$1 和$2 取key 和 value。</li>\n<li>case $1取参数的key，case $2取其中的值，如果取到了，就通过shift 2，把最前面的两个位置给移除了比如:<code>./test.sh -v kkk -n bbbb</code> 读取到如果执行了 shift 2,它就会把-v kkk 给扔了</li>\n<li>底下的if 是判断有没有读取到想要的值</li>\n</ul>\n</li>\n<li><p>其他的方式去根据key获取参数</p>\n<ul>\n<li>一个是getopts 但是getopts不支持长选项，具体可以参考<a href=\"http://www.cnblogs.com/xiangzi888/archive/2012/04/03/2430736.html\">getopts命令行参数处理</a></li>\n<li>另一个是getopt，<a href=\"http://blog.csdn.net/wh211212/article/details/53750366\">shell中使用getopts 和 getopt</a></li>\n</ul>\n</li>\n</ol>\n<p>个人建议使用第一种方式去处理shell参数，不会有太多的局限性，唯一的问题就是代码会多一些哈！</p>\n"},{"title":"Mac下效率工具","date":"2017-05-27T09:02:12.000Z","index_img":["/images/shell/005_mac_0.jpg"],"_content":"\n对于开发者来说，有一个符合自己开发习惯的操作环境能够最大化的提升工作效率。以下就介绍下自己个人用的比较舒服的开发环境。\n\n### iterm2\n\nMac 上是有一个自带的终端（terminal）,但是功能相对简单。而且用起来也不是特别舒服。使用Mac的基本都是用iterm2 来作为终端工具。\n\n1. 设置快捷键，快速将iter2唤出。无需去手动打开应用\n\n   在Preferences->Keys-> Hotkey 找到下图位置进行设置。我设置的快捷键是option+空格\n\n   ![img](https://cocoon-break.github.io/images/shell/005_mac_1.png)\n\n2. 设置半屏效果，并且能够固定在屏幕上方。\n\n   Preferences->Profiles->windows 设置按照下图即可\n\n   ![image2](https://cocoon-break.github.io/images/shell/005_mac_2.png)\n\n3. iterm2配色\n\n   网上有很多的配色方案，我们可以用现成的。比较出名的就是iTerm2-Color-Schemes\n\n   ```shell\n   git clone https://github.com/mbadolato/iTerm2-Color-Schemes\n   ```\n\n   好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案。我个人比较喜欢使用的是`Violet Light`方案哈\n\n   ![](https://cocoon-break.github.io/images/shell/005_mac_3.jpg)\n\n#### 常用的快捷键\n\n- 窗口和屏相关\n  - 新建窗口：command + t\n  - 关闭窗口或者分屏：command + w\n  - 切换标签：command +  左右方向键\n  - 切换全屏：command + enter\n  - 水平分屏：command + shift + d \n  - 垂直分屏：command + d \n  - 切换分屏：command + option + 方向键\n- 编辑相关\n  - 清除当前行：ctrl + u\n  - 删除光标之前的字符：ctrl + h\n  - 删除光标之前的单词：ctrl + w\n  - 删除光标到文本末尾：ctrl + k\n  - 到行首： ctrl + a\n  - 到行末：ctrl + e\n  - 查找历史命令：ctrl + r\n\n#### 一个例子\n\n之前遇到一个情况，需要同时对多台远程机器进行同样的命令操作，这时候就可以用iterm2了。第一步先进行`command + d`  和`command + shift + d`进行分屏。在每个分屏中分别远程ssh成功之后。然后使用`command + shift + i`。这时就几个屏就会同时输入同样的内容了。\n\n![](https://cocoon-break.github.io/images/shell/005_mac_4.jpg)\n\n\n### on-my-zsh\n\nShell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。\n\nLinux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。\n\n```sh\n# 查看当前系统支持的shell\ncat /etc/shells\n# 查看目前使用的shell\necho $SHELL\n```\n\n在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh。mac下要开启使用zsh 执行以下命令并重启iterm2\n\n```shell\nchsh -s /bin/zsh\n```\n\n #### 手动安装\n\n如果当前系统没有自带zsh，也可以手动就行安装。具体的平台可以参考[官方安装教程](https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH)，根据安装教程完成安装后，可以对zsh进行配置。\n\n```shell\n# 下载配置模版\ngit clone https://github.com/robbyrussell/oh-my-zsh ~/.oh-my-zsh\n# 使用配置模版\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\noh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考[主题预览](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)，选好主题了，接下来就是配置了。编辑~/.zshrc 文件\n\n```sh\nvim ~/.zshrc\n#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的\nZSH_THEME=\"af-magic\"\n```\n\n#### zsh的优势\n\n1. zsh 可以兼容bash，bash的使用习惯还是可以保留的\n2. 强大tab 补全功能，执行`cd`的时候，只要按两下tab，就可以将目标路径下的所有目录列出。在按回车可以进入选择的目录\n3. 智能补全功能，比如要进入/var/log/nginx/error/lastyear/may/first/monday。在zsh下输入/v/l/n/e/l/m/f/m，然后按tab就可以将目录补全。\n4. 命令选项和命令参数补全，比如输入kill -9 然后按下tab 就会显示进程名称和进程id。\n5. 大小写更正，比如当前目录下有一个AA.txt，我们输入`cat aa.txt`和tab键，就会更正为`cat AA.txt`\n\nzsh 还有很多其他强大的功能，具体的等大家去探索吧，这里就不介绍更多了。\n\n\n\n这里推荐一个替换命令`cd`的工具`z`，使用`z+文件夹名`可快速切花目录，不需要向cd那样输入相对路径和绝对路径来实现目录切换。mac下安装执行`brew install z`，然后在.zshrc 最后添加`source $(brew --prefix)/etc/profile.d/z.sh` 即可。需要留意的是使用z第一次进入跳转路径需要使用绝对路径，第二次可以直接使用文件夹名称。\n\n### VIM\n\nvim  是一个很强大的文本编辑器，vim对于每个开发来说都应该掌握的一个技能。vim本身自带了一个基础教程，学习完这个教程之后对vim基础操作都没啥问题。在iterm2或者终端输入以下命令来启动这个教程\n\n```shell\nvimtutor\n```\n\n教程里面介绍了很多快捷键操作，这里就不在重复了。\n\nVim  还有一个很强大的功能就是插件，只要你配置好相关的插件，你就可以不使用任何的开发工具，可以直接使用vim进行开发。更多的vim参考[跟我一起学习VIM](https://cloud.tencent.com/developer/article/1343616)\n\n相信有了上述的这些工具能够大幅提升生产效率。","source":"_posts/005_mac效率.md","raw":"---\ntitle: Mac下效率工具\ndate: 2017-05-27 17:02:12\nindex_img:\n- /images/shell/005_mac_0.jpg\ntags: \n- shell\ncategories:\n- 开发效率\n---\n\n对于开发者来说，有一个符合自己开发习惯的操作环境能够最大化的提升工作效率。以下就介绍下自己个人用的比较舒服的开发环境。\n\n### iterm2\n\nMac 上是有一个自带的终端（terminal）,但是功能相对简单。而且用起来也不是特别舒服。使用Mac的基本都是用iterm2 来作为终端工具。\n\n1. 设置快捷键，快速将iter2唤出。无需去手动打开应用\n\n   在Preferences->Keys-> Hotkey 找到下图位置进行设置。我设置的快捷键是option+空格\n\n   ![img](https://cocoon-break.github.io/images/shell/005_mac_1.png)\n\n2. 设置半屏效果，并且能够固定在屏幕上方。\n\n   Preferences->Profiles->windows 设置按照下图即可\n\n   ![image2](https://cocoon-break.github.io/images/shell/005_mac_2.png)\n\n3. iterm2配色\n\n   网上有很多的配色方案，我们可以用现成的。比较出名的就是iTerm2-Color-Schemes\n\n   ```shell\n   git clone https://github.com/mbadolato/iTerm2-Color-Schemes\n   ```\n\n   好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案。我个人比较喜欢使用的是`Violet Light`方案哈\n\n   ![](https://cocoon-break.github.io/images/shell/005_mac_3.jpg)\n\n#### 常用的快捷键\n\n- 窗口和屏相关\n  - 新建窗口：command + t\n  - 关闭窗口或者分屏：command + w\n  - 切换标签：command +  左右方向键\n  - 切换全屏：command + enter\n  - 水平分屏：command + shift + d \n  - 垂直分屏：command + d \n  - 切换分屏：command + option + 方向键\n- 编辑相关\n  - 清除当前行：ctrl + u\n  - 删除光标之前的字符：ctrl + h\n  - 删除光标之前的单词：ctrl + w\n  - 删除光标到文本末尾：ctrl + k\n  - 到行首： ctrl + a\n  - 到行末：ctrl + e\n  - 查找历史命令：ctrl + r\n\n#### 一个例子\n\n之前遇到一个情况，需要同时对多台远程机器进行同样的命令操作，这时候就可以用iterm2了。第一步先进行`command + d`  和`command + shift + d`进行分屏。在每个分屏中分别远程ssh成功之后。然后使用`command + shift + i`。这时就几个屏就会同时输入同样的内容了。\n\n![](https://cocoon-break.github.io/images/shell/005_mac_4.jpg)\n\n\n### on-my-zsh\n\nShell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。\n\nLinux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。\n\n```sh\n# 查看当前系统支持的shell\ncat /etc/shells\n# 查看目前使用的shell\necho $SHELL\n```\n\n在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh。mac下要开启使用zsh 执行以下命令并重启iterm2\n\n```shell\nchsh -s /bin/zsh\n```\n\n #### 手动安装\n\n如果当前系统没有自带zsh，也可以手动就行安装。具体的平台可以参考[官方安装教程](https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH)，根据安装教程完成安装后，可以对zsh进行配置。\n\n```shell\n# 下载配置模版\ngit clone https://github.com/robbyrussell/oh-my-zsh ~/.oh-my-zsh\n# 使用配置模版\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n```\n\noh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考[主题预览](https://github.com/robbyrussell/oh-my-zsh/wiki/Themes)，选好主题了，接下来就是配置了。编辑~/.zshrc 文件\n\n```sh\nvim ~/.zshrc\n#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的\nZSH_THEME=\"af-magic\"\n```\n\n#### zsh的优势\n\n1. zsh 可以兼容bash，bash的使用习惯还是可以保留的\n2. 强大tab 补全功能，执行`cd`的时候，只要按两下tab，就可以将目标路径下的所有目录列出。在按回车可以进入选择的目录\n3. 智能补全功能，比如要进入/var/log/nginx/error/lastyear/may/first/monday。在zsh下输入/v/l/n/e/l/m/f/m，然后按tab就可以将目录补全。\n4. 命令选项和命令参数补全，比如输入kill -9 然后按下tab 就会显示进程名称和进程id。\n5. 大小写更正，比如当前目录下有一个AA.txt，我们输入`cat aa.txt`和tab键，就会更正为`cat AA.txt`\n\nzsh 还有很多其他强大的功能，具体的等大家去探索吧，这里就不介绍更多了。\n\n\n\n这里推荐一个替换命令`cd`的工具`z`，使用`z+文件夹名`可快速切花目录，不需要向cd那样输入相对路径和绝对路径来实现目录切换。mac下安装执行`brew install z`，然后在.zshrc 最后添加`source $(brew --prefix)/etc/profile.d/z.sh` 即可。需要留意的是使用z第一次进入跳转路径需要使用绝对路径，第二次可以直接使用文件夹名称。\n\n### VIM\n\nvim  是一个很强大的文本编辑器，vim对于每个开发来说都应该掌握的一个技能。vim本身自带了一个基础教程，学习完这个教程之后对vim基础操作都没啥问题。在iterm2或者终端输入以下命令来启动这个教程\n\n```shell\nvimtutor\n```\n\n教程里面介绍了很多快捷键操作，这里就不在重复了。\n\nVim  还有一个很强大的功能就是插件，只要你配置好相关的插件，你就可以不使用任何的开发工具，可以直接使用vim进行开发。更多的vim参考[跟我一起学习VIM](https://cloud.tencent.com/developer/article/1343616)\n\n相信有了上述的这些工具能够大幅提升生产效率。","slug":"005_mac效率","published":1,"updated":"2021-03-10T05:50:28.589Z","_id":"ckm2uej100000d5ym2nhy02jg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>对于开发者来说，有一个符合自己开发习惯的操作环境能够最大化的提升工作效率。以下就介绍下自己个人用的比较舒服的开发环境。</p>\n<h3 id=\"iterm2\"><a href=\"#iterm2\" class=\"headerlink\" title=\"iterm2\"></a>iterm2</h3><p>Mac 上是有一个自带的终端（terminal）,但是功能相对简单。而且用起来也不是特别舒服。使用Mac的基本都是用iterm2 来作为终端工具。</p>\n<ol>\n<li><p>设置快捷键，快速将iter2唤出。无需去手动打开应用</p>\n<p>在Preferences-&gt;Keys-&gt; Hotkey 找到下图位置进行设置。我设置的快捷键是option+空格</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_1.png\" alt=\"img\"></p>\n</li>\n<li><p>设置半屏效果，并且能够固定在屏幕上方。</p>\n<p>Preferences-&gt;Profiles-&gt;windows 设置按照下图即可</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_2.png\" alt=\"image2\"></p>\n</li>\n<li><p>iterm2配色</p>\n<p>网上有很多的配色方案，我们可以用现成的。比较出名的就是iTerm2-Color-Schemes</p>\n<pre><code class=\"hljs shell\">git clone https://github.com/mbadolato/iTerm2-Color-Schemes</code></pre>\n\n<p>好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案。我个人比较喜欢使用的是<code>Violet Light</code>方案哈</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_3.jpg\"></p>\n</li>\n</ol>\n<h4 id=\"常用的快捷键\"><a href=\"#常用的快捷键\" class=\"headerlink\" title=\"常用的快捷键\"></a>常用的快捷键</h4><ul>\n<li>窗口和屏相关<ul>\n<li>新建窗口：command + t</li>\n<li>关闭窗口或者分屏：command + w</li>\n<li>切换标签：command +  左右方向键</li>\n<li>切换全屏：command + enter</li>\n<li>水平分屏：command + shift + d </li>\n<li>垂直分屏：command + d </li>\n<li>切换分屏：command + option + 方向键</li>\n</ul>\n</li>\n<li>编辑相关<ul>\n<li>清除当前行：ctrl + u</li>\n<li>删除光标之前的字符：ctrl + h</li>\n<li>删除光标之前的单词：ctrl + w</li>\n<li>删除光标到文本末尾：ctrl + k</li>\n<li>到行首： ctrl + a</li>\n<li>到行末：ctrl + e</li>\n<li>查找历史命令：ctrl + r</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h4><p>之前遇到一个情况，需要同时对多台远程机器进行同样的命令操作，这时候就可以用iterm2了。第一步先进行<code>command + d</code>  和<code>command + shift + d</code>进行分屏。在每个分屏中分别远程ssh成功之后。然后使用<code>command + shift + i</code>。这时就几个屏就会同时输入同样的内容了。</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_4.jpg\"></p>\n<h3 id=\"on-my-zsh\"><a href=\"#on-my-zsh\" class=\"headerlink\" title=\"on-my-zsh\"></a>on-my-zsh</h3><p>Shell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。</p>\n<p>Linux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 查看当前系统支持的shell</span>\ncat /etc/shells\n<span class=\"hljs-comment\"># 查看目前使用的shell</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$SHELL</span></code></pre>\n\n<p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh。mac下要开启使用zsh 执行以下命令并重启iterm2</p>\n<pre><code class=\"hljs shell\">chsh -s /bin/zsh</code></pre>\n\n<h4 id=\"手动安装\"><a href=\"#手动安装\" class=\"headerlink\" title=\"手动安装\"></a>手动安装</h4><p>如果当前系统没有自带zsh，也可以手动就行安装。具体的平台可以参考<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH\">官方安装教程</a>，根据安装教程完成安装后，可以对zsh进行配置。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 下载配置模版</span>\ngit clone https://github.com/robbyrussell/oh-my-zsh ~/.oh-my-zsh\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 使用配置模版</span>\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre>\n\n<p>oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\">主题预览</a>，选好主题了，接下来就是配置了。编辑~/.zshrc 文件</p>\n<pre><code class=\"hljs sh\">vim ~/.zshrc\n<span class=\"hljs-comment\">#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的</span>\nZSH_THEME=<span class=\"hljs-string\">&quot;af-magic&quot;</span></code></pre>\n\n<h4 id=\"zsh的优势\"><a href=\"#zsh的优势\" class=\"headerlink\" title=\"zsh的优势\"></a>zsh的优势</h4><ol>\n<li>zsh 可以兼容bash，bash的使用习惯还是可以保留的</li>\n<li>强大tab 补全功能，执行<code>cd</code>的时候，只要按两下tab，就可以将目标路径下的所有目录列出。在按回车可以进入选择的目录</li>\n<li>智能补全功能，比如要进入/var/log/nginx/error/lastyear/may/first/monday。在zsh下输入/v/l/n/e/l/m/f/m，然后按tab就可以将目录补全。</li>\n<li>命令选项和命令参数补全，比如输入kill -9 然后按下tab 就会显示进程名称和进程id。</li>\n<li>大小写更正，比如当前目录下有一个AA.txt，我们输入<code>cat aa.txt</code>和tab键，就会更正为<code>cat AA.txt</code></li>\n</ol>\n<p>zsh 还有很多其他强大的功能，具体的等大家去探索吧，这里就不介绍更多了。</p>\n<p>这里推荐一个替换命令<code>cd</code>的工具<code>z</code>，使用<code>z+文件夹名</code>可快速切花目录，不需要向cd那样输入相对路径和绝对路径来实现目录切换。mac下安装执行<code>brew install z</code>，然后在.zshrc 最后添加<code>source $(brew --prefix)/etc/profile.d/z.sh</code> 即可。需要留意的是使用z第一次进入跳转路径需要使用绝对路径，第二次可以直接使用文件夹名称。</p>\n<h3 id=\"VIM\"><a href=\"#VIM\" class=\"headerlink\" title=\"VIM\"></a>VIM</h3><p>vim  是一个很强大的文本编辑器，vim对于每个开发来说都应该掌握的一个技能。vim本身自带了一个基础教程，学习完这个教程之后对vim基础操作都没啥问题。在iterm2或者终端输入以下命令来启动这个教程</p>\n<pre><code class=\"hljs shell\">vimtutor</code></pre>\n\n<p>教程里面介绍了很多快捷键操作，这里就不在重复了。</p>\n<p>Vim  还有一个很强大的功能就是插件，只要你配置好相关的插件，你就可以不使用任何的开发工具，可以直接使用vim进行开发。更多的vim参考<a href=\"https://cloud.tencent.com/developer/article/1343616\">跟我一起学习VIM</a></p>\n<p>相信有了上述的这些工具能够大幅提升生产效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于开发者来说，有一个符合自己开发习惯的操作环境能够最大化的提升工作效率。以下就介绍下自己个人用的比较舒服的开发环境。</p>\n<h3 id=\"iterm2\"><a href=\"#iterm2\" class=\"headerlink\" title=\"iterm2\"></a>iterm2</h3><p>Mac 上是有一个自带的终端（terminal）,但是功能相对简单。而且用起来也不是特别舒服。使用Mac的基本都是用iterm2 来作为终端工具。</p>\n<ol>\n<li><p>设置快捷键，快速将iter2唤出。无需去手动打开应用</p>\n<p>在Preferences-&gt;Keys-&gt; Hotkey 找到下图位置进行设置。我设置的快捷键是option+空格</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_1.png\" alt=\"img\"></p>\n</li>\n<li><p>设置半屏效果，并且能够固定在屏幕上方。</p>\n<p>Preferences-&gt;Profiles-&gt;windows 设置按照下图即可</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_2.png\" alt=\"image2\"></p>\n</li>\n<li><p>iterm2配色</p>\n<p>网上有很多的配色方案，我们可以用现成的。比较出名的就是iTerm2-Color-Schemes</p>\n<pre><code class=\"hljs shell\">git clone https://github.com/mbadolato/iTerm2-Color-Schemes</code></pre>\n\n<p>好了配色方案是有了接下来我们就是进行配色了,这个也是比较简单，打开iterm2的偏好设置，找到Profiles下的Colors，选中import，这里选择刚才git 克隆下来文件中的schemes文件夹下的文件，这些文件就是各种各样的配色方案。我个人比较喜欢使用的是<code>Violet Light</code>方案哈</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_3.jpg\"></p>\n</li>\n</ol>\n<h4 id=\"常用的快捷键\"><a href=\"#常用的快捷键\" class=\"headerlink\" title=\"常用的快捷键\"></a>常用的快捷键</h4><ul>\n<li>窗口和屏相关<ul>\n<li>新建窗口：command + t</li>\n<li>关闭窗口或者分屏：command + w</li>\n<li>切换标签：command +  左右方向键</li>\n<li>切换全屏：command + enter</li>\n<li>水平分屏：command + shift + d </li>\n<li>垂直分屏：command + d </li>\n<li>切换分屏：command + option + 方向键</li>\n</ul>\n</li>\n<li>编辑相关<ul>\n<li>清除当前行：ctrl + u</li>\n<li>删除光标之前的字符：ctrl + h</li>\n<li>删除光标之前的单词：ctrl + w</li>\n<li>删除光标到文本末尾：ctrl + k</li>\n<li>到行首： ctrl + a</li>\n<li>到行末：ctrl + e</li>\n<li>查找历史命令：ctrl + r</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h4><p>之前遇到一个情况，需要同时对多台远程机器进行同样的命令操作，这时候就可以用iterm2了。第一步先进行<code>command + d</code>  和<code>command + shift + d</code>进行分屏。在每个分屏中分别远程ssh成功之后。然后使用<code>command + shift + i</code>。这时就几个屏就会同时输入同样的内容了。</p>\n<p><img src=\"https://cocoon-break.github.io/images/shell/005_mac_4.jpg\"></p>\n<h3 id=\"on-my-zsh\"><a href=\"#on-my-zsh\" class=\"headerlink\" title=\"on-my-zsh\"></a>on-my-zsh</h3><p>Shell 是LInux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后在把结果返回给用户或应用程序。</p>\n<p>Linux/Unix 提供了很多种shell，常用的shell有这么几种，sh、bash、csh等。想知道系统有几种shell，可以通过以下命令查看。</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 查看当前系统支持的shell</span>\ncat /etc/shells\n<span class=\"hljs-comment\"># 查看目前使用的shell</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$SHELL</span></code></pre>\n\n<p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh。mac下要开启使用zsh 执行以下命令并重启iterm2</p>\n<pre><code class=\"hljs shell\">chsh -s /bin/zsh</code></pre>\n\n<h4 id=\"手动安装\"><a href=\"#手动安装\" class=\"headerlink\" title=\"手动安装\"></a>手动安装</h4><p>如果当前系统没有自带zsh，也可以手动就行安装。具体的平台可以参考<a href=\"https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH\">官方安装教程</a>，根据安装教程完成安装后，可以对zsh进行配置。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 下载配置模版</span>\ngit clone https://github.com/robbyrussell/oh-my-zsh ~/.oh-my-zsh\n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 使用配置模版</span>\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre>\n\n<p>oh-my-zsh 提供了很多的主题，可以选择自己喜欢的风格。具体的主题效果可以参考<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Themes\">主题预览</a>，选好主题了，接下来就是配置了。编辑~/.zshrc 文件</p>\n<pre><code class=\"hljs sh\">vim ~/.zshrc\n<span class=\"hljs-comment\">#编辑主题，af-magic是我机器上的主题风格，具体可以设置为刚才主题预览中的</span>\nZSH_THEME=<span class=\"hljs-string\">&quot;af-magic&quot;</span></code></pre>\n\n<h4 id=\"zsh的优势\"><a href=\"#zsh的优势\" class=\"headerlink\" title=\"zsh的优势\"></a>zsh的优势</h4><ol>\n<li>zsh 可以兼容bash，bash的使用习惯还是可以保留的</li>\n<li>强大tab 补全功能，执行<code>cd</code>的时候，只要按两下tab，就可以将目标路径下的所有目录列出。在按回车可以进入选择的目录</li>\n<li>智能补全功能，比如要进入/var/log/nginx/error/lastyear/may/first/monday。在zsh下输入/v/l/n/e/l/m/f/m，然后按tab就可以将目录补全。</li>\n<li>命令选项和命令参数补全，比如输入kill -9 然后按下tab 就会显示进程名称和进程id。</li>\n<li>大小写更正，比如当前目录下有一个AA.txt，我们输入<code>cat aa.txt</code>和tab键，就会更正为<code>cat AA.txt</code></li>\n</ol>\n<p>zsh 还有很多其他强大的功能，具体的等大家去探索吧，这里就不介绍更多了。</p>\n<p>这里推荐一个替换命令<code>cd</code>的工具<code>z</code>，使用<code>z+文件夹名</code>可快速切花目录，不需要向cd那样输入相对路径和绝对路径来实现目录切换。mac下安装执行<code>brew install z</code>，然后在.zshrc 最后添加<code>source $(brew --prefix)/etc/profile.d/z.sh</code> 即可。需要留意的是使用z第一次进入跳转路径需要使用绝对路径，第二次可以直接使用文件夹名称。</p>\n<h3 id=\"VIM\"><a href=\"#VIM\" class=\"headerlink\" title=\"VIM\"></a>VIM</h3><p>vim  是一个很强大的文本编辑器，vim对于每个开发来说都应该掌握的一个技能。vim本身自带了一个基础教程，学习完这个教程之后对vim基础操作都没啥问题。在iterm2或者终端输入以下命令来启动这个教程</p>\n<pre><code class=\"hljs shell\">vimtutor</code></pre>\n\n<p>教程里面介绍了很多快捷键操作，这里就不在重复了。</p>\n<p>Vim  还有一个很强大的功能就是插件，只要你配置好相关的插件，你就可以不使用任何的开发工具，可以直接使用vim进行开发。更多的vim参考<a href=\"https://cloud.tencent.com/developer/article/1343616\">跟我一起学习VIM</a></p>\n<p>相信有了上述的这些工具能够大幅提升生产效率。</p>\n"},{"title":"加密算法简介","date":"2017-08-28T07:47:00.000Z","index_img":["/images/other/006_encrypt_0.jpg"],"_content":"\n### 简介\n\n先用一张图从大方向来介绍加密分类。当然更加详细的加密算法需要更深入的去学习，本篇主要是对加密算法有个大概的认知，能够认识到不同加密算法的优劣。\n\n```mermaid\ngraph TB\nA(加密) -->B(可逆)\nA(加密) -->C(不可逆)\nC -->D(对称加密)\nC -->E(非对称加密)\n```\n\n### 不可逆的加密算法\n\n#### 单向加密\n\n通过名称我们就可以了解到，就是明文经过加密之后，`无法通过解密`手段解析出加密之前到明文。既然无法解密得出明文，那该加密算法有什么应用场景呢？\n\n不能逆加密算法的应用场景主要是防止信息被篡改，可以明确消息在传递过程中没有被第三方篡改。典型的不可逆加密算法有MD5、SHA、HMAC、SM3等\n\n##### 不可逆特点\n\n1. 压缩性：任意长度明文信息经过加密之后得到长度都是固定的。\n2. 抗修改性：对原数据进行任何改动，哪怕是修改一个字节，得到结果都有很大的区别。\n3. 弱抗碰撞性：已知原数据和其单向加密结果，想找到一个具有相同结果的数据（即伪造数据）是非常困难的。\n4. 强抗碰撞性：想找到两个不同的数据，使它们具有相同的单向加密结果，是非常困难的。\n5. 简单高效：对数据进行单向加密处理速度是很快的。\n\n特点整理自[移动端加解密总结](https://zhuanlan.zhihu.com/p/22670078)\n\n### 可逆的加密算法\n\n可逆的加密算法就是明文经过加密之后，`可以通过解密`手段解析出加密之前得到明文。可逆的加密算法又分为对称加密和非对称加密。\n\n#### 对称加密\n\n对称加密算法，就是加密和解密使用的是同一个`密钥`。这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。\n\n常用的对称加密算法DES、AES、3DES、SM4\n\n##### 特点\n\n1. 密钥较小：密钥越大，加密越强，但是加解密的速度越慢。\n2. 优点：算法公开、计算量小、加密速度快、加密效率高，适合大的数据加密\n3. 缺点：密钥的管理分配。在发送密钥的过程中，密钥会有很大的风险被拦截。\n\n##### 加密模式\n\n对称加密算法还有一个需要留意的就是加密模式，即使使用的相同加密算法，加解密使用不同的加密模式也是无法获得正确的加密结果。主要了解下，ECB(电码本模式)、CCB(密码分组链接模式)模式。其他模式这里就详细介绍了，可以参考[AES加密模式](https://zhuanlan.zhihu.com/p/131324301)。\n\n###### ECB(电码本模式)\n\n这种模式将整个明文分成若干段相同的小段，然后对每一个小段进行加密。不同对称加密算法的段长度不同。\n\n对于AES加密算法来说这个小段的长度为128bit。这里就出现另外一个问题就是如果明文的长度不是128bit的倍数，就需要填充到128bit的倍数。就需要[填充模式](##### 填充模式)\n\nECB模式存在一个明显的问题，如果使用相同的密钥，那么相同的明文块就会生成相同的密文块，不能很好的隐藏数据模式。比如相同json结构，使用相同的密钥加密，能够推出加密模式为ECB模式。这听起来没什么大事，但事实上这对数据安全是一个很大的威胁。因此，`在密码协议中不建议使用ECB模式`\n\n![img](https://cocoon-break.github.io/images/other/006_encrypt_1.jpg)\n\n###### CCB(密码分组链接模式)\n\n这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。\n\n那这里也有新的问题产生了，如果使用这种模式，第一段的明文块怎么加密？\n\n这里就产生了一个概念**初始化向量IV**，初始化向量IV的作用是先与第一个明文块进行异或，得到第一个明文块，然后再进行后续的加密。\n\nCCB模式也存在一个明显的问题，加密过程是串行的，不能并行，速度比较慢。但是解密可以并行。另外，如果密文的某一位被修改了，只会使这个密文块所对应的明文块完全改变并且改变下一个明文块的对应位，安全性仍然有一定的欠缺。\n\n##### 填充模式\n\n1. NoPadding，这个很好理解就是不填充。但是有一个要求是，明文长度必须是`加密算法分段之后长度`的倍数。比如AES就是128bit\n2. PKCS7Padding，假设数据长度需要填充n(n>0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。（AES常用）\n3. PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。\n4. zeropadding，数据长度不对齐时使用0填充，否则不填充。\n5. ISO 10126，最后一个字节是填充的字节数（包括最后一字节），其他全部填随机数\n6. ANSI X9.23，跟ISO 10126很像，只不过ANSI X9.23其他字节填的都是0而不是随机数\n\n\n**注：**\n\n1. 初始化向量IV，除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。\n2. 除OFB和CTR不需要填充！其他的加密模式都是需要填充的\n\n\n\n#### 非对称加密\n\n非对称加密算法，就是加密和解密使用的不是相同的密钥。一个可以公开的密钥叫`公钥`，主要用来加密使用。一个需要私密保存的的密钥叫`私钥`。需要注意的是，公钥和私钥必须是一对，如果用公钥加密，必须使用对应的私钥才能解密。\n\n常用的非对称加密算法RSA、SM2\n\n##### 特点\n\n1. 算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。\n2. 优点：密钥管理。使用公私钥，私钥只能安全的一方保管，公钥可以提供给任何人。公钥加密的消息只能私钥能解\n3. 缺点：效率低下\n\n\n\n浅显易懂的小灰漫画[什么是加密算法](https://zhuanlan.zhihu.com/p/55574439)","source":"_posts/006_加密算法简介.md","raw":"---\ntitle: 加密算法简介\ndate: 2017-08-28 15:47:00\nindex_img:\n- /images/other/006_encrypt_0.jpg\ntags: \n- 扩展\ncategories:\n- 算法\n---\n\n### 简介\n\n先用一张图从大方向来介绍加密分类。当然更加详细的加密算法需要更深入的去学习，本篇主要是对加密算法有个大概的认知，能够认识到不同加密算法的优劣。\n\n```mermaid\ngraph TB\nA(加密) -->B(可逆)\nA(加密) -->C(不可逆)\nC -->D(对称加密)\nC -->E(非对称加密)\n```\n\n### 不可逆的加密算法\n\n#### 单向加密\n\n通过名称我们就可以了解到，就是明文经过加密之后，`无法通过解密`手段解析出加密之前到明文。既然无法解密得出明文，那该加密算法有什么应用场景呢？\n\n不能逆加密算法的应用场景主要是防止信息被篡改，可以明确消息在传递过程中没有被第三方篡改。典型的不可逆加密算法有MD5、SHA、HMAC、SM3等\n\n##### 不可逆特点\n\n1. 压缩性：任意长度明文信息经过加密之后得到长度都是固定的。\n2. 抗修改性：对原数据进行任何改动，哪怕是修改一个字节，得到结果都有很大的区别。\n3. 弱抗碰撞性：已知原数据和其单向加密结果，想找到一个具有相同结果的数据（即伪造数据）是非常困难的。\n4. 强抗碰撞性：想找到两个不同的数据，使它们具有相同的单向加密结果，是非常困难的。\n5. 简单高效：对数据进行单向加密处理速度是很快的。\n\n特点整理自[移动端加解密总结](https://zhuanlan.zhihu.com/p/22670078)\n\n### 可逆的加密算法\n\n可逆的加密算法就是明文经过加密之后，`可以通过解密`手段解析出加密之前得到明文。可逆的加密算法又分为对称加密和非对称加密。\n\n#### 对称加密\n\n对称加密算法，就是加密和解密使用的是同一个`密钥`。这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。\n\n常用的对称加密算法DES、AES、3DES、SM4\n\n##### 特点\n\n1. 密钥较小：密钥越大，加密越强，但是加解密的速度越慢。\n2. 优点：算法公开、计算量小、加密速度快、加密效率高，适合大的数据加密\n3. 缺点：密钥的管理分配。在发送密钥的过程中，密钥会有很大的风险被拦截。\n\n##### 加密模式\n\n对称加密算法还有一个需要留意的就是加密模式，即使使用的相同加密算法，加解密使用不同的加密模式也是无法获得正确的加密结果。主要了解下，ECB(电码本模式)、CCB(密码分组链接模式)模式。其他模式这里就详细介绍了，可以参考[AES加密模式](https://zhuanlan.zhihu.com/p/131324301)。\n\n###### ECB(电码本模式)\n\n这种模式将整个明文分成若干段相同的小段，然后对每一个小段进行加密。不同对称加密算法的段长度不同。\n\n对于AES加密算法来说这个小段的长度为128bit。这里就出现另外一个问题就是如果明文的长度不是128bit的倍数，就需要填充到128bit的倍数。就需要[填充模式](##### 填充模式)\n\nECB模式存在一个明显的问题，如果使用相同的密钥，那么相同的明文块就会生成相同的密文块，不能很好的隐藏数据模式。比如相同json结构，使用相同的密钥加密，能够推出加密模式为ECB模式。这听起来没什么大事，但事实上这对数据安全是一个很大的威胁。因此，`在密码协议中不建议使用ECB模式`\n\n![img](https://cocoon-break.github.io/images/other/006_encrypt_1.jpg)\n\n###### CCB(密码分组链接模式)\n\n这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。\n\n那这里也有新的问题产生了，如果使用这种模式，第一段的明文块怎么加密？\n\n这里就产生了一个概念**初始化向量IV**，初始化向量IV的作用是先与第一个明文块进行异或，得到第一个明文块，然后再进行后续的加密。\n\nCCB模式也存在一个明显的问题，加密过程是串行的，不能并行，速度比较慢。但是解密可以并行。另外，如果密文的某一位被修改了，只会使这个密文块所对应的明文块完全改变并且改变下一个明文块的对应位，安全性仍然有一定的欠缺。\n\n##### 填充模式\n\n1. NoPadding，这个很好理解就是不填充。但是有一个要求是，明文长度必须是`加密算法分段之后长度`的倍数。比如AES就是128bit\n2. PKCS7Padding，假设数据长度需要填充n(n>0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。（AES常用）\n3. PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。\n4. zeropadding，数据长度不对齐时使用0填充，否则不填充。\n5. ISO 10126，最后一个字节是填充的字节数（包括最后一字节），其他全部填随机数\n6. ANSI X9.23，跟ISO 10126很像，只不过ANSI X9.23其他字节填的都是0而不是随机数\n\n\n**注：**\n\n1. 初始化向量IV，除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。\n2. 除OFB和CTR不需要填充！其他的加密模式都是需要填充的\n\n\n\n#### 非对称加密\n\n非对称加密算法，就是加密和解密使用的不是相同的密钥。一个可以公开的密钥叫`公钥`，主要用来加密使用。一个需要私密保存的的密钥叫`私钥`。需要注意的是，公钥和私钥必须是一对，如果用公钥加密，必须使用对应的私钥才能解密。\n\n常用的非对称加密算法RSA、SM2\n\n##### 特点\n\n1. 算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。\n2. 优点：密钥管理。使用公私钥，私钥只能安全的一方保管，公钥可以提供给任何人。公钥加密的消息只能私钥能解\n3. 缺点：效率低下\n\n\n\n浅显易懂的小灰漫画[什么是加密算法](https://zhuanlan.zhihu.com/p/55574439)","slug":"006_加密算法简介","published":1,"updated":"2021-03-10T06:00:08.339Z","_id":"ckm310lw9000117ym2jyk5agw","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>先用一张图从大方向来介绍加密分类。当然更加详细的加密算法需要更深入的去学习，本篇主要是对加密算法有个大概的认知，能够认识到不同加密算法的优劣。</p>\n<pre><code class=\"hljs mermaid\">graph TB\nA(加密) --&gt;B(可逆)\nA(加密) --&gt;C(不可逆)\nC --&gt;D(对称加密)\nC --&gt;E(非对称加密)</code></pre>\n\n<h3 id=\"不可逆的加密算法\"><a href=\"#不可逆的加密算法\" class=\"headerlink\" title=\"不可逆的加密算法\"></a>不可逆的加密算法</h3><h4 id=\"单向加密\"><a href=\"#单向加密\" class=\"headerlink\" title=\"单向加密\"></a>单向加密</h4><p>通过名称我们就可以了解到，就是明文经过加密之后，<code>无法通过解密</code>手段解析出加密之前到明文。既然无法解密得出明文，那该加密算法有什么应用场景呢？</p>\n<p>不能逆加密算法的应用场景主要是防止信息被篡改，可以明确消息在传递过程中没有被第三方篡改。典型的不可逆加密算法有MD5、SHA、HMAC、SM3等</p>\n<h5 id=\"不可逆特点\"><a href=\"#不可逆特点\" class=\"headerlink\" title=\"不可逆特点\"></a>不可逆特点</h5><ol>\n<li>压缩性：任意长度明文信息经过加密之后得到长度都是固定的。</li>\n<li>抗修改性：对原数据进行任何改动，哪怕是修改一个字节，得到结果都有很大的区别。</li>\n<li>弱抗碰撞性：已知原数据和其单向加密结果，想找到一个具有相同结果的数据（即伪造数据）是非常困难的。</li>\n<li>强抗碰撞性：想找到两个不同的数据，使它们具有相同的单向加密结果，是非常困难的。</li>\n<li>简单高效：对数据进行单向加密处理速度是很快的。</li>\n</ol>\n<p>特点整理自<a href=\"https://zhuanlan.zhihu.com/p/22670078\">移动端加解密总结</a></p>\n<h3 id=\"可逆的加密算法\"><a href=\"#可逆的加密算法\" class=\"headerlink\" title=\"可逆的加密算法\"></a>可逆的加密算法</h3><p>可逆的加密算法就是明文经过加密之后，<code>可以通过解密</code>手段解析出加密之前得到明文。可逆的加密算法又分为对称加密和非对称加密。</p>\n<h4 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h4><p>对称加密算法，就是加密和解密使用的是同一个<code>密钥</code>。这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。</p>\n<p>常用的对称加密算法DES、AES、3DES、SM4</p>\n<h5 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ol>\n<li>密钥较小：密钥越大，加密越强，但是加解密的速度越慢。</li>\n<li>优点：算法公开、计算量小、加密速度快、加密效率高，适合大的数据加密</li>\n<li>缺点：密钥的管理分配。在发送密钥的过程中，密钥会有很大的风险被拦截。</li>\n</ol>\n<h5 id=\"加密模式\"><a href=\"#加密模式\" class=\"headerlink\" title=\"加密模式\"></a>加密模式</h5><p>对称加密算法还有一个需要留意的就是加密模式，即使使用的相同加密算法，加解密使用不同的加密模式也是无法获得正确的加密结果。主要了解下，ECB(电码本模式)、CCB(密码分组链接模式)模式。其他模式这里就详细介绍了，可以参考<a href=\"https://zhuanlan.zhihu.com/p/131324301\">AES加密模式</a>。</p>\n<h6 id=\"ECB-电码本模式\"><a href=\"#ECB-电码本模式\" class=\"headerlink\" title=\"ECB(电码本模式)\"></a>ECB(电码本模式)</h6><p>这种模式将整个明文分成若干段相同的小段，然后对每一个小段进行加密。不同对称加密算法的段长度不同。</p>\n<p>对于AES加密算法来说这个小段的长度为128bit。这里就出现另外一个问题就是如果明文的长度不是128bit的倍数，就需要填充到128bit的倍数。就需要[填充模式](##### 填充模式)</p>\n<p>ECB模式存在一个明显的问题，如果使用相同的密钥，那么相同的明文块就会生成相同的密文块，不能很好的隐藏数据模式。比如相同json结构，使用相同的密钥加密，能够推出加密模式为ECB模式。这听起来没什么大事，但事实上这对数据安全是一个很大的威胁。因此，<code>在密码协议中不建议使用ECB模式</code></p>\n<p><img src=\"https://cocoon-break.github.io/images/other/006_encrypt_1.jpg\" alt=\"img\"></p>\n<h6 id=\"CCB-密码分组链接模式\"><a href=\"#CCB-密码分组链接模式\" class=\"headerlink\" title=\"CCB(密码分组链接模式)\"></a>CCB(密码分组链接模式)</h6><p>这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</p>\n<p>那这里也有新的问题产生了，如果使用这种模式，第一段的明文块怎么加密？</p>\n<p>这里就产生了一个概念<strong>初始化向量IV</strong>，初始化向量IV的作用是先与第一个明文块进行异或，得到第一个明文块，然后再进行后续的加密。</p>\n<p>CCB模式也存在一个明显的问题，加密过程是串行的，不能并行，速度比较慢。但是解密可以并行。另外，如果密文的某一位被修改了，只会使这个密文块所对应的明文块完全改变并且改变下一个明文块的对应位，安全性仍然有一定的欠缺。</p>\n<h5 id=\"填充模式\"><a href=\"#填充模式\" class=\"headerlink\" title=\"填充模式\"></a>填充模式</h5><ol>\n<li>NoPadding，这个很好理解就是不填充。但是有一个要求是，明文长度必须是<code>加密算法分段之后长度</code>的倍数。比如AES就是128bit</li>\n<li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。（AES常用）</li>\n<li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li>\n<li>zeropadding，数据长度不对齐时使用0填充，否则不填充。</li>\n<li>ISO 10126，最后一个字节是填充的字节数（包括最后一字节），其他全部填随机数</li>\n<li>ANSI X9.23，跟ISO 10126很像，只不过ANSI X9.23其他字节填的都是0而不是随机数</li>\n</ol>\n<p><strong>注：</strong></p>\n<ol>\n<li>初始化向量IV，除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。</li>\n<li>除OFB和CTR不需要填充！其他的加密模式都是需要填充的</li>\n</ol>\n<h4 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h4><p>非对称加密算法，就是加密和解密使用的不是相同的密钥。一个可以公开的密钥叫<code>公钥</code>，主要用来加密使用。一个需要私密保存的的密钥叫<code>私钥</code>。需要注意的是，公钥和私钥必须是一对，如果用公钥加密，必须使用对应的私钥才能解密。</p>\n<p>常用的非对称加密算法RSA、SM2</p>\n<h5 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ol>\n<li>算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</li>\n<li>优点：密钥管理。使用公私钥，私钥只能安全的一方保管，公钥可以提供给任何人。公钥加密的消息只能私钥能解</li>\n<li>缺点：效率低下</li>\n</ol>\n<p>浅显易懂的小灰漫画<a href=\"https://zhuanlan.zhihu.com/p/55574439\">什么是加密算法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>先用一张图从大方向来介绍加密分类。当然更加详细的加密算法需要更深入的去学习，本篇主要是对加密算法有个大概的认知，能够认识到不同加密算法的优劣。</p>\n<pre><code class=\"hljs mermaid\">graph TB\nA(加密) --&gt;B(可逆)\nA(加密) --&gt;C(不可逆)\nC --&gt;D(对称加密)\nC --&gt;E(非对称加密)</code></pre>\n\n<h3 id=\"不可逆的加密算法\"><a href=\"#不可逆的加密算法\" class=\"headerlink\" title=\"不可逆的加密算法\"></a>不可逆的加密算法</h3><h4 id=\"单向加密\"><a href=\"#单向加密\" class=\"headerlink\" title=\"单向加密\"></a>单向加密</h4><p>通过名称我们就可以了解到，就是明文经过加密之后，<code>无法通过解密</code>手段解析出加密之前到明文。既然无法解密得出明文，那该加密算法有什么应用场景呢？</p>\n<p>不能逆加密算法的应用场景主要是防止信息被篡改，可以明确消息在传递过程中没有被第三方篡改。典型的不可逆加密算法有MD5、SHA、HMAC、SM3等</p>\n<h5 id=\"不可逆特点\"><a href=\"#不可逆特点\" class=\"headerlink\" title=\"不可逆特点\"></a>不可逆特点</h5><ol>\n<li>压缩性：任意长度明文信息经过加密之后得到长度都是固定的。</li>\n<li>抗修改性：对原数据进行任何改动，哪怕是修改一个字节，得到结果都有很大的区别。</li>\n<li>弱抗碰撞性：已知原数据和其单向加密结果，想找到一个具有相同结果的数据（即伪造数据）是非常困难的。</li>\n<li>强抗碰撞性：想找到两个不同的数据，使它们具有相同的单向加密结果，是非常困难的。</li>\n<li>简单高效：对数据进行单向加密处理速度是很快的。</li>\n</ol>\n<p>特点整理自<a href=\"https://zhuanlan.zhihu.com/p/22670078\">移动端加解密总结</a></p>\n<h3 id=\"可逆的加密算法\"><a href=\"#可逆的加密算法\" class=\"headerlink\" title=\"可逆的加密算法\"></a>可逆的加密算法</h3><p>可逆的加密算法就是明文经过加密之后，<code>可以通过解密</code>手段解析出加密之前得到明文。可逆的加密算法又分为对称加密和非对称加密。</p>\n<h4 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h4><p>对称加密算法，就是加密和解密使用的是同一个<code>密钥</code>。这个密钥既可以加密也用于解密，因而其安全性依赖于所持有密钥的安全性。</p>\n<p>常用的对称加密算法DES、AES、3DES、SM4</p>\n<h5 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ol>\n<li>密钥较小：密钥越大，加密越强，但是加解密的速度越慢。</li>\n<li>优点：算法公开、计算量小、加密速度快、加密效率高，适合大的数据加密</li>\n<li>缺点：密钥的管理分配。在发送密钥的过程中，密钥会有很大的风险被拦截。</li>\n</ol>\n<h5 id=\"加密模式\"><a href=\"#加密模式\" class=\"headerlink\" title=\"加密模式\"></a>加密模式</h5><p>对称加密算法还有一个需要留意的就是加密模式，即使使用的相同加密算法，加解密使用不同的加密模式也是无法获得正确的加密结果。主要了解下，ECB(电码本模式)、CCB(密码分组链接模式)模式。其他模式这里就详细介绍了，可以参考<a href=\"https://zhuanlan.zhihu.com/p/131324301\">AES加密模式</a>。</p>\n<h6 id=\"ECB-电码本模式\"><a href=\"#ECB-电码本模式\" class=\"headerlink\" title=\"ECB(电码本模式)\"></a>ECB(电码本模式)</h6><p>这种模式将整个明文分成若干段相同的小段，然后对每一个小段进行加密。不同对称加密算法的段长度不同。</p>\n<p>对于AES加密算法来说这个小段的长度为128bit。这里就出现另外一个问题就是如果明文的长度不是128bit的倍数，就需要填充到128bit的倍数。就需要[填充模式](##### 填充模式)</p>\n<p>ECB模式存在一个明显的问题，如果使用相同的密钥，那么相同的明文块就会生成相同的密文块，不能很好的隐藏数据模式。比如相同json结构，使用相同的密钥加密，能够推出加密模式为ECB模式。这听起来没什么大事，但事实上这对数据安全是一个很大的威胁。因此，<code>在密码协议中不建议使用ECB模式</code></p>\n<p><img src=\"https://cocoon-break.github.io/images/other/006_encrypt_1.jpg\" alt=\"img\"></p>\n<h6 id=\"CCB-密码分组链接模式\"><a href=\"#CCB-密码分组链接模式\" class=\"headerlink\" title=\"CCB(密码分组链接模式)\"></a>CCB(密码分组链接模式)</h6><p>这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</p>\n<p>那这里也有新的问题产生了，如果使用这种模式，第一段的明文块怎么加密？</p>\n<p>这里就产生了一个概念<strong>初始化向量IV</strong>，初始化向量IV的作用是先与第一个明文块进行异或，得到第一个明文块，然后再进行后续的加密。</p>\n<p>CCB模式也存在一个明显的问题，加密过程是串行的，不能并行，速度比较慢。但是解密可以并行。另外，如果密文的某一位被修改了，只会使这个密文块所对应的明文块完全改变并且改变下一个明文块的对应位，安全性仍然有一定的欠缺。</p>\n<h5 id=\"填充模式\"><a href=\"#填充模式\" class=\"headerlink\" title=\"填充模式\"></a>填充模式</h5><ol>\n<li>NoPadding，这个很好理解就是不填充。但是有一个要求是，明文长度必须是<code>加密算法分段之后长度</code>的倍数。比如AES就是128bit</li>\n<li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。（AES常用）</li>\n<li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li>\n<li>zeropadding，数据长度不对齐时使用0填充，否则不填充。</li>\n<li>ISO 10126，最后一个字节是填充的字节数（包括最后一字节），其他全部填随机数</li>\n<li>ANSI X9.23，跟ISO 10126很像，只不过ANSI X9.23其他字节填的都是0而不是随机数</li>\n</ol>\n<p><strong>注：</strong></p>\n<ol>\n<li>初始化向量IV，除ECB以外的所有加密方式中，都需要用到IV对加密结果进行随机化。</li>\n<li>除OFB和CTR不需要填充！其他的加密模式都是需要填充的</li>\n</ol>\n<h4 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h4><p>非对称加密算法，就是加密和解密使用的不是相同的密钥。一个可以公开的密钥叫<code>公钥</code>，主要用来加密使用。一个需要私密保存的的密钥叫<code>私钥</code>。需要注意的是，公钥和私钥必须是一对，如果用公钥加密，必须使用对应的私钥才能解密。</p>\n<p>常用的非对称加密算法RSA、SM2</p>\n<h5 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ol>\n<li>算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</li>\n<li>优点：密钥管理。使用公私钥，私钥只能安全的一方保管，公钥可以提供给任何人。公钥加密的消息只能私钥能解</li>\n<li>缺点：效率低下</li>\n</ol>\n<p>浅显易懂的小灰漫画<a href=\"https://zhuanlan.zhihu.com/p/55574439\">什么是加密算法</a></p>\n"},{"title":"MySQL系列一之基础使用","date":"2018-08-12T11:47:00.000Z","index_img":["/images/mysql/007_mysql_0.jpg"],"_content":"\nMySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。\n\n### 链接MySQL服务\n\n通过命令行建立链接\n\n```shell\n# -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e\"show databases\" \n# 建立链接的同时，执行提前写好的sql文件\nmysql -uroot -proot < test.sql\n```\n\n### 数据库管理\n\n数据库管理包括，数据库创建，数据库删除，数据库使用等操作\n\n```mysql\n-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;\n```\n\n### 数据表管理\n\n数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改\n\n```mysql\n-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname ='golang',description='开发语言';\nINSERT INTO class (cname,description) VALUES('PHP','开发语言'),('Mysql','数据库');\n-- 数据表删除单条记录\ndelete from class where cname='golang';\n-- 数据表修改单条记录\nupdate class set cname = \"PHP2\" where id=2;\n-- 删除表\ndrop table if exits class;\n```\n\n创建数据模板表，后续可以根据模板表创建新的数据表\n\n```mysql\n-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;\n```\n\n数据表字段名称修改以及字段增删\n\n```mysql\n-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);\n```\n\n数据表相关主键操作，主键的增删\n\n```mysql\n-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);\n```\n\n### 数据类型\n\nMySQL数据类型包括字符串，数值类型，枚举类型\n\n**字符串数据类型**\n\n| 类型       | 大小                | 用途                            |\n| :--------- | :------------------ | :------------------------------ |\n| CHAR       | 0-255字节           | 定长字符串                      |\n| VARCHAR    | 0-65535 字节        | 变长字符串                      |\n| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255字节           | 短文本字符串                    |\n| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535字节        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |\n\nCHAR类型是定长的数据类型，比如定义20长度的`char`类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。\n\nVARCHAR类型是变长数据类型，空间受内容长度影响。\n\n**字符串常用函数**\n\n| 函数名          | 作用                         | 示例                                                  |\n| --------------- | ---------------------------- | ----------------------------------------------------- |\n| UPPER()/LOWER() | 将内容全部改成大写/小写      | select UPPER(cname) from class;                       |\n| CONCAT()        | 字符拼接                     | select concat(cname,description) from class;          |\n| Left()/Right()  | 用于取左或右指定数量的字符   | select left(cname,3) from class;                      |\n| mid             | 从中间取字符串               | select *  from class where mid(cname,2,2) = 'hp';     |\n| substring       | 从指定位置开始向右截取字符串 | select *  from class where SUBSTRING(cname,2) = 'hp'; |\n| char_length     | 获取字符串数量               | select char_length(cname) from class;                 |\n\n正则表达式和like的使用\n\n```mysql\n-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP 'php|mysql';\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE '_h%';\n```\n\n**数值整型类型**\n\n| MySQL数据类型 | 含义（有符号）                       |\n| ------------- | ------------------------------------ |\n| tinyint(m)    | 1个字节 范围(-128~127)               |\n| smallint(m)   | 2个字节 范围(-32768~32767)           |\n| mediumint(m)  | 3个字节 范围(-8388608~8388607)       |\n| int(m)        | 4个字节 范围(-2147483648~2147483647) |\n| bigint(m)     | 8个字节 范围(+-9.22*10的18次方)      |\n\n取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。\n\n**数值浮点型**\n\n| 类型    | 大小                               | 范围（有符号）                                               | 范围（无符号）                                               |\n| :------ | :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| FLOAT   | 4 字节                             | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  |\n| DOUBLE  | 8 字节                             | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |\n| DECIMAL | DECIMAL(M,D) ，m<65 是总个数，d<30 | 依赖于M和D的值                                               | 依赖于M和D的值                                               |\n\n**ENUM/SET**\n\nENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。\n\nSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。\n\n### 日期时间\n\n| 日期时间类型 | 占用空间 | 日期格式            | 最小值              | 最大值              | 零值表示            |\n| ------------ | -------- | ------------------- | ------------------- | ------------------- | ------------------- |\n| DATETIME     | 8 bytes  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 | 0000-00-00 00:00:00 |\n| TIMESTAMP    | 4 bytes  | YYYY-MM-DD HH:MM:SS | 1970-01-01 08:00:01 | 2038-01-19 03:14:07 | 00000000000000      |\n| DATE         | 4 bytes  | YYYY-MM-DD          | 1000-01-01          | 9999-12-31          | 0000-00-00          |\n| TIME         | 3 bytes  | HH:MM:SS            | -838:59:59          | 838:59:59           | 00:00:00            |\n| YEAR         | 1 bytes  | YYYY                | 1901                | 2155                | 0000                |\n\nMysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,\n\n创建字段\n\n```sql\nALTER TABLE class ADD create_at datetime default null;\n```\n\n对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档\n\n| 参数 | 描述                               |\n| ---- | ---------------------------------- |\n| %Y   | 年，4 位                           |\n| %y   | 年，2位                            |\n| %M   | 月名                               |\n| %m   | 月，数值(00-12)                    |\n| %H   | 小时 (00-23)                       |\n| %h   | 小时 (01-12)                       |\n| %i   | 分钟，数值(00-59)                  |\n| %s   | 秒(00-59)                          |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM） |\n\n使用示例\n\n```mysql\nselect cname,DATE_FORMAT(create_at,'%Y年%m月%d %H时%i分%s秒') as create_at from class;\nselect cname,TIME_FORMAT(create_at,'%r') as create_at from class;\n```\n\n**添加数据时自动更新时间**\n\n```mysql\nalter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n```\n\n只要该条记录有任何一个字段被修改，则自动更新update_at字段的值\n\n**常用函数**\n\n| 函数                    | 说明                                                 |\n| ----------------------- | ---------------------------------------------------- |\n| HOUR                    | 小时                                                 |\n| MINUTE                  | 分                                                   |\n| SECOND                  | 秒                                                   |\n| YEAR                    | 年                                                   |\n| MONTH                   | 月                                                   |\n| DAY                     | 日                                                   |\n| TIME                    | 获取时间                                             |\n| WEEK                    | 周                                                   |\n| QUARTER                 | 季                                                   |\n| CURRENT_DATE（CURDATE） | 当前日期                                             |\n| CURRENT_TIME            | 当前时间                                             |\n| NOW                     | 当前时间                                             |\n| DAYOFYEAR               | 一年中的日数                                         |\n| DAYOFMONTH              | 月份中日数                                           |\n| DAYOFWEEK               | 星期天（1）到星期六（7）                             |\n| WEEKDAY                 | 星期一（0）到星期天（6）                             |\n| TO_DAYS                 | 从元年到现在的天数（忽略时间部分）                   |\n| FROM_DAYS               | 根据天数得到日期（忽略时间部分）                     |\n| TIME_TO_SEC             | 时间转为秒数（忽略日期部分）                         |\n| SEC_TO_TIME             | 根据秒数转为时间（忽略日期部分）                     |\n| UNIX_TIMESTAMP          | 根据日期返回秒数（包括日期与时间）                   |\n| FROM_UNIXTIME           | 根据秒数返回日期与时间（包括日期与时间）             |\n| DATEDIFF                | 两个日期相差的天数（忽略时间部分）                   |\n| TIMEDIFF                | 计算两个时间的间隔（忽略日期部分）                   |\n| TIMESTAMPDIFF           | 根据指定单位计算两个日期时间的间隔（包括日期与时间） |\n| LAST_DAY                | 该月的最后一天                                       |\n\n使用示例\n\n```mysql\n-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());\n```\n\n**时间计算 常用函数 **\n\n| 函数      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| ADDTIME   | 添加时间（负数为减少），只对时间有效                         |\n| TIMESTAMP | 添加时间（负数为减少），只对时间有效                         |\n| DATE_ADD  | 根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB) |\n| DATE_SUB  | DATE_ADD的反函数                                             |\n| LAST_DAY  | 指定月最后一天日期                                           |\n\n使用示例\n\n```mysql\n-- 获取七小时之前的时间\nselect ADDTIME(now(),'-7:00:00')\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);\n```\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))\n\n","source":"_posts/007_MySQL系列一.md","raw":"---\ntitle: MySQL系列一之基础使用\ndate: 2018-08-12 19:47:00\nindex_img:\n- /images/mysql/007_mysql_0.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\nMySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。\n\n### 链接MySQL服务\n\n通过命令行建立链接\n\n```shell\n# -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e\"show databases\" \n# 建立链接的同时，执行提前写好的sql文件\nmysql -uroot -proot < test.sql\n```\n\n### 数据库管理\n\n数据库管理包括，数据库创建，数据库删除，数据库使用等操作\n\n```mysql\n-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;\n```\n\n### 数据表管理\n\n数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改\n\n```mysql\n-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname ='golang',description='开发语言';\nINSERT INTO class (cname,description) VALUES('PHP','开发语言'),('Mysql','数据库');\n-- 数据表删除单条记录\ndelete from class where cname='golang';\n-- 数据表修改单条记录\nupdate class set cname = \"PHP2\" where id=2;\n-- 删除表\ndrop table if exits class;\n```\n\n创建数据模板表，后续可以根据模板表创建新的数据表\n\n```mysql\n-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;\n```\n\n数据表字段名称修改以及字段增删\n\n```mysql\n-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);\n```\n\n数据表相关主键操作，主键的增删\n\n```mysql\n-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);\n```\n\n### 数据类型\n\nMySQL数据类型包括字符串，数值类型，枚举类型\n\n**字符串数据类型**\n\n| 类型       | 大小                | 用途                            |\n| :--------- | :------------------ | :------------------------------ |\n| CHAR       | 0-255字节           | 定长字符串                      |\n| VARCHAR    | 0-65535 字节        | 变长字符串                      |\n| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255字节           | 短文本字符串                    |\n| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535字节        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |\n\nCHAR类型是定长的数据类型，比如定义20长度的`char`类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。\n\nVARCHAR类型是变长数据类型，空间受内容长度影响。\n\n**字符串常用函数**\n\n| 函数名          | 作用                         | 示例                                                  |\n| --------------- | ---------------------------- | ----------------------------------------------------- |\n| UPPER()/LOWER() | 将内容全部改成大写/小写      | select UPPER(cname) from class;                       |\n| CONCAT()        | 字符拼接                     | select concat(cname,description) from class;          |\n| Left()/Right()  | 用于取左或右指定数量的字符   | select left(cname,3) from class;                      |\n| mid             | 从中间取字符串               | select *  from class where mid(cname,2,2) = 'hp';     |\n| substring       | 从指定位置开始向右截取字符串 | select *  from class where SUBSTRING(cname,2) = 'hp'; |\n| char_length     | 获取字符串数量               | select char_length(cname) from class;                 |\n\n正则表达式和like的使用\n\n```mysql\n-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP 'php|mysql';\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE '_h%';\n```\n\n**数值整型类型**\n\n| MySQL数据类型 | 含义（有符号）                       |\n| ------------- | ------------------------------------ |\n| tinyint(m)    | 1个字节 范围(-128~127)               |\n| smallint(m)   | 2个字节 范围(-32768~32767)           |\n| mediumint(m)  | 3个字节 范围(-8388608~8388607)       |\n| int(m)        | 4个字节 范围(-2147483648~2147483647) |\n| bigint(m)     | 8个字节 范围(+-9.22*10的18次方)      |\n\n取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。\n\n**数值浮点型**\n\n| 类型    | 大小                               | 范围（有符号）                                               | 范围（无符号）                                               |\n| :------ | :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| FLOAT   | 4 字节                             | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  |\n| DOUBLE  | 8 字节                             | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |\n| DECIMAL | DECIMAL(M,D) ，m<65 是总个数，d<30 | 依赖于M和D的值                                               | 依赖于M和D的值                                               |\n\n**ENUM/SET**\n\nENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。\n\nSET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。\n\n### 日期时间\n\n| 日期时间类型 | 占用空间 | 日期格式            | 最小值              | 最大值              | 零值表示            |\n| ------------ | -------- | ------------------- | ------------------- | ------------------- | ------------------- |\n| DATETIME     | 8 bytes  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 | 9999-12-31 23:59:59 | 0000-00-00 00:00:00 |\n| TIMESTAMP    | 4 bytes  | YYYY-MM-DD HH:MM:SS | 1970-01-01 08:00:01 | 2038-01-19 03:14:07 | 00000000000000      |\n| DATE         | 4 bytes  | YYYY-MM-DD          | 1000-01-01          | 9999-12-31          | 0000-00-00          |\n| TIME         | 3 bytes  | HH:MM:SS            | -838:59:59          | 838:59:59           | 00:00:00            |\n| YEAR         | 1 bytes  | YYYY                | 1901                | 2155                | 0000                |\n\nMysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,\n\n创建字段\n\n```sql\nALTER TABLE class ADD create_at datetime default null;\n```\n\n对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档\n\n| 参数 | 描述                               |\n| ---- | ---------------------------------- |\n| %Y   | 年，4 位                           |\n| %y   | 年，2位                            |\n| %M   | 月名                               |\n| %m   | 月，数值(00-12)                    |\n| %H   | 小时 (00-23)                       |\n| %h   | 小时 (01-12)                       |\n| %i   | 分钟，数值(00-59)                  |\n| %s   | 秒(00-59)                          |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM） |\n\n使用示例\n\n```mysql\nselect cname,DATE_FORMAT(create_at,'%Y年%m月%d %H时%i分%s秒') as create_at from class;\nselect cname,TIME_FORMAT(create_at,'%r') as create_at from class;\n```\n\n**添加数据时自动更新时间**\n\n```mysql\nalter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;\n```\n\n只要该条记录有任何一个字段被修改，则自动更新update_at字段的值\n\n**常用函数**\n\n| 函数                    | 说明                                                 |\n| ----------------------- | ---------------------------------------------------- |\n| HOUR                    | 小时                                                 |\n| MINUTE                  | 分                                                   |\n| SECOND                  | 秒                                                   |\n| YEAR                    | 年                                                   |\n| MONTH                   | 月                                                   |\n| DAY                     | 日                                                   |\n| TIME                    | 获取时间                                             |\n| WEEK                    | 周                                                   |\n| QUARTER                 | 季                                                   |\n| CURRENT_DATE（CURDATE） | 当前日期                                             |\n| CURRENT_TIME            | 当前时间                                             |\n| NOW                     | 当前时间                                             |\n| DAYOFYEAR               | 一年中的日数                                         |\n| DAYOFMONTH              | 月份中日数                                           |\n| DAYOFWEEK               | 星期天（1）到星期六（7）                             |\n| WEEKDAY                 | 星期一（0）到星期天（6）                             |\n| TO_DAYS                 | 从元年到现在的天数（忽略时间部分）                   |\n| FROM_DAYS               | 根据天数得到日期（忽略时间部分）                     |\n| TIME_TO_SEC             | 时间转为秒数（忽略日期部分）                         |\n| SEC_TO_TIME             | 根据秒数转为时间（忽略日期部分）                     |\n| UNIX_TIMESTAMP          | 根据日期返回秒数（包括日期与时间）                   |\n| FROM_UNIXTIME           | 根据秒数返回日期与时间（包括日期与时间）             |\n| DATEDIFF                | 两个日期相差的天数（忽略时间部分）                   |\n| TIMEDIFF                | 计算两个时间的间隔（忽略日期部分）                   |\n| TIMESTAMPDIFF           | 根据指定单位计算两个日期时间的间隔（包括日期与时间） |\n| LAST_DAY                | 该月的最后一天                                       |\n\n使用示例\n\n```mysql\n-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());\n```\n\n**时间计算 常用函数 **\n\n| 函数      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| ADDTIME   | 添加时间（负数为减少），只对时间有效                         |\n| TIMESTAMP | 添加时间（负数为减少），只对时间有效                         |\n| DATE_ADD  | 根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB) |\n| DATE_SUB  | DATE_ADD的反函数                                             |\n| LAST_DAY  | 指定月最后一天日期                                           |\n\n使用示例\n\n```mysql\n-- 获取七小时之前的时间\nselect ADDTIME(now(),'-7:00:00')\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);\n```\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))\n\n","slug":"007_MySQL系列一","published":1,"updated":"2021-03-10T06:05:48.346Z","_id":"ckm31ea07000717ymh0hq0hg4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>MySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。</p>\n<h3 id=\"链接MySQL服务\"><a href=\"#链接MySQL服务\" class=\"headerlink\" title=\"链接MySQL服务\"></a>链接MySQL服务</h3><p>通过命令行建立链接</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作</span>\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e&quot;show databases&quot; \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 建立链接的同时，执行提前写好的sql文件</span>\nmysql -uroot -proot &lt; test.sql</code></pre>\n\n<h3 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h3><p>数据库管理包括，数据库创建，数据库删除，数据库使用等操作</p>\n<pre><code class=\"hljs mysql\">-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;</code></pre>\n\n<h3 id=\"数据表管理\"><a href=\"#数据表管理\" class=\"headerlink\" title=\"数据表管理\"></a>数据表管理</h3><p>数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改</p>\n<pre><code class=\"hljs mysql\">-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname &#x3D;&#39;golang&#39;,description&#x3D;&#39;开发语言&#39;;\nINSERT INTO class (cname,description) VALUES(&#39;PHP&#39;,&#39;开发语言&#39;),(&#39;Mysql&#39;,&#39;数据库&#39;);\n-- 数据表删除单条记录\ndelete from class where cname&#x3D;&#39;golang&#39;;\n-- 数据表修改单条记录\nupdate class set cname &#x3D; &quot;PHP2&quot; where id&#x3D;2;\n-- 删除表\ndrop table if exits class;</code></pre>\n\n<p>创建数据模板表，后续可以根据模板表创建新的数据表</p>\n<pre><code class=\"hljs mysql\">-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;</code></pre>\n\n<p>数据表字段名称修改以及字段增删</p>\n<pre><code class=\"hljs mysql\">-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);</code></pre>\n\n<p>数据表相关主键操作，主键的增删</p>\n<pre><code class=\"hljs mysql\">-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</code></pre>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>MySQL数据类型包括字符串，数值类型，枚举类型</p>\n<p><strong>字符串数据类型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CHAR</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">定长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">VARCHAR</td>\n<td align=\"left\">0-65535 字节</td>\n<td align=\"left\">变长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYBLOB</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">不超过 255 个字符的二进制字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYTEXT</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">短文本字符串</td>\n</tr>\n<tr>\n<td align=\"left\">BLOB</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">TEXT</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMBLOB</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">二进制形式的中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMTEXT</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGBLOB</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">二进制形式的极大文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGTEXT</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">极大文本数据</td>\n</tr>\n</tbody></table>\n<p>CHAR类型是定长的数据类型，比如定义20长度的<code>char</code>类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。</p>\n<p>VARCHAR类型是变长数据类型，空间受内容长度影响。</p>\n<p><strong>字符串常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UPPER()/LOWER()</td>\n<td>将内容全部改成大写/小写</td>\n<td>select UPPER(cname) from class;</td>\n</tr>\n<tr>\n<td>CONCAT()</td>\n<td>字符拼接</td>\n<td>select concat(cname,description) from class;</td>\n</tr>\n<tr>\n<td>Left()/Right()</td>\n<td>用于取左或右指定数量的字符</td>\n<td>select left(cname,3) from class;</td>\n</tr>\n<tr>\n<td>mid</td>\n<td>从中间取字符串</td>\n<td>select *  from class where mid(cname,2,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>substring</td>\n<td>从指定位置开始向右截取字符串</td>\n<td>select *  from class where SUBSTRING(cname,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>char_length</td>\n<td>获取字符串数量</td>\n<td>select char_length(cname) from class;</td>\n</tr>\n</tbody></table>\n<p>正则表达式和like的使用</p>\n<pre><code class=\"hljs mysql\">-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP &#39;php|mysql&#39;;\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE &#39;_h%&#39;;</code></pre>\n\n<p><strong>数值整型类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>MySQL数据类型</th>\n<th>含义（有符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tinyint(m)</td>\n<td>1个字节 范围(-128~127)</td>\n</tr>\n<tr>\n<td>smallint(m)</td>\n<td>2个字节 范围(-32768~32767)</td>\n</tr>\n<tr>\n<td>mediumint(m)</td>\n<td>3个字节 范围(-8388608~8388607)</td>\n</tr>\n<tr>\n<td>int(m)</td>\n<td>4个字节 范围(-2147483648~2147483647)</td>\n</tr>\n<tr>\n<td>bigint(m)</td>\n<td>8个字节 范围(+-9.22*10的18次方)</td>\n</tr>\n</tbody></table>\n<p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。</p>\n<p><strong>数值浮点型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">范围（有符号）</th>\n<th align=\"left\">范围（无符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">FLOAT</td>\n<td align=\"left\">4 字节</td>\n<td align=\"left\">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>\n<td align=\"left\">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>\n</tr>\n<tr>\n<td align=\"left\">DOUBLE</td>\n<td align=\"left\">8 字节</td>\n<td align=\"left\">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n<td align=\"left\">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n</tr>\n<tr>\n<td align=\"left\">DECIMAL</td>\n<td align=\"left\">DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td>\n<td align=\"left\">依赖于M和D的值</td>\n<td align=\"left\">依赖于M和D的值</td>\n</tr>\n</tbody></table>\n<p><strong>ENUM/SET</strong></p>\n<p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。</p>\n<p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。</p>\n<h3 id=\"日期时间\"><a href=\"#日期时间\" class=\"headerlink\" title=\"日期时间\"></a>日期时间</h3><table>\n<thead>\n<tr>\n<th>日期时间类型</th>\n<th>占用空间</th>\n<th>日期格式</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>零值表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATETIME</td>\n<td>8 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1000-01-01 00:00:00</td>\n<td>9999-12-31 23:59:59</td>\n<td>0000-00-00 00:00:00</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1970-01-01 08:00:01</td>\n<td>2038-01-19 03:14:07</td>\n<td>00000000000000</td>\n</tr>\n<tr>\n<td>DATE</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD</td>\n<td>1000-01-01</td>\n<td>9999-12-31</td>\n<td>0000-00-00</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>3 bytes</td>\n<td>HH:MM:SS</td>\n<td>-838:59:59</td>\n<td>838:59:59</td>\n<td>00:00:00</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>1 bytes</td>\n<td>YYYY</td>\n<td>1901</td>\n<td>2155</td>\n<td>0000</td>\n</tr>\n</tbody></table>\n<p>Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,</p>\n<p>创建字段</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">ADD</span> create_at datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-literal\">null</span>;</code></pre>\n\n<p>对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%Y</td>\n<td>年，4 位</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年，2位</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>月名</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月，数值(00-12)</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>小时 (00-23)</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>小时 (01-12)</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>分钟，数值(00-59)</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>秒(00-59)</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>时间，12-小时（hh:mm:ss AM 或 PM）</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">select cname,DATE_FORMAT(create_at,&#39;%Y年%m月%d %H时%i分%s秒&#39;) as create_at from class;\nselect cname,TIME_FORMAT(create_at,&#39;%r&#39;) as create_at from class;</code></pre>\n\n<p><strong>添加数据时自动更新时间</strong></p>\n<pre><code class=\"hljs mysql\">alter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;</code></pre>\n\n<p>只要该条记录有任何一个字段被修改，则自动更新update_at字段的值</p>\n<p><strong>常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HOUR</td>\n<td>小时</td>\n</tr>\n<tr>\n<td>MINUTE</td>\n<td>分</td>\n</tr>\n<tr>\n<td>SECOND</td>\n<td>秒</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>年</td>\n</tr>\n<tr>\n<td>MONTH</td>\n<td>月</td>\n</tr>\n<tr>\n<td>DAY</td>\n<td>日</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>获取时间</td>\n</tr>\n<tr>\n<td>WEEK</td>\n<td>周</td>\n</tr>\n<tr>\n<td>QUARTER</td>\n<td>季</td>\n</tr>\n<tr>\n<td>CURRENT_DATE（CURDATE）</td>\n<td>当前日期</td>\n</tr>\n<tr>\n<td>CURRENT_TIME</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>NOW</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>DAYOFYEAR</td>\n<td>一年中的日数</td>\n</tr>\n<tr>\n<td>DAYOFMONTH</td>\n<td>月份中日数</td>\n</tr>\n<tr>\n<td>DAYOFWEEK</td>\n<td>星期天（1）到星期六（7）</td>\n</tr>\n<tr>\n<td>WEEKDAY</td>\n<td>星期一（0）到星期天（6）</td>\n</tr>\n<tr>\n<td>TO_DAYS</td>\n<td>从元年到现在的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>FROM_DAYS</td>\n<td>根据天数得到日期（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIME_TO_SEC</td>\n<td>时间转为秒数（忽略日期部分）</td>\n</tr>\n<tr>\n<td>SEC_TO_TIME</td>\n<td>根据秒数转为时间（忽略日期部分）</td>\n</tr>\n<tr>\n<td>UNIX_TIMESTAMP</td>\n<td>根据日期返回秒数（包括日期与时间）</td>\n</tr>\n<tr>\n<td>FROM_UNIXTIME</td>\n<td>根据秒数返回日期与时间（包括日期与时间）</td>\n</tr>\n<tr>\n<td>DATEDIFF</td>\n<td>两个日期相差的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIMEDIFF</td>\n<td>计算两个时间的间隔（忽略日期部分）</td>\n</tr>\n<tr>\n<td>TIMESTAMPDIFF</td>\n<td>根据指定单位计算两个日期时间的间隔（包括日期与时间）</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>该月的最后一天</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());</code></pre>\n\n<p>**时间计算 常用函数 **</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADDTIME</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>DATE_ADD</td>\n<td>根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB)</td>\n</tr>\n<tr>\n<td>DATE_SUB</td>\n<td>DATE_ADD的反函数</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>指定月最后一天日期</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 获取七小时之前的时间\nselect ADDTIME(now(),&#39;-7:00:00&#39;)\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);</code></pre>\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL是平常使用较多的数据，因项目需要发现自身对MySQL有所欠缺。所以复习了一下MySQL知识，做个总结归纳。本文介绍为基础知识，从数据库链接开始，包括一些常用SQL语句，和MySQL的一些数据类型。建议使用docker 的MySQL 进行SQL练习。同时推荐个人比较喜欢使用的数据库可视化软件Table Plus。</p>\n<h3 id=\"链接MySQL服务\"><a href=\"#链接MySQL服务\" class=\"headerlink\" title=\"链接MySQL服务\"></a>链接MySQL服务</h3><p>通过命令行建立链接</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> -u 参数指定用户名，-p指定密码，-P指定端口默认是3306，-h 是指定主机地址,-e 指定链接之后操作</span>\nmysql -uroot -proot -P3306 -h 127.0.0.1\nmysql -uroot -proot -e&quot;show databases&quot; \n<span class=\"hljs-meta\">#</span><span class=\"bash\"> 建立链接的同时，执行提前写好的sql文件</span>\nmysql -uroot -proot &lt; test.sql</code></pre>\n\n<h3 id=\"数据库管理\"><a href=\"#数据库管理\" class=\"headerlink\" title=\"数据库管理\"></a>数据库管理</h3><p>数据库管理包括，数据库创建，数据库删除，数据库使用等操作</p>\n<pre><code class=\"hljs mysql\">-- 创建数据库并指定字符集\ncreate database test charset utf8;\n-- 数据库查看\nshow databases;\n-- 删除数据库\ndrop database test;\n-- 一般为了删除不存在的数据库报错，可以通过if exits\ndrop database if exits test;\n-- 使用数据库\nuse test;</code></pre>\n\n<h3 id=\"数据表管理\"><a href=\"#数据表管理\" class=\"headerlink\" title=\"数据表管理\"></a>数据表管理</h3><p>数据表管理包括，数据表创建，数据表删除，数据表记录增删改，数据表字段名修改</p>\n<pre><code class=\"hljs mysql\">-- 创建class 表id 自增，同时指定表字符集\ncreate table class (id int primary key AUTO_INCREMENT,cname varchar(30) NOT NULL,description varchar(100) default NULL) charset utf8;\n-- 数据表插入单条数据，和多条数据\nINSERT INTO class set cname &#x3D;&#39;golang&#39;,description&#x3D;&#39;开发语言&#39;;\nINSERT INTO class (cname,description) VALUES(&#39;PHP&#39;,&#39;开发语言&#39;),(&#39;Mysql&#39;,&#39;数据库&#39;);\n-- 数据表删除单条记录\ndelete from class where cname&#x3D;&#39;golang&#39;;\n-- 数据表修改单条记录\nupdate class set cname &#x3D; &quot;PHP2&quot; where id&#x3D;2;\n-- 删除表\ndrop table if exits class;</code></pre>\n\n<p>创建数据模板表，后续可以根据模板表创建新的数据表</p>\n<pre><code class=\"hljs mysql\">-- 复制表结构\ncreate table tcopy like class;\n-- 复制表同时复制数据\ncreate table tcopy select * from class;</code></pre>\n\n<p>数据表字段名称修改以及字段增删</p>\n<pre><code class=\"hljs mysql\">-- 数据表重命名\nalter table class rename classes;\nrename table classes to class;\n-- 数据表增加字段\nalter table class add school varchar(50);\n-- 数据表删除字段\nalter table class drop school;\n-- 修改字段名\nalter table class CHANGE description descriptions varchar(30);</code></pre>\n\n<p>数据表相关主键操作，主键的增删</p>\n<pre><code class=\"hljs mysql\">-- 主键为自增字段，需要删除自增属性后才可以删除主键\nalter table class MODIFY id int not null;-- 删除自增\nalter table class DROP PRIMARY key;-- 删除主键\n\n-- 添加表主键\nalter table class add PRIMARY KEY(id);-- 添加表主键\nalter table class MODIFY id int not null AUTO_INCREMENT;-- 添加自增列\nalter table class modify id int not null AUTO_INCREMENT ,add PRIMARY key(id);</code></pre>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>MySQL数据类型包括字符串，数值类型，枚举类型</p>\n<p><strong>字符串数据类型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CHAR</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">定长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">VARCHAR</td>\n<td align=\"left\">0-65535 字节</td>\n<td align=\"left\">变长字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYBLOB</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">不超过 255 个字符的二进制字符串</td>\n</tr>\n<tr>\n<td align=\"left\">TINYTEXT</td>\n<td align=\"left\">0-255字节</td>\n<td align=\"left\">短文本字符串</td>\n</tr>\n<tr>\n<td align=\"left\">BLOB</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">二进制形式的长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">TEXT</td>\n<td align=\"left\">0-65 535字节</td>\n<td align=\"left\">长文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMBLOB</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">二进制形式的中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">MEDIUMTEXT</td>\n<td align=\"left\">0-16 777 215字节</td>\n<td align=\"left\">中等长度文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGBLOB</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">二进制形式的极大文本数据</td>\n</tr>\n<tr>\n<td align=\"left\">LONGTEXT</td>\n<td align=\"left\">0-4 294 967 295字节</td>\n<td align=\"left\">极大文本数据</td>\n</tr>\n</tbody></table>\n<p>CHAR类型是定长的数据类型，比如定义20长度的<code>char</code>类型即使只存一个字符，也占20个长度，好处是处理速度快，缺点是占用空间大。</p>\n<p>VARCHAR类型是变长数据类型，空间受内容长度影响。</p>\n<p><strong>字符串常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UPPER()/LOWER()</td>\n<td>将内容全部改成大写/小写</td>\n<td>select UPPER(cname) from class;</td>\n</tr>\n<tr>\n<td>CONCAT()</td>\n<td>字符拼接</td>\n<td>select concat(cname,description) from class;</td>\n</tr>\n<tr>\n<td>Left()/Right()</td>\n<td>用于取左或右指定数量的字符</td>\n<td>select left(cname,3) from class;</td>\n</tr>\n<tr>\n<td>mid</td>\n<td>从中间取字符串</td>\n<td>select *  from class where mid(cname,2,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>substring</td>\n<td>从指定位置开始向右截取字符串</td>\n<td>select *  from class where SUBSTRING(cname,2) = ‘hp’;</td>\n</tr>\n<tr>\n<td>char_length</td>\n<td>获取字符串数量</td>\n<td>select char_length(cname) from class;</td>\n</tr>\n</tbody></table>\n<p>正则表达式和like的使用</p>\n<pre><code class=\"hljs mysql\">-- 正则匹配php 或者MySQL\nSELECT * FROM class WHERE cname REGEXP &#39;php|mysql&#39;;\n-- _用于匹配一个字符，%用于匹配任意多个字符\nSELECT *  FROM class WHERE cname LIKE &#39;_h%&#39;;</code></pre>\n\n<p><strong>数值整型类型</strong></p>\n<table>\n<thead>\n<tr>\n<th>MySQL数据类型</th>\n<th>含义（有符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tinyint(m)</td>\n<td>1个字节 范围(-128~127)</td>\n</tr>\n<tr>\n<td>smallint(m)</td>\n<td>2个字节 范围(-32768~32767)</td>\n</tr>\n<tr>\n<td>mediumint(m)</td>\n<td>3个字节 范围(-8388608~8388607)</td>\n</tr>\n<tr>\n<td>int(m)</td>\n<td>4个字节 范围(-2147483648~2147483647)</td>\n</tr>\n<tr>\n<td>bigint(m)</td>\n<td>8个字节 范围(+-9.22*10的18次方)</td>\n</tr>\n</tbody></table>\n<p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。</p>\n<p><strong>数值浮点型</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">大小</th>\n<th align=\"left\">范围（有符号）</th>\n<th align=\"left\">范围（无符号）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">FLOAT</td>\n<td align=\"left\">4 字节</td>\n<td align=\"left\">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>\n<td align=\"left\">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>\n</tr>\n<tr>\n<td align=\"left\">DOUBLE</td>\n<td align=\"left\">8 字节</td>\n<td align=\"left\">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n<td align=\"left\">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>\n</tr>\n<tr>\n<td align=\"left\">DECIMAL</td>\n<td align=\"left\">DECIMAL(M,D) ，m&lt;65 是总个数，d&lt;30</td>\n<td align=\"left\">依赖于M和D的值</td>\n<td align=\"left\">依赖于M和D的值</td>\n</tr>\n</tbody></table>\n<p><strong>ENUM/SET</strong></p>\n<p>ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。</p>\n<p>SET 类型与 ENUM 类型相似但不相同。SET 类型可以从预定义的集合中取得任意数量的值。　一个 SET 类型最多可以包含 64 项元素。</p>\n<h3 id=\"日期时间\"><a href=\"#日期时间\" class=\"headerlink\" title=\"日期时间\"></a>日期时间</h3><table>\n<thead>\n<tr>\n<th>日期时间类型</th>\n<th>占用空间</th>\n<th>日期格式</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>零值表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATETIME</td>\n<td>8 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1000-01-01 00:00:00</td>\n<td>9999-12-31 23:59:59</td>\n<td>0000-00-00 00:00:00</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>1970-01-01 08:00:01</td>\n<td>2038-01-19 03:14:07</td>\n<td>00000000000000</td>\n</tr>\n<tr>\n<td>DATE</td>\n<td>4 bytes</td>\n<td>YYYY-MM-DD</td>\n<td>1000-01-01</td>\n<td>9999-12-31</td>\n<td>0000-00-00</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>3 bytes</td>\n<td>HH:MM:SS</td>\n<td>-838:59:59</td>\n<td>838:59:59</td>\n<td>00:00:00</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>1 bytes</td>\n<td>YYYY</td>\n<td>1901</td>\n<td>2155</td>\n<td>0000</td>\n</tr>\n</tbody></table>\n<p>Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS的ISO 8601标准,</p>\n<p>创建字段</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-keyword\">ADD</span> create_at datetime <span class=\"hljs-keyword\">default</span> <span class=\"hljs-literal\">null</span>;</code></pre>\n\n<p>对于时间有一些数据格式化表示，通常有一些格式化参数，常用的格式化参数如下：更多的查询官方文档</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%Y</td>\n<td>年，4 位</td>\n</tr>\n<tr>\n<td>%y</td>\n<td>年，2位</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>月名</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>月，数值(00-12)</td>\n</tr>\n<tr>\n<td>%H</td>\n<td>小时 (00-23)</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>小时 (01-12)</td>\n</tr>\n<tr>\n<td>%i</td>\n<td>分钟，数值(00-59)</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>秒(00-59)</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>时间，12-小时（hh:mm:ss AM 或 PM）</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">select cname,DATE_FORMAT(create_at,&#39;%Y年%m月%d %H时%i分%s秒&#39;) as create_at from class;\nselect cname,TIME_FORMAT(create_at,&#39;%r&#39;) as create_at from class;</code></pre>\n\n<p><strong>添加数据时自动更新时间</strong></p>\n<pre><code class=\"hljs mysql\">alter table class add updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;</code></pre>\n\n<p>只要该条记录有任何一个字段被修改，则自动更新update_at字段的值</p>\n<p><strong>常用函数</strong></p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HOUR</td>\n<td>小时</td>\n</tr>\n<tr>\n<td>MINUTE</td>\n<td>分</td>\n</tr>\n<tr>\n<td>SECOND</td>\n<td>秒</td>\n</tr>\n<tr>\n<td>YEAR</td>\n<td>年</td>\n</tr>\n<tr>\n<td>MONTH</td>\n<td>月</td>\n</tr>\n<tr>\n<td>DAY</td>\n<td>日</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>获取时间</td>\n</tr>\n<tr>\n<td>WEEK</td>\n<td>周</td>\n</tr>\n<tr>\n<td>QUARTER</td>\n<td>季</td>\n</tr>\n<tr>\n<td>CURRENT_DATE（CURDATE）</td>\n<td>当前日期</td>\n</tr>\n<tr>\n<td>CURRENT_TIME</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>NOW</td>\n<td>当前时间</td>\n</tr>\n<tr>\n<td>DAYOFYEAR</td>\n<td>一年中的日数</td>\n</tr>\n<tr>\n<td>DAYOFMONTH</td>\n<td>月份中日数</td>\n</tr>\n<tr>\n<td>DAYOFWEEK</td>\n<td>星期天（1）到星期六（7）</td>\n</tr>\n<tr>\n<td>WEEKDAY</td>\n<td>星期一（0）到星期天（6）</td>\n</tr>\n<tr>\n<td>TO_DAYS</td>\n<td>从元年到现在的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>FROM_DAYS</td>\n<td>根据天数得到日期（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIME_TO_SEC</td>\n<td>时间转为秒数（忽略日期部分）</td>\n</tr>\n<tr>\n<td>SEC_TO_TIME</td>\n<td>根据秒数转为时间（忽略日期部分）</td>\n</tr>\n<tr>\n<td>UNIX_TIMESTAMP</td>\n<td>根据日期返回秒数（包括日期与时间）</td>\n</tr>\n<tr>\n<td>FROM_UNIXTIME</td>\n<td>根据秒数返回日期与时间（包括日期与时间）</td>\n</tr>\n<tr>\n<td>DATEDIFF</td>\n<td>两个日期相差的天数（忽略时间部分）</td>\n</tr>\n<tr>\n<td>TIMEDIFF</td>\n<td>计算两个时间的间隔（忽略日期部分）</td>\n</tr>\n<tr>\n<td>TIMESTAMPDIFF</td>\n<td>根据指定单位计算两个日期时间的间隔（包括日期与时间）</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>该月的最后一天</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 使用函数分割时间\nselect cname,YEAR(create_at),MONTH(create_at),DAY(create_at),HOUR(create_at),MINUTE(create_at),SECOND(create_at) from class;\n-- 当前时间\nSELECT now(),CURDATE(),CURRENT_DATE(),CURRENT_TIME(),NOW();\n-- 时间计算\nSELECT DAYOFYEAR(now()),DAYOFMONTH(now()),DAYOFWEEK(now()),WEEKDAY(now());</code></pre>\n\n<p>**时间计算 常用函数 **</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADDTIME</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>添加时间（负数为减少），只对时间有效</td>\n</tr>\n<tr>\n<td>DATE_ADD</td>\n<td>根据单位添加时间，支持单位有YEAR/MONTH/DAY/HOUR/MINUTE/SECOND/HOUR_MINUTE（负数时等于DATE_SUB)</td>\n</tr>\n<tr>\n<td>DATE_SUB</td>\n<td>DATE_ADD的反函数</td>\n</tr>\n<tr>\n<td>LAST_DAY</td>\n<td>指定月最后一天日期</td>\n</tr>\n</tbody></table>\n<p>使用示例</p>\n<pre><code class=\"hljs mysql\">-- 获取七小时之前的时间\nselect ADDTIME(now(),&#39;-7:00:00&#39;)\n-- 获取七天之后的时间，interval表示间隔\nSELECT DATE_ADD(now(),INTERVAL 7 DAY);\n-- 获取本月第一天的日期\nSELECT DATE_SUB(now(),INTERVAL DAYOFMONTH(now())-1 DAY);</code></pre>\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n"},{"title":"MySQL系列二之基础使用","date":"2018-08-15T12:37:01.000Z","index_img":["/images/mysql/008_mysql_0.jpg"],"_content":"\n这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。\n\n### 摘要和排序\n\n**order by**\n\nmysql 排序的关键字为**order by**，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。\n\n```mysql\n-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id >=2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;\n```\n\n上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。\n\n```mysql\n-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),'何','赵');\n```\n\n**count函数**\n\ncount(字段) 函数不会统计null值，使用count(*)时会将null统计进去。\n\n```mysql\n-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;\n```\n\n**min/max 函数**\n\n计算最小值或最大值\n\n```mysql\n-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;\n```\n\n**SUM/AVG**函数\n\n统计和，统计平局值\n\n```mysql\n-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;\n```\n\n**distinct 函数**\n\ndistinct用于去除结果集中的重复记录\n\n```mysql\n-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;\n```\n\n**group by**\n\n在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同**sql mode**模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！\n\n```mysql\n-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';\n```\n\n不同的sql_mode\n\n| sql_mode                   | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| ONLY_FULL_GROUP_BY         | 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 |\n| STRICT_TRANS_TABLES        | 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 |\n| NO_ZERO_IN_DATE            | 在严格模式下，不允许日期和月份为零                           |\n| NO_ZERO_DATE               | 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 |\n| ERROR_FOR_DIVISION_BY_ZERO | 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL |\n| NO_ENGINE_SUBSTITUTION     | 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 |\n| NO_AUTO_VALUE_ON_ZERO      | 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 |\n\n```mysql\n-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;\n```\n\n使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组\n\n```mysql\nSELECT class_id FROM stu GROUP BY class_id HAVING count(*)>2;\n```\n\n### 多表操作\n\n在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。\n\n先看下图，一下所有的inner可以通过该图来理解。\n\n![](/images/mysql/join.jpg)\n\n**INNER**\n\n所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用**inner join** 后面跟着ON，ON后面跟的是条件\n\n```mysql\n-- 获取用户信息\nselect * from stu as s,user_info as i where s.id = i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id = i.stu_id;\n```\n\n**OUTER JOIN**\n\n外链接包括`LEFT JOIN` 与 `RIGHT JOIN` ，可以简单理解为 `LEFT JOIN`会包含左侧所有表记录，`RIGHT JOIN` 会包含右侧表全部记录。\n\n左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。\n\n```mysql\n-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id = i.stu_id\nWHERE i.qq is null;\n```\n\n同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。\n\n```mysql\n-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id = c.id\nWHERE s.id IS NULL;\n```\n\n**SELF JOIN**\n\n`SELF JOIN`为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是**子查询操作的是两次性能会比自连接消耗性能**。\n\n```mysql\n-- 使用子查询操作\nSELECT * FROM stu WHERE class_id = \n(SELECT class_id FROM stu WHERE sname = '后盾人')\nAND stu.sname !='后盾人';\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id = s2.class_id\nWHERE s1.sname = '后盾人' AND s2.sname !='后盾人';\n```\n\n**UNION**\n\n`UNION` 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。\n\n- UNION会过滤重复的结果\n- UNION ALL 不过滤重复结果\n- 列表字段由是第一个查询的字段\n\n```mysql\n-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;\n```\n\n\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))","source":"_posts/008_MySQL系列二.md","raw":"---\ntitle: MySQL系列二之基础使用\ndate: 2018-08-15 20:37:01\nindex_img:\n- /images/mysql/008_mysql_0.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\n这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。\n\n### 摘要和排序\n\n**order by**\n\nmysql 排序的关键字为**order by**，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。\n\n```mysql\n-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id >=2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;\n```\n\n上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。\n\n```mysql\n-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),'何','赵');\n```\n\n**count函数**\n\ncount(字段) 函数不会统计null值，使用count(*)时会将null统计进去。\n\n```mysql\n-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;\n```\n\n**min/max 函数**\n\n计算最小值或最大值\n\n```mysql\n-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;\n```\n\n**SUM/AVG**函数\n\n统计和，统计平局值\n\n```mysql\n-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;\n```\n\n**distinct 函数**\n\ndistinct用于去除结果集中的重复记录\n\n```mysql\n-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;\n```\n\n**group by**\n\n在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同**sql mode**模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！\n\n```mysql\n-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode = 'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';\n```\n\n不同的sql_mode\n\n| sql_mode                   | 说明                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| ONLY_FULL_GROUP_BY         | 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 |\n| STRICT_TRANS_TABLES        | 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 |\n| NO_ZERO_IN_DATE            | 在严格模式下，不允许日期和月份为零                           |\n| NO_ZERO_DATE               | 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 |\n| ERROR_FOR_DIVISION_BY_ZERO | 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL |\n| NO_ENGINE_SUBSTITUTION     | 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 |\n| NO_AUTO_VALUE_ON_ZERO      | 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 |\n\n```mysql\n-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;\n```\n\n使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组\n\n```mysql\nSELECT class_id FROM stu GROUP BY class_id HAVING count(*)>2;\n```\n\n### 多表操作\n\n在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。\n\n先看下图，一下所有的inner可以通过该图来理解。\n\n![](/images/mysql/join.jpg)\n\n**INNER**\n\n所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用**inner join** 后面跟着ON，ON后面跟的是条件\n\n```mysql\n-- 获取用户信息\nselect * from stu as s,user_info as i where s.id = i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id = i.stu_id;\n```\n\n**OUTER JOIN**\n\n外链接包括`LEFT JOIN` 与 `RIGHT JOIN` ，可以简单理解为 `LEFT JOIN`会包含左侧所有表记录，`RIGHT JOIN` 会包含右侧表全部记录。\n\n左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。\n\n```mysql\n-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id = i.stu_id\nWHERE i.qq is null;\n```\n\n同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。\n\n```mysql\n-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id = c.id\nWHERE s.id IS NULL;\n```\n\n**SELF JOIN**\n\n`SELF JOIN`为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是**子查询操作的是两次性能会比自连接消耗性能**。\n\n```mysql\n-- 使用子查询操作\nSELECT * FROM stu WHERE class_id = \n(SELECT class_id FROM stu WHERE sname = '后盾人')\nAND stu.sname !='后盾人';\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id = s2.class_id\nWHERE s1.sname = '后盾人' AND s2.sname !='后盾人';\n```\n\n**UNION**\n\n`UNION` 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。\n\n- UNION会过滤重复的结果\n- UNION ALL 不过滤重复结果\n- 列表字段由是第一个查询的字段\n\n```mysql\n-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;\n```\n\n\n\n本文参考链接[后盾人MySQL教程]([http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html](http://houdunren.gitee.io/note/mysql/2 基本操作.html))","slug":"008_MySQL系列二","published":1,"updated":"2021-03-10T06:07:50.228Z","_id":"ckm31eeoo000a17ymai1zc3hy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。</p>\n<h3 id=\"摘要和排序\"><a href=\"#摘要和排序\" class=\"headerlink\" title=\"摘要和排序\"></a>摘要和排序</h3><p><strong>order by</strong></p>\n<p>mysql 排序的关键字为<strong>order by</strong>，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。</p>\n<pre><code class=\"hljs mysql\">-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id &gt;&#x3D;2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;</code></pre>\n\n<p>上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。</p>\n<pre><code class=\"hljs mysql\">-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),&#39;何&#39;,&#39;赵&#39;);</code></pre>\n\n<p><strong>count函数</strong></p>\n<p>count(字段) 函数不会统计null值，使用count(*)时会将null统计进去。</p>\n<pre><code class=\"hljs mysql\">-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;</code></pre>\n\n<p><strong>min/max 函数</strong></p>\n<p>计算最小值或最大值</p>\n<pre><code class=\"hljs mysql\">-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;</code></pre>\n\n<p><strong>SUM/AVG</strong>函数</p>\n<p>统计和，统计平局值</p>\n<pre><code class=\"hljs mysql\">-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;</code></pre>\n\n<p><strong>distinct 函数</strong></p>\n<p>distinct用于去除结果集中的重复记录</p>\n<pre><code class=\"hljs mysql\">-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;</code></pre>\n\n<p><strong>group by</strong></p>\n<p>在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同<strong>sql mode</strong>模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！</p>\n<pre><code class=\"hljs mysql\">-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode &#x3D; &#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre>\n\n<p>不同的sql_mode</p>\n<table>\n<thead>\n<tr>\n<th>sql_mode</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ONLY_FULL_GROUP_BY</td>\n<td>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</td>\n</tr>\n<tr>\n<td>STRICT_TRANS_TABLES</td>\n<td>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</td>\n</tr>\n<tr>\n<td>NO_ZERO_IN_DATE</td>\n<td>在严格模式下，不允许日期和月份为零</td>\n</tr>\n<tr>\n<td>NO_ZERO_DATE</td>\n<td>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</td>\n</tr>\n<tr>\n<td>ERROR_FOR_DIVISION_BY_ZERO</td>\n<td>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</td>\n</tr>\n<tr>\n<td>NO_ENGINE_SUBSTITUTION</td>\n<td>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</td>\n</tr>\n<tr>\n<td>NO_AUTO_VALUE_ON_ZERO</td>\n<td>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs mysql\">-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode&#x3D;(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;</code></pre>\n\n<p>使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组</p>\n<pre><code class=\"hljs mysql\">SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2;</code></pre>\n\n<h3 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h3><p>在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。</p>\n<p>先看下图，一下所有的inner可以通过该图来理解。</p>\n<p><img src=\"/images/mysql/join.jpg\"></p>\n<p><strong>INNER</strong></p>\n<p>所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用<strong>inner join</strong> 后面跟着ON，ON后面跟的是条件</p>\n<pre><code class=\"hljs mysql\">-- 获取用户信息\nselect * from stu as s,user_info as i where s.id &#x3D; i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id &#x3D; i.stu_id;</code></pre>\n\n<p><strong>OUTER JOIN</strong></p>\n<p>外链接包括<code>LEFT JOIN</code> 与 <code>RIGHT JOIN</code> ，可以简单理解为 <code>LEFT JOIN</code>会包含左侧所有表记录，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p>\n<p>左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。</p>\n<pre><code class=\"hljs mysql\">-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id &#x3D; i.stu_id\nWHERE i.qq is null;</code></pre>\n\n<p>同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。</p>\n<pre><code class=\"hljs mysql\">-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id &#x3D; c.id\nWHERE s.id IS NULL;</code></pre>\n\n<p><strong>SELF JOIN</strong></p>\n<p><code>SELF JOIN</code>为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是<strong>子查询操作的是两次性能会比自连接消耗性能</strong>。</p>\n<pre><code class=\"hljs mysql\">-- 使用子查询操作\nSELECT * FROM stu WHERE class_id &#x3D; \n(SELECT class_id FROM stu WHERE sname &#x3D; &#39;后盾人&#39;)\nAND stu.sname !&#x3D;&#39;后盾人&#39;;\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id &#x3D; s2.class_id\nWHERE s1.sname &#x3D; &#39;后盾人&#39; AND s2.sname !&#x3D;&#39;后盾人&#39;;</code></pre>\n\n<p><strong>UNION</strong></p>\n<p><code>UNION</code> 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。</p>\n<ul>\n<li>UNION会过滤重复的结果</li>\n<li>UNION ALL 不过滤重复结果</li>\n<li>列表字段由是第一个查询的字段</li>\n</ul>\n<pre><code class=\"hljs mysql\">-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;</code></pre>\n\n\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个是MySQL系列的第二部分还是主要以基础使用为主，本篇主要介绍排序和多表操作相关的基础知识。所有讲解都是基于MySQL 8.0以上版本。</p>\n<h3 id=\"摘要和排序\"><a href=\"#摘要和排序\" class=\"headerlink\" title=\"摘要和排序\"></a>摘要和排序</h3><p><strong>order by</strong></p>\n<p>mysql 排序的关键字为<strong>order by</strong>，默认排序是升序（ASC），降序的关键字是DESC，有一点需要留意的是，如果有SQL语句中有where子句，则order by 必须放在where 语句后面。多个条件排序则用逗号隔开。</p>\n<pre><code class=\"hljs mysql\">-- 默认学生表，字段有id,class_id,name,birthday,sex\n-- 根据姓名进行降序排列\nselect * from stu order by name desc;\n-- 必须放在where语句后面\nselect * from stu where id &gt;&#x3D;2 order by name;\n-- 多条件排序\nselect * from stu order by sex asc,birthday desc;</code></pre>\n\n<p>上面为通用的排序方式，MySQL同时也支持自定义排序通过**filed()**函数，field(value,str1,str2)，value与str1、str2比较，返回1、2，如遇到null或者不在列表中的数据则返回0，当然后面也可以增加更多的str3，str4。</p>\n<pre><code class=\"hljs mysql\">-- 根据姓自定义排序\nSELECT * FROM stu ORDER BY FIELD(left(sname,1),&#39;何&#39;,&#39;赵&#39;);</code></pre>\n\n<p><strong>count函数</strong></p>\n<p>count(字段) 函数不会统计null值，使用count(*)时会将null统计进去。</p>\n<pre><code class=\"hljs mysql\">-- 统计class_id 字段不为null 的条数\nSELECT COUNT(class_id) FROM stu;\n-- 和上面语句等价\nselect count(*) from stu where class_id is not null;</code></pre>\n\n<p><strong>min/max 函数</strong></p>\n<p>计算最小值或最大值</p>\n<pre><code class=\"hljs mysql\">-- 获取最小的学生出生年份\nSELECT year(max(birthday)) from stu;</code></pre>\n\n<p><strong>SUM/AVG</strong>函数</p>\n<p>统计和，统计平局值</p>\n<pre><code class=\"hljs mysql\">-- 统计学生的平均年龄\nSELECT ROUND(AVG(TIMESTAMPDIFF(YEAR,birthday,now())))  FROM stu ;</code></pre>\n\n<p><strong>distinct 函数</strong></p>\n<p>distinct用于去除结果集中的重复记录</p>\n<pre><code class=\"hljs mysql\">-- 获取所有班级编号\nSELECT DISTINCT class_id AS class FROM stu WHERE class_id IS NOT NULL;</code></pre>\n\n<p><strong>group by</strong></p>\n<p>在说group by 之前，我们先了解一下MySQL 的查询模式，mysql可以运行在不同<strong>sql mode</strong>模式下面，sql mode模式定义了mysql应该支持的sql语法，数据校验等！</p>\n<pre><code class=\"hljs mysql\">-- 查看全局的sql_mode\nSELECT @@GLOBAL.sql_mode;\n\n-- 设置全局的sql_mode\nSET GLOBAL sql_mode &#x3D; &#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</code></pre>\n\n<p>不同的sql_mode</p>\n<table>\n<thead>\n<tr>\n<th>sql_mode</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ONLY_FULL_GROUP_BY</td>\n<td>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中</td>\n</tr>\n<tr>\n<td>STRICT_TRANS_TABLES</td>\n<td>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</td>\n</tr>\n<tr>\n<td>NO_ZERO_IN_DATE</td>\n<td>在严格模式下，不允许日期和月份为零</td>\n</tr>\n<tr>\n<td>NO_ZERO_DATE</td>\n<td>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</td>\n</tr>\n<tr>\n<td>ERROR_FOR_DIVISION_BY_ZERO</td>\n<td>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</td>\n</tr>\n<tr>\n<td>NO_ENGINE_SUBSTITUTION</td>\n<td>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</td>\n</tr>\n<tr>\n<td>NO_AUTO_VALUE_ON_ZERO</td>\n<td>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs mysql\">-- 去除本次链接的sql_mode，ONLY_FULL_GROUP_BY\nSET sql_mode&#x3D;(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;));\n-- 根据班级分组查询最小出生日期姓名\nSELECT min(birthday),sname FROM stu GROUP BY class_id;</code></pre>\n\n<p>使用GROUP BY将数据分组后，还可以使用HAVING过滤分组，规定包括哪些分组，排除哪些分组</p>\n<pre><code class=\"hljs mysql\">SELECT class_id FROM stu GROUP BY class_id HAVING count(*)&gt;2;</code></pre>\n\n<h3 id=\"多表操作\"><a href=\"#多表操作\" class=\"headerlink\" title=\"多表操作\"></a>多表操作</h3><p>在实际操作中很多时候是一张表不能解决，我们需要从多张表中获取数据，或者通过其他表的数据删除另外一张表的数据，这个时候就需要多表操作了。表的关系可以分为一对一，一对多，多对多。</p>\n<p>先看下图，一下所有的inner可以通过该图来理解。</p>\n<p><img src=\"/images/mysql/join.jpg\"></p>\n<p><strong>INNER</strong></p>\n<p>所有多表操作都可以简单理解为，把多个表联系成一个表，最终思想成面上当成一个表对待。使用<strong>inner join</strong> 后面跟着ON，ON后面跟的是条件</p>\n<pre><code class=\"hljs mysql\">-- 获取用户信息\nselect * from stu as s,user_info as i where s.id &#x3D; i.stu_id;\n-- 使用inner 来进行多表查询，和上面的语句是等价的\nSELECT * FROM stu AS s INNER JOIN user_info as i ON s.id &#x3D; i.stu_id;</code></pre>\n\n<p><strong>OUTER JOIN</strong></p>\n<p>外链接包括<code>LEFT JOIN</code> 与 <code>RIGHT JOIN</code> ，可以简单理解为 <code>LEFT JOIN</code>会包含左侧所有表记录，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p>\n<p>左连接LEFT JOIN的含义就是求两个表的交集外加左表剩下的数据。依旧从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。</p>\n<pre><code class=\"hljs mysql\">-- 获取没有设置QQ的用户\nSELECT s.sname FROM stu AS s LEFT JOIN user_info as i\nON s.id &#x3D; i.stu_id\nWHERE i.qq is null;</code></pre>\n\n<p>同理右连接RIGHT JOIN就是求两个表的交集外加右表剩下的数据。再次从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。和left join 是相反的。</p>\n<pre><code class=\"hljs mysql\">-- 哪个班级没有学生\nSELECT sname,c.id,c.cname FROM stu AS s RIGHT JOIN class as c\nON s.class_id &#x3D; c.id\nWHERE s.id IS NULL;</code></pre>\n\n<p><strong>SELF JOIN</strong></p>\n<p><code>SELF JOIN</code>为自连接即表与自身进行关联。虽然自连接的两张表都是同一张表，但也把它按两张表对待，这样理解就会容易些。子查询操作和自连接操作都能达到相同的查询结果，但是<strong>子查询操作的是两次性能会比自连接消耗性能</strong>。</p>\n<pre><code class=\"hljs mysql\">-- 使用子查询操作\nSELECT * FROM stu WHERE class_id &#x3D; \n(SELECT class_id FROM stu WHERE sname &#x3D; &#39;后盾人&#39;)\nAND stu.sname !&#x3D;&#39;后盾人&#39;;\n-- 使用自连接操作\nSELECT s1.sname,s2.sname FROM stu as s1 \nINNER JOIN stu as s2\nON s1.class_id &#x3D; s2.class_id\nWHERE s1.sname &#x3D; &#39;后盾人&#39; AND s2.sname !&#x3D;&#39;后盾人&#39;;</code></pre>\n\n<p><strong>UNION</strong></p>\n<p><code>UNION</code> 用于连接多个查询结果，要保证每个查询返回的列数与顺序要一样。</p>\n<ul>\n<li>UNION会过滤重复的结果</li>\n<li>UNION ALL 不过滤重复结果</li>\n<li>列表字段由是第一个查询的字段</li>\n</ul>\n<pre><code class=\"hljs mysql\">-- 查询年龄最大与最小的同学\n(SELECT sname,birthday FROM stu ORDER BY birthday DESC LIMIT 1)\nUNION\n(SELECT sname,birthday from stu ORDER BY birthday ASC LIMIT 1)\nORDER BY birthday DESC;</code></pre>\n\n\n\n<p>本文参考链接[后盾人MySQL教程]([<a href=\"http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]\">http://houdunren.gitee.io/note/mysql/2%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html]</a>(<a href=\"http://houdunren.gitee.io/note/mysql/2\">http://houdunren.gitee.io/note/mysql/2</a> 基本操作.html))</p>\n"},{"title":"MySQL系列三之事务和锁","date":"2018-08-18T15:17:01.000Z","index_img":["/images/mysql/009_mysql_0.jpg"],"_content":"\n本篇来讲讲MySQL的事务以及锁\n\n### 事务\n\n事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。\n\n至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。\n\n```mysql\nshow engins;\n```\n\n#### 事务的特性\n\n事务具有以下的特性\n\n- 原子性\n\n  事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。\n\n- 一致性\n\n  数据库总是从一个一致性的状态转换到另一个一致性的状态。\n\n- 隔离性\n\n  一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。\n\n- 持久性\n\n  一旦事务提交，其所做的修改便会永久保存在数据库中。\n\nMysql的提交默认是自动提交，即发送一条sql执行一条。\n\n#### 事务的提交\n\n执行 `START TRANSACTION` 或 `BEGIN` 语句后，表示要开启一项事务处理。\n\n- COMMIT 提交事务\n- ROLLBACK 回滚事务\n\n```mysql\nSTART TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,'张帝','女');\nCOMMIT; -- rollback 回滚事务\n```\n\n#### 事务隔离\n\n在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？\n\n当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：\n\n1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。\n3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n> 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\n\nMySQL拥有不同的事务隔离级别\n\n| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 说明                                                         |\n| ---------------------------- | ---- | ---------- | ---- | ------------------------------------------------------------ |\n| 读未提交（read-uncommitted） | 是   | 是         | 是   | 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 |\n| 不可重复读（read-committed） | 否   | 是         | 是   | 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 |\n| 可重复读（repeatable-read）  | 否   | 否         | 是   | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 |\n| 串行化（serializable）       | 否   | 否         | 否   | 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。 |\n\n#### 查询/设置MySQL的事务隔离级别\n\nInoDB默认的事务隔离级别是repeatable-read\n\n```mysql\n-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n### 锁机制\n\n因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种\n\n- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。\n\n- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n`InnoDB` 是主流储存引擎并支持行级锁的，有更高的并发处理性能。\n\n- 行锁开销大，锁表慢\n- 行锁高并发下可并行处理，性能更高\n- 行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁\n- 在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放\n\n#### 行锁\n\n- 使用**索引字段**为筛选条件，来复现行锁。\n\n  事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。\n\n  ```mysql\n  -- 事务A\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE id=1;\n  ```\n\n  事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。\n\n  ```mysql\n  -- 事务B 阻塞\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=1;\n  commit\n  -- 事务B id=2 操作成功\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=2;\n  commit\n  ```\n\n  当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行\n\n  ```mysql\n  -- 事务A\n  commit\n  ```\n\n- 使用**非索引字段**为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。\n\n  事务A执行以下代码，因为`sname`字段没有添加索引，造成锁定整个表\n\n  ```mysql\n  -- 事务A 没有commit，同时sname 字段没有添加索引\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE sname ='haha1';\n  ```\n\n  现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态\n\n  ```mysql\n  -- 事务B 阻塞，因为stu 表锁\n  BEGIN;\n  update stu set sname = '小明' where id=1\n  commit\n  ```\n\n- 简单查看MySQL行锁的争用情况\n\n  过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\n\n  ```mysql\n  show status like 'innodb_row_lock%';\n  ```\n\n  如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。\n\n#### 区间锁（页面锁）\n\n- 使用索引字段作为筛选条件\n\n  事务A筛选时使用了范围区间\n\n  ```mysql\n  -- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\n  BEGIN;\n  UPDATE goods SET num=200 WHERE id>1 AND id<4; \n  ```\n\n  事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录\n\n  ```mysql\n  -- 事务B id=2 无法操作，区间锁\n  BEGIN;\n  update goods set num =1 where id=2;\n  commit;\n  -- 事务B id =4 正常操作\n  BEGIN;\n  update goods set num =1 where id=4;\n  commit;\n  ```\n\n#### 表锁\n\nMySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。\n\n##### 读锁\n\n为表设置读锁后，当前会话和其他会话都不可以修改数据。\n\n会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表\n\n```mysql\nLOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num=300 WHERE id=1;\nSELECT * FROM stu;\n```\n\n因为会话A对表`goods`设置了读锁，所以会话B也不能修改\n\n```mysql\nupdate goods set num=200 where id=1;-- 阻塞住\n```\n\n会话A解锁表后，其他会话又可以继续操作表了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 写锁\n\n为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。\n\n会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表\n\n```mysql\nLOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES('后盾人教程',300);\n```\n\n会话B读取/写入/写入表数据都将阻塞\n\n```mysql\nselect * from goods;-- 阻塞\n```\n\n会话A解锁表数据后，其他会话都可以正常操作了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 悲观锁\n\n悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。\n\n事务A执行悲观锁操作后，其他事务执行将被阻塞\n\n```mysql\n-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\nUPDATE goods SET num=num-2 WHERE id=1; \n```\n\n事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务\n\n```mysql\n-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\ncommit；\n```\n\n##### 乐观锁\n\n在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。\n\n事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务B同时查询，也获取了版本号为0的记录\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务A更改库存，并增加版本号\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n[超详细的锁介绍](https://blog.csdn.net/Jack__Frost/article/details/73347688)\n\n在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。\n\n1. 优化sql语句\n2. 降低MySQL数据的事务隔离级别\n\n\n\n参考链接：https://www.cnblogs.com/qq1148932219/p/11694064.html","source":"_posts/009_MySQL系列三.md","raw":"---\ntitle: MySQL系列三之事务和锁\ndate: 2018-08-18 23:17:01\nindex_img:\n- /images/mysql/009_mysql_0.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\n本篇来讲讲MySQL的事务以及锁\n\n### 事务\n\n事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。\n\n至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。\n\n```mysql\nshow engins;\n```\n\n#### 事务的特性\n\n事务具有以下的特性\n\n- 原子性\n\n  事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。\n\n- 一致性\n\n  数据库总是从一个一致性的状态转换到另一个一致性的状态。\n\n- 隔离性\n\n  一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。\n\n- 持久性\n\n  一旦事务提交，其所做的修改便会永久保存在数据库中。\n\nMysql的提交默认是自动提交，即发送一条sql执行一条。\n\n#### 事务的提交\n\n执行 `START TRANSACTION` 或 `BEGIN` 语句后，表示要开启一项事务处理。\n\n- COMMIT 提交事务\n- ROLLBACK 回滚事务\n\n```mysql\nSTART TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,'张帝','女');\nCOMMIT; -- rollback 回滚事务\n```\n\n#### 事务隔离\n\n在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？\n\n当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：\n\n1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。\n3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\n\n> 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\n\nMySQL拥有不同的事务隔离级别\n\n| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 | 说明                                                         |\n| ---------------------------- | ---- | ---------- | ---- | ------------------------------------------------------------ |\n| 读未提交（read-uncommitted） | 是   | 是         | 是   | 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 |\n| 不可重复读（read-committed） | 否   | 是         | 是   | 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 |\n| 可重复读（repeatable-read）  | 否   | 否         | 是   | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 |\n| 串行化（serializable）       | 否   | 否         | 否   | 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。 |\n\n#### 查询/设置MySQL的事务隔离级别\n\nInoDB默认的事务隔离级别是repeatable-read\n\n```mysql\n-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;\n```\n\n### 锁机制\n\n因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种\n\n- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。\n\n- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。\n\n- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n`InnoDB` 是主流储存引擎并支持行级锁的，有更高的并发处理性能。\n\n- 行锁开销大，锁表慢\n- 行锁高并发下可并行处理，性能更高\n- 行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁\n- 在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放\n\n#### 行锁\n\n- 使用**索引字段**为筛选条件，来复现行锁。\n\n  事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。\n\n  ```mysql\n  -- 事务A\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE id=1;\n  ```\n\n  事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。\n\n  ```mysql\n  -- 事务B 阻塞\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=1;\n  commit\n  -- 事务B id=2 操作成功\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms2' WHERE id=2;\n  commit\n  ```\n\n  当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行\n\n  ```mysql\n  -- 事务A\n  commit\n  ```\n\n- 使用**非索引字段**为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。\n\n  事务A执行以下代码，因为`sname`字段没有添加索引，造成锁定整个表\n\n  ```mysql\n  -- 事务A 没有commit，同时sname 字段没有添加索引\n  BEGIN;\n  UPDATE stu SET sname = 'hdcms' WHERE sname ='haha1';\n  ```\n\n  现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态\n\n  ```mysql\n  -- 事务B 阻塞，因为stu 表锁\n  BEGIN;\n  update stu set sname = '小明' where id=1\n  commit\n  ```\n\n- 简单查看MySQL行锁的争用情况\n\n  过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况\n\n  ```mysql\n  show status like 'innodb_row_lock%';\n  ```\n\n  如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。\n\n#### 区间锁（页面锁）\n\n- 使用索引字段作为筛选条件\n\n  事务A筛选时使用了范围区间\n\n  ```mysql\n  -- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\n  BEGIN;\n  UPDATE goods SET num=200 WHERE id>1 AND id<4; \n  ```\n\n  事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录\n\n  ```mysql\n  -- 事务B id=2 无法操作，区间锁\n  BEGIN;\n  update goods set num =1 where id=2;\n  commit;\n  -- 事务B id =4 正常操作\n  BEGIN;\n  update goods set num =1 where id=4;\n  commit;\n  ```\n\n#### 表锁\n\nMySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。\n\n##### 读锁\n\n为表设置读锁后，当前会话和其他会话都不可以修改数据。\n\n会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表\n\n```mysql\nLOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num=300 WHERE id=1;\nSELECT * FROM stu;\n```\n\n因为会话A对表`goods`设置了读锁，所以会话B也不能修改\n\n```mysql\nupdate goods set num=200 where id=1;-- 阻塞住\n```\n\n会话A解锁表后，其他会话又可以继续操作表了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 写锁\n\n为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。\n\n会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表\n\n```mysql\nLOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES('后盾人教程',300);\n```\n\n会话B读取/写入/写入表数据都将阻塞\n\n```mysql\nselect * from goods;-- 阻塞\n```\n\n会话A解锁表数据后，其他会话都可以正常操作了\n\n```mysql\nUNLOCK TABLES;\n```\n\n##### 悲观锁\n\n悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。\n\n事务A执行悲观锁操作后，其他事务执行将被阻塞\n\n```mysql\n-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\nUPDATE goods SET num=num-2 WHERE id=1; \n```\n\n事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务\n\n```mysql\n-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id=1 FOR UPDATE;\ncommit；\n```\n\n##### 乐观锁\n\n在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。\n\n事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务B同时查询，也获取了版本号为0的记录\n\n```mysql\nBEGIN;\nSELECT * FROM goods WHERE id = 1;\n```\n\n事务A更改库存，并增加版本号\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。\n\n```mysql\nUPDATE goods SET num=num-10,VERSION =VERSION+1 WHERE VERSION=0;\n```\n\n[超详细的锁介绍](https://blog.csdn.net/Jack__Frost/article/details/73347688)\n\n在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。\n\n1. 优化sql语句\n2. 降低MySQL数据的事务隔离级别\n\n\n\n参考链接：https://www.cnblogs.com/qq1148932219/p/11694064.html","slug":"009_MySQL系列三","published":1,"updated":"2021-03-10T06:13:09.209Z","_id":"ckm31emoh000d17ymbvjw9rlh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本篇来讲讲MySQL的事务以及锁</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。</p>\n<p>至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。</p>\n<pre><code class=\"hljs mysql\">show engins;</code></pre>\n\n<h4 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h4><p>事务具有以下的特性</p>\n<ul>\n<li><p>原子性</p>\n<p>事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。</p>\n</li>\n<li><p>一致性</p>\n<p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>\n</li>\n<li><p>隔离性</p>\n<p>一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。</p>\n</li>\n<li><p>持久性</p>\n<p>一旦事务提交，其所做的修改便会永久保存在数据库中。</p>\n</li>\n</ul>\n<p>Mysql的提交默认是自动提交，即发送一条sql执行一条。</p>\n<h4 id=\"事务的提交\"><a href=\"#事务的提交\" class=\"headerlink\" title=\"事务的提交\"></a>事务的提交</h4><p>执行 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句后，表示要开启一项事务处理。</p>\n<ul>\n<li>COMMIT 提交事务</li>\n<li>ROLLBACK 回滚事务</li>\n</ul>\n<pre><code class=\"hljs mysql\">START TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,&#39;张帝&#39;,&#39;女&#39;);\nCOMMIT; -- rollback 回滚事务</code></pre>\n\n<h4 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h4><p>在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？</p>\n<p>当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：</p>\n<ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<blockquote>\n<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n</blockquote>\n<p>MySQL拥有不同的事务隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读未提交（read-uncommitted）</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td>\n</tr>\n</tbody></table>\n<h4 id=\"查询-设置MySQL的事务隔离级别\"><a href=\"#查询-设置MySQL的事务隔离级别\" class=\"headerlink\" title=\"查询/设置MySQL的事务隔离级别\"></a>查询/设置MySQL的事务隔离级别</h4><p>InoDB默认的事务隔离级别是repeatable-read</p>\n<pre><code class=\"hljs mysql\">-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre>\n\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h3><p>因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种</p>\n<ul>\n<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p>\n</li>\n<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n</li>\n<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n</li>\n</ul>\n<p><code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能。</p>\n<ul>\n<li>行锁开销大，锁表慢</li>\n<li>行锁高并发下可并行处理，性能更高</li>\n<li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li>\n<li>在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放</li>\n</ul>\n<h4 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h4><ul>\n<li><p>使用<strong>索引字段</strong>为筛选条件，来复现行锁。</p>\n<p>事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。</p>\n<pre><code class=\"hljs mysql\">-- 事务A\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE id&#x3D;1;</code></pre>\n\n<p>事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;1;\ncommit\n-- 事务B id&#x3D;2 操作成功\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;2;\ncommit</code></pre>\n\n<p>当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行</p>\n<pre><code class=\"hljs mysql\">-- 事务A\ncommit</code></pre>\n</li>\n<li><p>使用<strong>非索引字段</strong>为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。</p>\n<p>事务A执行以下代码，因为<code>sname</code>字段没有添加索引，造成锁定整个表</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，同时sname 字段没有添加索引\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE sname &#x3D;&#39;haha1&#39;;</code></pre>\n\n<p>现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞，因为stu 表锁\nBEGIN;\nupdate stu set sname &#x3D; &#39;小明&#39; where id&#x3D;1\ncommit</code></pre>\n</li>\n<li><p>简单查看MySQL行锁的争用情况</p>\n<p>过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>\n<pre><code class=\"hljs mysql\">show status like &#39;innodb_row_lock%&#39;;</code></pre>\n\n<p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>\n</li>\n</ul>\n<h4 id=\"区间锁（页面锁）\"><a href=\"#区间锁（页面锁）\" class=\"headerlink\" title=\"区间锁（页面锁）\"></a>区间锁（页面锁）</h4><ul>\n<li><p>使用索引字段作为筛选条件</p>\n<p>事务A筛选时使用了范围区间</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\nBEGIN;\nUPDATE goods SET num&#x3D;200 WHERE id&gt;1 AND id&lt;4;</code></pre>\n\n<p>事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录</p>\n<pre><code class=\"hljs mysql\">-- 事务B id&#x3D;2 无法操作，区间锁\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;2;\ncommit;\n-- 事务B id &#x3D;4 正常操作\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;4;\ncommit;</code></pre>\n\n</li>\n</ul>\n<h4 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h4><p>MySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。</p>\n<h5 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h5><p>为表设置读锁后，当前会话和其他会话都不可以修改数据。</p>\n<p>会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num&#x3D;300 WHERE id&#x3D;1;\nSELECT * FROM stu;</code></pre>\n\n<p>因为会话A对表<code>goods</code>设置了读锁，所以会话B也不能修改</p>\n<pre><code class=\"hljs mysql\">update goods set num&#x3D;200 where id&#x3D;1;-- 阻塞住</code></pre>\n\n<p>会话A解锁表后，其他会话又可以继续操作表了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h5><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。</p>\n<p>会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES(&#39;后盾人教程&#39;,300);</code></pre>\n\n<p>会话B读取/写入/写入表数据都将阻塞</p>\n<pre><code class=\"hljs mysql\">select * from goods;-- 阻塞</code></pre>\n\n<p>会话A解锁表数据后，其他会话都可以正常操作了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h5><p>悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。</p>\n<p>事务A执行悲观锁操作后，其他事务执行将被阻塞</p>\n<pre><code class=\"hljs mysql\">-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\nUPDATE goods SET num&#x3D;num-2 WHERE id&#x3D;1;</code></pre>\n\n<p>事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务</p>\n<pre><code class=\"hljs mysql\">-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\ncommit；</code></pre>\n\n<h5 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h5><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p>\n<p>事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务B同时查询，也获取了版本号为0的记录</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务A更改库存，并增加版本号</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p>事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/Jack__Frost/article/details/73347688\">超详细的锁介绍</a></p>\n<p>在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。</p>\n<ol>\n<li>优化sql语句</li>\n<li>降低MySQL数据的事务隔离级别</li>\n</ol>\n<p>参考链接：<a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇来讲讲MySQL的事务以及锁</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>事务是保证多个SQL操作的一致性，如果有一条SQL语句操作失败，则全部的SQL语句都失效。简单的说事务就是一组原子性的SQL语句。可以将这组语句理解成一个工作单元，要么全部执行要么都不执行。</p>\n<p>至于支不支持事务是和MySQL的存储引擎相关的，我们这边使用的是MySQL8.0的版本，使用的默认引擎是InnoDB（MySQL5.5以后默认使用InnoDB存储引擎），而InnoDB是支持事务的。如果是其他版本的MySQL可以通过以下SQL语句查询。</p>\n<pre><code class=\"hljs mysql\">show engins;</code></pre>\n\n<h4 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h4><p>事务具有以下的特性</p>\n<ul>\n<li><p>原子性</p>\n<p>事务中的所有操作要么全部提交成功，要么全部失败回滚。比如从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来，这两步必须同时完成，要么就不完成。</p>\n</li>\n<li><p>一致性</p>\n<p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>\n</li>\n<li><p>隔离性</p>\n<p>一个事务所做的修改在提交之前对其它事务是不可见的。两个以上的事务不会出现交错执行的状态，因为这样可能会导致数据不一致。</p>\n</li>\n<li><p>持久性</p>\n<p>一旦事务提交，其所做的修改便会永久保存在数据库中。</p>\n</li>\n</ul>\n<p>Mysql的提交默认是自动提交，即发送一条sql执行一条。</p>\n<h4 id=\"事务的提交\"><a href=\"#事务的提交\" class=\"headerlink\" title=\"事务的提交\"></a>事务的提交</h4><p>执行 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句后，表示要开启一项事务处理。</p>\n<ul>\n<li>COMMIT 提交事务</li>\n<li>ROLLBACK 回滚事务</li>\n</ul>\n<pre><code class=\"hljs mysql\">START TRANSACTION;-- 或者begin\nINSERT INTO stu (class_id,sname,sex)VALUES(2,&#39;张帝&#39;,&#39;女&#39;);\nCOMMIT; -- rollback 回滚事务</code></pre>\n\n<h4 id=\"事务隔离\"><a href=\"#事务隔离\" class=\"headerlink\" title=\"事务隔离\"></a>事务隔离</h4><p>在上面我们说到事务具有隔离性，那么为什么事务需要隔离性呢？</p>\n<p>当高并发访问会遇到多个事务的隔离问题，可能会出现以下问题：</p>\n<ol>\n<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>\n<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>\n<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>\n</ol>\n<blockquote>\n<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>\n</blockquote>\n<p>MySQL拥有不同的事务隔离级别</p>\n<table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读未提交（read-uncommitted）</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td>最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别。</td>\n</tr>\n</tbody></table>\n<h4 id=\"查询-设置MySQL的事务隔离级别\"><a href=\"#查询-设置MySQL的事务隔离级别\" class=\"headerlink\" title=\"查询/设置MySQL的事务隔离级别\"></a>查询/设置MySQL的事务隔离级别</h4><p>InoDB默认的事务隔离级别是repeatable-read</p>\n<pre><code class=\"hljs mysql\">-- 查询本次会话的事务隔离级别\nSELECT @@SESSION.transaction_isolation\n-- 查询全局的事务隔离级别\nSELECT @@GLOBAL.transaction_isolation\n-- 设置本次会话的事务隔离级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- 设置全局的事务隔离级别\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre>\n\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a>锁机制</h3><p>因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。但是为了防止客户端同时修改数据，所以有了锁的机制。锁的等级主要分为以下几种</p>\n<ul>\n<li><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高 ，并发度最低。</p>\n</li>\n<li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>\n</li>\n<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n</li>\n</ul>\n<p><code>InnoDB</code> 是主流储存引擎并支持行级锁的，有更高的并发处理性能。</p>\n<ul>\n<li>行锁开销大，锁表慢</li>\n<li>行锁高并发下可并行处理，性能更高</li>\n<li>行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁</li>\n<li>在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放</li>\n</ul>\n<h4 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h4><ul>\n<li><p>使用<strong>索引字段</strong>为筛选条件，来复现行锁。</p>\n<p>事务A执行以下sql 但不提交，此时已经将id=1这条记录给加锁了。</p>\n<pre><code class=\"hljs mysql\">-- 事务A\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE id&#x3D;1;</code></pre>\n\n<p>事务B也执行对id=1进行相同的更新操作，执行过程出现阻塞。如果事务执行对id=2，则可以操作成功，不会出现阻塞现象。</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;1;\ncommit\n-- 事务B id&#x3D;2 操作成功\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms2&#39; WHERE id&#x3D;2;\ncommit</code></pre>\n\n<p>当事务A提交之后，解锁id=1这行记录之后，事务B的操作才会继续执行</p>\n<pre><code class=\"hljs mysql\">-- 事务A\ncommit</code></pre>\n</li>\n<li><p>使用<strong>非索引字段</strong>为筛选条件，则出现表锁。如果出现表锁，则该张表的update操作将无法操作。</p>\n<p>事务A执行以下代码，因为<code>sname</code>字段没有添加索引，造成锁定整个表</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，同时sname 字段没有添加索引\nBEGIN;\nUPDATE stu SET sname &#x3D; &#39;hdcms&#39; WHERE sname &#x3D;&#39;haha1&#39;;</code></pre>\n\n<p>现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态</p>\n<pre><code class=\"hljs mysql\">-- 事务B 阻塞，因为stu 表锁\nBEGIN;\nupdate stu set sname &#x3D; &#39;小明&#39; where id&#x3D;1\ncommit</code></pre>\n</li>\n<li><p>简单查看MySQL行锁的争用情况</p>\n<p>过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>\n<pre><code class=\"hljs mysql\">show status like &#39;innodb_row_lock%&#39;;</code></pre>\n\n<p>如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>\n</li>\n</ul>\n<h4 id=\"区间锁（页面锁）\"><a href=\"#区间锁（页面锁）\" class=\"headerlink\" title=\"区间锁（页面锁）\"></a>区间锁（页面锁）</h4><ul>\n<li><p>使用索引字段作为筛选条件</p>\n<p>事务A筛选时使用了范围区间</p>\n<pre><code class=\"hljs mysql\">-- 事务A 没有commit，造成范围锁id为2 和 3的行被锁住\nBEGIN;\nUPDATE goods SET num&#x3D;200 WHERE id&gt;1 AND id&lt;4;</code></pre>\n\n<p>事务B将不能修改表中的ID等于2的记录，但可以修改大于等于4 或者等于1的记录</p>\n<pre><code class=\"hljs mysql\">-- 事务B id&#x3D;2 无法操作，区间锁\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;2;\ncommit;\n-- 事务B id &#x3D;4 正常操作\nBEGIN;\nupdate goods set num &#x3D;1 where id&#x3D;4;\ncommit;</code></pre>\n\n</li>\n</ul>\n<h4 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h4><p>MySQL表级锁定的常见类型主要分为两种，一种是读锁，一种是写锁。</p>\n<h5 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h5><p>为表设置读锁后，当前会话和其他会话都不可以修改数据。</p>\n<p>会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods READ;-- 加读锁\nUPDATE goods SET num&#x3D;300 WHERE id&#x3D;1;\nSELECT * FROM stu;</code></pre>\n\n<p>因为会话A对表<code>goods</code>设置了读锁，所以会话B也不能修改</p>\n<pre><code class=\"hljs mysql\">update goods set num&#x3D;200 where id&#x3D;1;-- 阻塞住</code></pre>\n\n<p>会话A解锁表后，其他会话又可以继续操作表了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h5><p>为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。</p>\n<p>会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表</p>\n<pre><code class=\"hljs mysql\">LOCK TABLE goods WRITE; -- 加写锁\nINSERT INTO goods (name,num )VALUES(&#39;后盾人教程&#39;,300);</code></pre>\n\n<p>会话B读取/写入/写入表数据都将阻塞</p>\n<pre><code class=\"hljs mysql\">select * from goods;-- 阻塞</code></pre>\n\n<p>会话A解锁表数据后，其他会话都可以正常操作了</p>\n<pre><code class=\"hljs mysql\">UNLOCK TABLES;</code></pre>\n\n<h5 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h5><p>悲观锁指对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，可以很好地解决并发事务的更新丢失问题。</p>\n<p>事务A执行悲观锁操作后，其他事务执行将被阻塞</p>\n<pre><code class=\"hljs mysql\">-- 没有commit, for update 表示执行悲观锁\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\nUPDATE goods SET num&#x3D;num-2 WHERE id&#x3D;1;</code></pre>\n\n<p>事务B执行以下代码将不能查询库存，必须等事务A提交或回滚事务</p>\n<pre><code class=\"hljs mysql\">-- 被阻塞，只要等事务A commit之后才会执行B事务\nBEGIN;\nSELECT * FROM goods WHERE id&#x3D;1 FOR UPDATE;\ncommit；</code></pre>\n\n<h5 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h5><p>在每次去拿数据的时候认为别人不会修改，不对数据上锁，但是在提交更新的时候会判断在此期间数据是否被更改，如果被更改则提交失败。</p>\n<p>事务A查询商品库存，获取了商品记录，记录中有VERSION字段用于记录版本号（目前为0）</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务B同时查询，也获取了版本号为0的记录</p>\n<pre><code class=\"hljs mysql\">BEGIN;\nSELECT * FROM goods WHERE id &#x3D; 1;</code></pre>\n\n<p>事务A更改库存，并增加版本号</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p>事务B更改数据，但使用的是事务B查询到的0号版本，因为事务A已经提交版本号为1，造成事务B修改失败，保证了数据的完整性。</p>\n<pre><code class=\"hljs mysql\">UPDATE goods SET num&#x3D;num-10,VERSION &#x3D;VERSION+1 WHERE VERSION&#x3D;0;</code></pre>\n\n<p><a href=\"https://blog.csdn.net/Jack__Frost/article/details/73347688\">超详细的锁介绍</a></p>\n<p>在对数据进行insert\\update\\delete的时候容易出现Deadlock found when trying to get lock 错误，目前有两个方式进行调整优化。</p>\n<ol>\n<li>优化sql语句</li>\n<li>降低MySQL数据的事务隔离级别</li>\n</ol>\n<p>参考链接：<a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n"},{"title":"MySQL系列四之执行流程及架构","date":"2018-08-22T14:37:01.000Z","index_img":["/images/mysql/010_mysql_0.jpg"],"_content":"\n前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。\n\n### 执行流程\n\n我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？\n\n1. MySQL客户端通过协议将SQL语句发送给MySQL服务器。\n\n2. MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。\n\n3. MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）\n\n4. MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。\n\n5. 将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。\n\n\n知道执行流程之后，我们看下MySQL的架构图。\n\n![](/images/mysql/MySQL_Architecture.jpg)\n\nmysql 逻辑架构主要分为三层\n\n1. 应用层\n   - 这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。\n2. 核心服务层\n   - 该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等\n3. 存储引擎层\n   - 可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。\n\n### 架构服务\n\n#### 应用层的服务\n\n##### 链接处理\n\nMySQL首先是一个网络程序，其在TCP之上定义了自己的[应用层协议](https://dev.mysql.com/doc/internals/en/client-server-protocol.html)。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。\n\n##### 身份验证\n\n每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。\n\n##### 安全\n\n客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。\n\n#### 核心服务层的服务\n\n##### MySQL服务和实用程序\n\nMySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。\n\n- 备份和恢复\n- 安全\n- 复制\n- 簇\n- 分区\n- 工作台\n\n##### SQL接口\n\nSQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。\n\n##### 解析器\n\nMySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：\n\n- 在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。\n- 语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 \n\n##### 优化器\n\n语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，**与具体的存储引擎实现无关**。\n\n##### 缓存\n\nMySQL缓存（查询缓存）存储**SELECT** 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。\n\n#### 存储引擎层的服务\n\n存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。\n\n```mysql\n-- 查看MySQL支持的存储引擎\nSHOW ENGINES;\n```\n\n**MySQL5.5以后默认使用InnoDB存储引擎**，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。\n\n##### InnoDB\n\nInnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：\n\n1. 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。\n2. 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。\n3. 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。\n4. 外键约束。MySQL支持外键的存储引擎只有InnoDB。\n5. 支持自动增加列AUTO_INCREMENT属性。\n\n##### MyISAM\n\n在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。\n\nMyISAM存储引擎特别适合在以下几种情况下使用：\n\n1. 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。\n2. 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。\n\n\n\n[更多引擎介绍](https://zhuanlan.zhihu.com/p/53619907)\n\n本文参考：https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\n\n​\t\t\t\t\thttps://zhuanlan.zhihu.com/p/53619907\n\n​\t\t\t\t\thttps://www.cnblogs.com/qq1148932219/p/11694064.html\n\n   ","source":"_posts/010_MySQL系列四.md","raw":"---\ntitle: MySQL系列四之执行流程及架构\ndate: 2018-08-22 22:37:01\nindex_img:\n- /images/mysql/010_mysql_0.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\n前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。\n\n### 执行流程\n\n我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？\n\n1. MySQL客户端通过协议将SQL语句发送给MySQL服务器。\n\n2. MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。\n\n3. MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）\n\n4. MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。\n\n5. 将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。\n\n\n知道执行流程之后，我们看下MySQL的架构图。\n\n![](/images/mysql/MySQL_Architecture.jpg)\n\nmysql 逻辑架构主要分为三层\n\n1. 应用层\n   - 这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。\n2. 核心服务层\n   - 该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等\n3. 存储引擎层\n   - 可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。\n\n### 架构服务\n\n#### 应用层的服务\n\n##### 链接处理\n\nMySQL首先是一个网络程序，其在TCP之上定义了自己的[应用层协议](https://dev.mysql.com/doc/internals/en/client-server-protocol.html)。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。\n\n##### 身份验证\n\n每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。\n\n##### 安全\n\n客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。\n\n#### 核心服务层的服务\n\n##### MySQL服务和实用程序\n\nMySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。\n\n- 备份和恢复\n- 安全\n- 复制\n- 簇\n- 分区\n- 工作台\n\n##### SQL接口\n\nSQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。\n\n##### 解析器\n\nMySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：\n\n- 在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。\n- 语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 \n\n##### 优化器\n\n语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，**与具体的存储引擎实现无关**。\n\n##### 缓存\n\nMySQL缓存（查询缓存）存储**SELECT** 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。\n\n#### 存储引擎层的服务\n\n存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。\n\n```mysql\n-- 查看MySQL支持的存储引擎\nSHOW ENGINES;\n```\n\n**MySQL5.5以后默认使用InnoDB存储引擎**，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。\n\n##### InnoDB\n\nInnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：\n\n1. 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。\n2. 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。\n3. 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。\n4. 外键约束。MySQL支持外键的存储引擎只有InnoDB。\n5. 支持自动增加列AUTO_INCREMENT属性。\n\n##### MyISAM\n\n在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。\n\nMyISAM存储引擎特别适合在以下几种情况下使用：\n\n1. 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。\n2. 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。\n\n\n\n[更多引擎介绍](https://zhuanlan.zhihu.com/p/53619907)\n\n本文参考：https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\n\n​\t\t\t\t\thttps://zhuanlan.zhihu.com/p/53619907\n\n​\t\t\t\t\thttps://www.cnblogs.com/qq1148932219/p/11694064.html\n\n   ","slug":"010_MySQL系列四","published":1,"updated":"2021-03-10T06:13:18.824Z","_id":"ckm31ewrt000g17ymb70ahjxx","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？</p>\n<ol>\n<li><p>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</p>\n</li>\n<li><p>MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p>\n</li>\n<li><p>MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）</p>\n</li>\n<li><p>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</p>\n</li>\n<li><p>将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。</p>\n</li>\n</ol>\n<p>知道执行流程之后，我们看下MySQL的架构图。</p>\n<p><img src=\"/images/mysql/MySQL_Architecture.jpg\"></p>\n<p>mysql 逻辑架构主要分为三层</p>\n<ol>\n<li>应用层<ul>\n<li>这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。</li>\n</ul>\n</li>\n<li>核心服务层<ul>\n<li>该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等</li>\n</ul>\n</li>\n<li>存储引擎层<ul>\n<li>可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"架构服务\"><a href=\"#架构服务\" class=\"headerlink\" title=\"架构服务\"></a>架构服务</h3><h4 id=\"应用层的服务\"><a href=\"#应用层的服务\" class=\"headerlink\" title=\"应用层的服务\"></a>应用层的服务</h4><h5 id=\"链接处理\"><a href=\"#链接处理\" class=\"headerlink\" title=\"链接处理\"></a>链接处理</h5><p>MySQL首先是一个网络程序，其在TCP之上定义了自己的<a href=\"https://dev.mysql.com/doc/internals/en/client-server-protocol.html\">应用层协议</a>。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。</p>\n<h5 id=\"身份验证\"><a href=\"#身份验证\" class=\"headerlink\" title=\"身份验证\"></a>身份验证</h5><p>每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。</p>\n<h5 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h5><p>客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。</p>\n<h4 id=\"核心服务层的服务\"><a href=\"#核心服务层的服务\" class=\"headerlink\" title=\"核心服务层的服务\"></a>核心服务层的服务</h4><h5 id=\"MySQL服务和实用程序\"><a href=\"#MySQL服务和实用程序\" class=\"headerlink\" title=\"MySQL服务和实用程序\"></a>MySQL服务和实用程序</h5><p>MySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。</p>\n<ul>\n<li>备份和恢复</li>\n<li>安全</li>\n<li>复制</li>\n<li>簇</li>\n<li>分区</li>\n<li>工作台</li>\n</ul>\n<h5 id=\"SQL接口\"><a href=\"#SQL接口\" class=\"headerlink\" title=\"SQL接口\"></a>SQL接口</h5><p>SQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</p>\n<h5 id=\"解析器\"><a href=\"#解析器\" class=\"headerlink\" title=\"解析器\"></a>解析器</h5><p>MySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：</p>\n<ul>\n<li>在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。</li>\n<li>语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 </li>\n</ul>\n<h5 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h5><p>语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，<strong>与具体的存储引擎实现无关</strong>。</p>\n<h5 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h5><p>MySQL缓存（查询缓存）存储<strong>SELECT</strong> 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。</p>\n<h4 id=\"存储引擎层的服务\"><a href=\"#存储引擎层的服务\" class=\"headerlink\" title=\"存储引擎层的服务\"></a>存储引擎层的服务</h4><p>存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。</p>\n<pre><code class=\"hljs mysql\">-- 查看MySQL支持的存储引擎\nSHOW ENGINES;</code></pre>\n\n<p><strong>MySQL5.5以后默认使用InnoDB存储引擎</strong>，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。</p>\n<h5 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h5><p>InnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>\n<ol>\n<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>\n<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>\n<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>\n<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>\n<li>支持自动增加列AUTO_INCREMENT属性。</li>\n</ol>\n<h5 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h5><p>在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。</p>\n<p>MyISAM存储引擎特别适合在以下几种情况下使用：</p>\n<ol>\n<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>\n<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/53619907\">更多引擎介绍</a></p>\n<p>本文参考：<a href=\"https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\">https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html</a></p>\n<p>​                    <a href=\"https://zhuanlan.zhihu.com/p/53619907\">https://zhuanlan.zhihu.com/p/53619907</a></p>\n<p>​                    <a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面几篇主要讲了MySQL一些实际上的使用，但是对整个mysql架构上的一些还是不够了解，熟悉mysql的架构还是对于我们很有帮助的。MySQL体系结构描述了MySQL系统的不同组件之间如何相互联系。MySQL体系结构基本上是一个客户端-服务器系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。</p>\n<h3 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h3><p>我们执行一条sql语句的时候，MySQL的执行流程是怎么样的呢？</p>\n<ol>\n<li><p>MySQL客户端通过协议将SQL语句发送给MySQL服务器。</p>\n</li>\n<li><p>MySQL服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p>\n</li>\n<li><p>MySQL服务器服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。(查询缓存默认不开启）</p>\n</li>\n<li><p>MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询。</p>\n</li>\n<li><p>将结果返回给客户端，如果开启查询缓存，则会备份一份到查询缓存中。</p>\n</li>\n</ol>\n<p>知道执行流程之后，我们看下MySQL的架构图。</p>\n<p><img src=\"/images/mysql/MySQL_Architecture.jpg\"></p>\n<p>mysql 逻辑架构主要分为三层</p>\n<ol>\n<li>应用层<ul>\n<li>这一层是在体系结构中的最顶层，可以在许多客户端-服务端体系结构中看到同一层。这一层包括一些大多数客户端-服务端应用程序共有的服务。从架构图中我们可以看到Client Connections 和Connect Pool。</li>\n</ul>\n</li>\n<li>核心服务层<ul>\n<li>该层负责MySQL关系数据库管理系统的所有逻辑功能。MySQL服务器的大脑位于这一层。包括查询解析、分析、优化、缓存、内置函数(比如 : 时间、数学、加密等函数)，所有的跨存储引擎的功能也在这一层实现 : 存储过程、触发器、视图等</li>\n</ul>\n</li>\n<li>存储引擎层<ul>\n<li>可插入的存储引擎功能使MySQL成为大多数开发人员的独特且首选的选择。插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。MySQL使我们可以根据不同的情况和要求选择各种存储引擎。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"架构服务\"><a href=\"#架构服务\" class=\"headerlink\" title=\"架构服务\"></a>架构服务</h3><h4 id=\"应用层的服务\"><a href=\"#应用层的服务\" class=\"headerlink\" title=\"应用层的服务\"></a>应用层的服务</h4><h5 id=\"链接处理\"><a href=\"#链接处理\" class=\"headerlink\" title=\"链接处理\"></a>链接处理</h5><p>MySQL首先是一个网络程序，其在TCP之上定义了自己的<a href=\"https://dev.mysql.com/doc/internals/en/client-server-protocol.html\">应用层协议</a>。所以要使用MySQL，我们可以编写代码，跟MySQL Server建立TCP连接，之后按照其定义好的协议进行交互。当然自己编写代码是比较麻烦的，我们也可以直接通过SDK进行链接如JDBC，ODBC等。当客户端连接到服务器时，客户端将获得自己的线程进行连接。来自该客户端的所有查询在该指定线程内执行。该线程由服务器缓存，因此不需要为每个新连接创建和销毁它们。</p>\n<h5 id=\"身份验证\"><a href=\"#身份验证\" class=\"headerlink\" title=\"身份验证\"></a>身份验证</h5><p>每当客户端连接到MySQL服务器时，服务器都会在服务器端执行身份验证。身份验证基于用户名，客户端主机和客户端用户密码。</p>\n<h5 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h5><p>客户端成功连接到MySQL服务器后，服务器将检查该特定客户端是否具有对MySQL服务器发出某些查询的特权。</p>\n<h4 id=\"核心服务层的服务\"><a href=\"#核心服务层的服务\" class=\"headerlink\" title=\"核心服务层的服务\"></a>核心服务层的服务</h4><h5 id=\"MySQL服务和实用程序\"><a href=\"#MySQL服务和实用程序\" class=\"headerlink\" title=\"MySQL服务和实用程序\"></a>MySQL服务和实用程序</h5><p>MySQL相对提供了广泛的服务和实用程序。这是MySQL普及的主要原因之一。该层提供了用于管理和维护MySQL系统的服务和实用程序。</p>\n<ul>\n<li>备份和恢复</li>\n<li>安全</li>\n<li>复制</li>\n<li>簇</li>\n<li>分区</li>\n<li>工作台</li>\n</ul>\n<h5 id=\"SQL接口\"><a href=\"#SQL接口\" class=\"headerlink\" title=\"SQL接口\"></a>SQL接口</h5><p>SQL是一种查询语言，用于查询Mysql 服务器，它是在MySQL客户端用户和服务器之间进行交互的工具。支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口。</p>\n<h5 id=\"解析器\"><a href=\"#解析器\" class=\"headerlink\" title=\"解析器\"></a>解析器</h5><p>MySQL会解析SQL查询，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。具体步骤如下：</p>\n<ul>\n<li>在解析常规语句时，首先进行词法分析（从字符流中生成单词或标记）。</li>\n<li>语法分析（使“句子”成为可能），语义分析（确保使这些句子确实有意义）和代码生成（对于编译器而言）在所有代码阶段都一次完成。 </li>\n</ul>\n<h5 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h5><p>语法解析和查询重写之后，MySQL会根据语法树和数据的统计信息对SQL进行优化，包括决定表的读取顺序、选择合适的索引等，最终生成SQL的具体执行步骤。这些具体的执行步骤里真正的数据操作都是通过预先定义好的存储引擎API来进行的，<strong>与具体的存储引擎实现无关</strong>。</p>\n<h5 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h5><p>MySQL缓存（查询缓存）存储<strong>SELECT</strong> 语句的完整结果集。甚至在解析查询之前，MySQL服务器都会查询查询缓存。如果任何客户端发出的查询与缓存中已经存在的查询相同，则服务器仅跳过解析，优化甚至执行，它仅显示缓存中的输出。</p>\n<h4 id=\"存储引擎层的服务\"><a href=\"#存储引擎层的服务\" class=\"headerlink\" title=\"存储引擎层的服务\"></a>存储引擎层的服务</h4><p>存储引擎的具体实现，这些存储引擎都实现了MySQl定义好的存储引擎API的部分或者全部。MySQL可以动态安装或移除存储引擎，可以有多种存储引擎同时存在，可以为每个Table设置不同的存储引擎。存储引擎负责在文件系统之上，管理表的数据、索引的实际内容，同时也会管理运行时的Cache、Buffer、事务、Log等数据和功能。</p>\n<pre><code class=\"hljs mysql\">-- 查看MySQL支持的存储引擎\nSHOW ENGINES;</code></pre>\n\n<p><strong>MySQL5.5以后默认使用InnoDB存储引擎</strong>，其中InnoDB和BDB提供事务安全表，其它存储引擎都是非事务安全表。</p>\n<h5 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h5><p>InnoDB引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>\n<ol>\n<li>更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。</li>\n<li>事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>\n<li>自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>\n<li>外键约束。MySQL支持外键的存储引擎只有InnoDB。</li>\n<li>支持自动增加列AUTO_INCREMENT属性。</li>\n</ol>\n<h5 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h5><p>在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特心态，包括全文索引、压缩、空间函数。但是MyISAM不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中MyISAM支持了事务，但是很多人的概念中依然是不支持事务的引擎。</p>\n<p>MyISAM存储引擎特别适合在以下几种情况下使用：</p>\n<ol>\n<li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>\n<li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/53619907\">更多引擎介绍</a></p>\n<p>本文参考：<a href=\"https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html\">https://www.rathishkumar.in/2016/04/understanding-mysql-architecture.html</a></p>\n<p>​                    <a href=\"https://zhuanlan.zhihu.com/p/53619907\">https://zhuanlan.zhihu.com/p/53619907</a></p>\n<p>​                    <a href=\"https://www.cnblogs.com/qq1148932219/p/11694064.html\">https://www.cnblogs.com/qq1148932219/p/11694064.html</a></p>\n"},{"title":"MySQL系列五之原理及性能","date":"2018-08-25T13:17:22.000Z","index_img":["/images/mysql/011_mysql_0.jpg"],"_content":"\n### 索引原理分析\n\nMySQL的索引是由**存储引擎**来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。\n\n聚簇索引和非聚簇索引：https://www.cnblogs.com/rjzheng/p/9915754.html\n\nB+tree\n\n#### 索引分类\n\n1. 主键索引：即主索引，根据主键pk_clolum（length）建立索引，**不允许重复，不允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；\n   ```\n\n2. 唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；\n   ```\n\n3. 普通索引：用表中的普通列构建的索引，没有任何限制\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col')；\n   ```\n\n4. 全文索引：用大文本对象的列构建的索引\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')；\n   ```\n\n5. 组合索引：用多个列组合构建的索引，这多个列中的值**不允许有空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；\n   ```\n\n   - 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引***\\*相当于建立了col1,col1col2,col1col2col3三个索引\\****，而col2或者col3是不能使用索引的。\n   - 在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引\n\n#### 索引的使用\n\n##### 什么时候使用索引\n\n- 主键自动建立唯一索引\n\n- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引\n\n- 作为排序的列要建立索引\n\n- 查询中与其他表关联的字段，外键关系建立索引\n\n- 高并发条件下倾向组合索引\n\n- 用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引\n\n  \n\n##### 什么时候不要使用索引\n\n- 经常增删改的列不要建立索引\n- 有大量重复的列不建立索引\n- 表记录太少不要建立索引\n\n##### 如何使用索引\n\n1. 查看表中的索引\n\n   ```mysql\n   SHOW INDEX FROM tablename\n   ```\n\n2. 查看查询语句使用索引的情况，查询语句加**explain**\n\n   ```mysql\n   explain SELECT * FROM table_name WHERE column_1='123';\n   ```\n\n3. 创建索引\n\n   ```mysql\n   -- 创建表时添加所有，index\n   CREATE TABLE mytable(  \n       ID INT NOT NULL,   \n       username VARCHAR(16) NOT NULL,  \n       INDEX [indexName] (username(length))  \n   );\n   -- 创建表之后添加索引\n   ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n   -- 或者\n   CREATE INDEX index_name ON my_table(column_name);\n   ```\n\n4. 删除索引\n\n   ```mysql\n   DROP INDEX my_index ON tablename;\n   ALTER TABLE table_name DROP INDEX index_name;\n   ```\n\n5. 根据索引查询，以下为使用的一部分\n\n   ```mysql\n   SELECT * FROM table_name WHERE column_1=column_2;-- (为column_1建立了索引)\n   SELECT * FROM table_name WHERE column_1 LIKE '三%'\n   SELECT * FROM table_name WHERE column_1 LIKE '_好_'\n   ```\n\n##### 索引失效原因\n\n- 在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。\n- 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。\n- LIKE操作中，'%aaa%'不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。\n- 在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)<2007\n- 在查询条件中使用不等于，包括<符号、>符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用<符号或者>符号不会使索引失效。（不等于，包括&lt;符号、>符号和！，如果占总记录的比例很小的话，也不会失效）\n- 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。\n- 字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。\n- 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来\n- 如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。\n- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引\n\n\n\n### 执行计划\n\n简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。\n\n基本语法是：SQL语句前面添加关键字 explain\n\n```sql\nexplain select * from stu where id >=2 order by name\n```\n\nmysql 执行计划主要包含以下信息\n\n| id   | select_type | table | partitions | type | possible_keys | key  | key_length | ref  | rows | extra |\n| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ---------- | ---- | ---- | ----- |\n|      |             |       |            |      |               |      |            |      |      |       |\n\n- **id** 表示各个子查询执行的顺序\n\n  - id 相同执行顺序由上至下\n  - id 不同，id 值越大越先被执行\n\n- **select_type** 查询数据的操作类型\n\n  | select_type  | 说明                                   |\n  | ------------ | -------------------------------------- |\n  | SIMPLE       | 不包含任何子查询或union等查询          |\n  | PRIMARY      | 包含子查询最外层查询就显示为 `PRIMARY` |\n  | SUBQUERY     | 在`select`或 `where`字句中包含的查询   |\n  | DERIVED      | `from`字句中包含的查询                 |\n  | UNION        | 出现在`union`后的查询语句中            |\n  | UNION RESULT | 从UNION中获取结果集                    |\n\n- **table** 输出的行所引用的表\n\n- **partitions** 如果查询是基于分区表的话，显示查询将访问的分区。\n\n- **type** 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。\n\n  | type            | 说明                                                       |\n  | --------------- | ---------------------------------------------------------- |\n  | system const    | 连接类型的特例，查询的表为系统表                           |\n  | const           | 使用主键或者唯一索引，且匹配的结果只有一条记录             |\n  | eq_ref          | 在`join`查询中使用`PRIMARY KEY`or`UNIQUE NOT NULL`索引关联 |\n  | ref             | 使用非唯一索引查找数据                                     |\n  | fulltext        | 使用全文索引                                               |\n  | ref_or_null     | 对`Null`进行索引的优化的 ref                               |\n  | unique_subquery | 在子查询中使用 eq_ref                                      |\n  | index_subquery  | 在子查询中使用 ref                                         |\n  | range           | 索引范围查找                                               |\n  | index           | 遍历索引                                                   |\n  | ALL             | 扫描全表数据                                               |\n\n- **possible_keys** 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。\n\n- **key** 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL\n\n- **key_length** 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度\n\n- **ref** 显示该表的索引字段关联了哪张表的哪个字段\n\n- **rows** 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\n\n- **extra** 包含不适合在其他列中显示但十分重要的额外信息\n\n  | extra           | 说明                                                         |\n  | --------------- | ------------------------------------------------------------ |\n  | Using filesort  | 表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。 |\n  | using temporary | 查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。 |\n  | using index     | 使用覆盖索引，避免了访问表的数据行。效率不错                 |\n  | Using where     | sql使用了where过滤,效率较高                                  |\n\n\n\n### 性能分析思路\n\n#### 问题定位\n\n1. 通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。\n\n   ```shell\n   # 显示状态信息,show status like ‘XXX’\n   show status;\n   #显示系统变量,show variables like ‘XXX’\n   show variables;\n   #显示InnoDB存储引擎的状态\n   show engine innodb status;\n   #查看当前SQL执行，包括执行状态、是否锁表等\n   show processlist;\n   ```\n\n   以下为退出MySQL登录之后执行\n\n   ```shell\n   # 显示状态信息\n   mysqladmin extended-status -u username -p password\n   #显示系统变量\n   mysqladmin variables -u root -p password\n   ```\n\n   常用的主要是show status和show processlist\n\n2. 慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下\n\n   ```sql\n   -- 检查是否开启\n   show variables like '%slow%';\n   -- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数\n   set global slow_query_log=ON;\n   -- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒\n   set long_query_time = 0.1;\n   ```\n\n   日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。\n\n3. explain分析查询。具体使用参考**执行计划**部分内容。\n\n4. profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。\n\n   ```sql\n   -- 查看是否开启profiling\n   select @@profiling;\n   -- 开profiling。注意测试完关闭该特性，否则耗费资源\n   set profiling=1;\n   -- 查看所有记录profile的SQL\n   show profiles;\n   -- 查看指定ID的SQL的详情\n   show profile for query 1;\n   -- 测试完，关闭该特性\n   set profiling=0;\n   ```\n\n#### 解决问题\n\n当MySQL发现性能问题。以下是一些优化思路。\n\n1. 优化SQL语句。以下是一些SQL使用建议\n   - 当结果集只有一行数据时使用LIMIT 1\n   - 多用like、不用null和where\n   - 在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销\n   - 避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。\n   - 使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。\n   - 用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度\n   - 尽可能的使用NOT NULL\n   - 拆分大的DELETE 或INSERT 语句\n   - 查询的列越小越快\n2. 建立索引。索引建立参考上面部分。索引使用建议\n   - 索引字段上不用mysql函数\n   - 在= 、group by 和 order by字段上面加上索引\n   - 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n   - 在使用in的时候可以尝试使用exists试试\n   - 在join的时候减少extra字段中临时表的数量\n   - 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。\n   - 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。\n\n\n\n参考：https://blog.csdn.net/tongdanping/article/details/79878302\n\n​\t\t\thttps://juejin.im/post/5a52386d51882573443c852a\n​\t\t\thttps://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie","source":"_posts/011_MySQL系列五.md","raw":"---\ntitle: MySQL系列五之原理及性能\ndate: 2018-08-25 21:17:22\nindex_img:\n- /images/mysql/011_mysql_0.jpg\ntags: \n- mysql\ncategories:\n- DB\n---\n\n### 索引原理分析\n\nMySQL的索引是由**存储引擎**来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。\n\n聚簇索引和非聚簇索引：https://www.cnblogs.com/rjzheng/p/9915754.html\n\nB+tree\n\n#### 索引分类\n\n1. 主键索引：即主索引，根据主键pk_clolum（length）建立索引，**不允许重复，不允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；\n   ```\n\n2. 唯一索引：用来建立索引的列的值必须是**唯一的，允许空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；\n   ```\n\n3. 普通索引：用表中的普通列构建的索引，没有任何限制\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col')；\n   ```\n\n4. 全文索引：用大文本对象的列构建的索引\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')；\n   ```\n\n5. 组合索引：用多个列组合构建的索引，这多个列中的值**不允许有空值**\n\n   ```mysql\n   ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；\n   ```\n\n   - 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引***\\*相当于建立了col1,col1col2,col1col2col3三个索引\\****，而col2或者col3是不能使用索引的。\n   - 在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引\n\n#### 索引的使用\n\n##### 什么时候使用索引\n\n- 主键自动建立唯一索引\n\n- 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引\n\n- 作为排序的列要建立索引\n\n- 查询中与其他表关联的字段，外键关系建立索引\n\n- 高并发条件下倾向组合索引\n\n- 用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引\n\n  \n\n##### 什么时候不要使用索引\n\n- 经常增删改的列不要建立索引\n- 有大量重复的列不建立索引\n- 表记录太少不要建立索引\n\n##### 如何使用索引\n\n1. 查看表中的索引\n\n   ```mysql\n   SHOW INDEX FROM tablename\n   ```\n\n2. 查看查询语句使用索引的情况，查询语句加**explain**\n\n   ```mysql\n   explain SELECT * FROM table_name WHERE column_1='123';\n   ```\n\n3. 创建索引\n\n   ```mysql\n   -- 创建表时添加所有，index\n   CREATE TABLE mytable(  \n       ID INT NOT NULL,   \n       username VARCHAR(16) NOT NULL,  \n       INDEX [indexName] (username(length))  \n   );\n   -- 创建表之后添加索引\n   ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n   -- 或者\n   CREATE INDEX index_name ON my_table(column_name);\n   ```\n\n4. 删除索引\n\n   ```mysql\n   DROP INDEX my_index ON tablename;\n   ALTER TABLE table_name DROP INDEX index_name;\n   ```\n\n5. 根据索引查询，以下为使用的一部分\n\n   ```mysql\n   SELECT * FROM table_name WHERE column_1=column_2;-- (为column_1建立了索引)\n   SELECT * FROM table_name WHERE column_1 LIKE '三%'\n   SELECT * FROM table_name WHERE column_1 LIKE '_好_'\n   ```\n\n##### 索引失效原因\n\n- 在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。\n- 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。\n- LIKE操作中，'%aaa%'不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。\n- 在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)<2007\n- 在查询条件中使用不等于，包括<符号、>符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用<符号或者>符号不会使索引失效。（不等于，包括&lt;符号、>符号和！，如果占总记录的比例很小的话，也不会失效）\n- 在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。\n- 字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。\n- 在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来\n- 如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。\n- 尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引\n\n\n\n### 执行计划\n\n简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。\n\n基本语法是：SQL语句前面添加关键字 explain\n\n```sql\nexplain select * from stu where id >=2 order by name\n```\n\nmysql 执行计划主要包含以下信息\n\n| id   | select_type | table | partitions | type | possible_keys | key  | key_length | ref  | rows | extra |\n| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ---------- | ---- | ---- | ----- |\n|      |             |       |            |      |               |      |            |      |      |       |\n\n- **id** 表示各个子查询执行的顺序\n\n  - id 相同执行顺序由上至下\n  - id 不同，id 值越大越先被执行\n\n- **select_type** 查询数据的操作类型\n\n  | select_type  | 说明                                   |\n  | ------------ | -------------------------------------- |\n  | SIMPLE       | 不包含任何子查询或union等查询          |\n  | PRIMARY      | 包含子查询最外层查询就显示为 `PRIMARY` |\n  | SUBQUERY     | 在`select`或 `where`字句中包含的查询   |\n  | DERIVED      | `from`字句中包含的查询                 |\n  | UNION        | 出现在`union`后的查询语句中            |\n  | UNION RESULT | 从UNION中获取结果集                    |\n\n- **table** 输出的行所引用的表\n\n- **partitions** 如果查询是基于分区表的话，显示查询将访问的分区。\n\n- **type** 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。\n\n  | type            | 说明                                                       |\n  | --------------- | ---------------------------------------------------------- |\n  | system const    | 连接类型的特例，查询的表为系统表                           |\n  | const           | 使用主键或者唯一索引，且匹配的结果只有一条记录             |\n  | eq_ref          | 在`join`查询中使用`PRIMARY KEY`or`UNIQUE NOT NULL`索引关联 |\n  | ref             | 使用非唯一索引查找数据                                     |\n  | fulltext        | 使用全文索引                                               |\n  | ref_or_null     | 对`Null`进行索引的优化的 ref                               |\n  | unique_subquery | 在子查询中使用 eq_ref                                      |\n  | index_subquery  | 在子查询中使用 ref                                         |\n  | range           | 索引范围查找                                               |\n  | index           | 遍历索引                                                   |\n  | ALL             | 扫描全表数据                                               |\n\n- **possible_keys** 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。\n\n- **key** 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL\n\n- **key_length** 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度\n\n- **ref** 显示该表的索引字段关联了哪张表的哪个字段\n\n- **rows** 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\n\n- **extra** 包含不适合在其他列中显示但十分重要的额外信息\n\n  | extra           | 说明                                                         |\n  | --------------- | ------------------------------------------------------------ |\n  | Using filesort  | 表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。 |\n  | using temporary | 查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。 |\n  | using index     | 使用覆盖索引，避免了访问表的数据行。效率不错                 |\n  | Using where     | sql使用了where过滤,效率较高                                  |\n\n\n\n### 性能分析思路\n\n#### 问题定位\n\n1. 通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。\n\n   ```shell\n   # 显示状态信息,show status like ‘XXX’\n   show status;\n   #显示系统变量,show variables like ‘XXX’\n   show variables;\n   #显示InnoDB存储引擎的状态\n   show engine innodb status;\n   #查看当前SQL执行，包括执行状态、是否锁表等\n   show processlist;\n   ```\n\n   以下为退出MySQL登录之后执行\n\n   ```shell\n   # 显示状态信息\n   mysqladmin extended-status -u username -p password\n   #显示系统变量\n   mysqladmin variables -u root -p password\n   ```\n\n   常用的主要是show status和show processlist\n\n2. 慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下\n\n   ```sql\n   -- 检查是否开启\n   show variables like '%slow%';\n   -- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数\n   set global slow_query_log=ON;\n   -- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒\n   set long_query_time = 0.1;\n   ```\n\n   日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。\n\n3. explain分析查询。具体使用参考**执行计划**部分内容。\n\n4. profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。\n\n   ```sql\n   -- 查看是否开启profiling\n   select @@profiling;\n   -- 开profiling。注意测试完关闭该特性，否则耗费资源\n   set profiling=1;\n   -- 查看所有记录profile的SQL\n   show profiles;\n   -- 查看指定ID的SQL的详情\n   show profile for query 1;\n   -- 测试完，关闭该特性\n   set profiling=0;\n   ```\n\n#### 解决问题\n\n当MySQL发现性能问题。以下是一些优化思路。\n\n1. 优化SQL语句。以下是一些SQL使用建议\n   - 当结果集只有一行数据时使用LIMIT 1\n   - 多用like、不用null和where\n   - 在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销\n   - 避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。\n   - 使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。\n   - 用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度\n   - 尽可能的使用NOT NULL\n   - 拆分大的DELETE 或INSERT 语句\n   - 查询的列越小越快\n2. 建立索引。索引建立参考上面部分。索引使用建议\n   - 索引字段上不用mysql函数\n   - 在= 、group by 和 order by字段上面加上索引\n   - 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n   - 在使用in的时候可以尝试使用exists试试\n   - 在join的时候减少extra字段中临时表的数量\n   - 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。\n   - 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。\n\n\n\n参考：https://blog.csdn.net/tongdanping/article/details/79878302\n\n​\t\t\thttps://juejin.im/post/5a52386d51882573443c852a\n​\t\t\thttps://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie","slug":"011_MySQL系列五","published":1,"updated":"2021-03-10T06:13:24.459Z","_id":"ckm31f4et000j17ym81ne5wj8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"索引原理分析\"><a href=\"#索引原理分析\" class=\"headerlink\" title=\"索引原理分析\"></a>索引原理分析</h3><p>MySQL的索引是由<strong>存储引擎</strong>来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。</p>\n<p>聚簇索引和非聚簇索引：<a href=\"https://www.cnblogs.com/rjzheng/p/9915754.html\">https://www.cnblogs.com/rjzheng/p/9915754.html</a></p>\n<p>B+tree</p>\n<h4 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h4><ol>\n<li><p>主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>普通索引：用表中的普通列构建的索引，没有任何限制</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>全文索引：用大文本对象的列构建的索引</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>组合索引：用多个列组合构建的索引，这多个列中的值<strong>不允许有空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</code></pre>\n\n<ul>\n<li>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引*<strong>*相当于建立了col1,col1col2,col1col2col3三个索引**</strong>，而col2或者col3是不能使用索引的。</li>\n<li>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h4><h5 id=\"什么时候使用索引\"><a href=\"#什么时候使用索引\" class=\"headerlink\" title=\"什么时候使用索引\"></a>什么时候使用索引</h5><ul>\n<li><p>主键自动建立唯一索引</p>\n</li>\n<li><p>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引</p>\n</li>\n<li><p>作为排序的列要建立索引</p>\n</li>\n<li><p>查询中与其他表关联的字段，外键关系建立索引</p>\n</li>\n<li><p>高并发条件下倾向组合索引</p>\n</li>\n<li><p>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</p>\n</li>\n</ul>\n<h5 id=\"什么时候不要使用索引\"><a href=\"#什么时候不要使用索引\" class=\"headerlink\" title=\"什么时候不要使用索引\"></a>什么时候不要使用索引</h5><ul>\n<li>经常增删改的列不要建立索引</li>\n<li>有大量重复的列不建立索引</li>\n<li>表记录太少不要建立索引</li>\n</ul>\n<h5 id=\"如何使用索引\"><a href=\"#如何使用索引\" class=\"headerlink\" title=\"如何使用索引\"></a>如何使用索引</h5><ol>\n<li><p>查看表中的索引</p>\n<pre><code class=\"hljs mysql\">SHOW INDEX FROM tablename</code></pre>\n</li>\n<li><p>查看查询语句使用索引的情况，查询语句加<strong>explain</strong></p>\n<pre><code class=\"hljs mysql\">explain SELECT * FROM table_name WHERE column_1&#x3D;&#39;123&#39;;</code></pre>\n</li>\n<li><p>创建索引</p>\n<pre><code class=\"hljs mysql\">-- 创建表时添加所有，index\nCREATE TABLE mytable(  \n    ID INT NOT NULL,   \n    username VARCHAR(16) NOT NULL,  \n    INDEX [indexName] (username(length))  \n);\n-- 创建表之后添加索引\nALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n-- 或者\nCREATE INDEX index_name ON my_table(column_name);</code></pre>\n</li>\n<li><p>删除索引</p>\n<pre><code class=\"hljs mysql\">DROP INDEX my_index ON tablename;\nALTER TABLE table_name DROP INDEX index_name;</code></pre>\n</li>\n<li><p>根据索引查询，以下为使用的一部分</p>\n<pre><code class=\"hljs mysql\">SELECT * FROM table_name WHERE column_1&#x3D;column_2;-- (为column_1建立了索引)\nSELECT * FROM table_name WHERE column_1 LIKE &#39;三%&#39;\nSELECT * FROM table_name WHERE column_1 LIKE &#39;_好_&#39;</code></pre>\n\n</li>\n</ol>\n<h5 id=\"索引失效原因\"><a href=\"#索引失效原因\" class=\"headerlink\" title=\"索引失效原因\"></a>索引失效原因</h5><ul>\n<li>在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</li>\n<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</li>\n<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。</li>\n<li>在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)&lt;2007</li>\n<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效）</li>\n<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。</li>\n<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。</li>\n<li>在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来</li>\n<li>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</li>\n<li>尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引</li>\n</ul>\n<h3 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h3><p>简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。</p>\n<p>基本语法是：SQL语句前面添加关键字 explain</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">explain</span> <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> stu <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span> &gt;=<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">name</span></code></pre>\n\n<p>mysql 执行计划主要包含以下信息</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>partitions</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_length</th>\n<th>ref</th>\n<th>rows</th>\n<th>extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><strong>id</strong> 表示各个子查询执行的顺序</p>\n<ul>\n<li>id 相同执行顺序由上至下</li>\n<li>id 不同，id 值越大越先被执行</li>\n</ul>\n</li>\n<li><p><strong>select_type</strong> 查询数据的操作类型</p>\n<table>\n<thead>\n<tr>\n<th>select_type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>不包含任何子查询或union等查询</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>包含子查询最外层查询就显示为 <code>PRIMARY</code></td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>在<code>select</code>或 <code>where</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td><code>from</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>出现在<code>union</code>后的查询语句中</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>从UNION中获取结果集</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>table</strong> 输出的行所引用的表</p>\n</li>\n<li><p><strong>partitions</strong> 如果查询是基于分区表的话，显示查询将访问的分区。</p>\n</li>\n<li><p><strong>type</strong> 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。</p>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>system const</td>\n<td>连接类型的特例，查询的表为系统表</td>\n</tr>\n<tr>\n<td>const</td>\n<td>使用主键或者唯一索引，且匹配的结果只有一条记录</td>\n</tr>\n<tr>\n<td>eq_ref</td>\n<td>在<code>join</code>查询中使用<code>PRIMARY KEY</code>or<code>UNIQUE NOT NULL</code>索引关联</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>使用非唯一索引查找数据</td>\n</tr>\n<tr>\n<td>fulltext</td>\n<td>使用全文索引</td>\n</tr>\n<tr>\n<td>ref_or_null</td>\n<td>对<code>Null</code>进行索引的优化的 ref</td>\n</tr>\n<tr>\n<td>unique_subquery</td>\n<td>在子查询中使用 eq_ref</td>\n</tr>\n<tr>\n<td>index_subquery</td>\n<td>在子查询中使用 ref</td>\n</tr>\n<tr>\n<td>range</td>\n<td>索引范围查找</td>\n</tr>\n<tr>\n<td>index</td>\n<td>遍历索引</td>\n</tr>\n<tr>\n<td>ALL</td>\n<td>扫描全表数据</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>possible_keys</strong> 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。</p>\n</li>\n<li><p><strong>key</strong> 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL</p>\n</li>\n<li><p><strong>key_length</strong> 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度</p>\n</li>\n<li><p><strong>ref</strong> 显示该表的索引字段关联了哪张表的哪个字段</p>\n</li>\n<li><p><strong>rows</strong> 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n</li>\n<li><p><strong>extra</strong> 包含不适合在其他列中显示但十分重要的额外信息</p>\n<table>\n<thead>\n<tr>\n<th>extra</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Using filesort</td>\n<td>表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。</td>\n</tr>\n<tr>\n<td>using temporary</td>\n<td>查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。</td>\n</tr>\n<tr>\n<td>using index</td>\n<td>使用覆盖索引，避免了访问表的数据行。效率不错</td>\n</tr>\n<tr>\n<td>Using where</td>\n<td>sql使用了where过滤,效率较高</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"性能分析思路\"><a href=\"#性能分析思路\" class=\"headerlink\" title=\"性能分析思路\"></a>性能分析思路</h3><h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><ol>\n<li><p>通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息,show status like ‘XXX’</span>\nshow status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量,show variables like ‘XXX’</span>\nshow variables;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示InnoDB存储引擎的状态</span>\nshow engine innodb status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">查看当前SQL执行，包括执行状态、是否锁表等</span>\nshow processlist;</code></pre>\n\n<p>以下为退出MySQL登录之后执行</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息</span>\nmysqladmin extended-status -u username -p password\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量</span>\nmysqladmin variables -u root -p password</code></pre>\n\n<p>常用的主要是show status和show processlist</p>\n</li>\n<li><p>慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 检查是否开启</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">variables</span> <span class=\"hljs-keyword\">like</span> <span class=\"hljs-string\">&#x27;%slow%&#x27;</span>;\n<span class=\"hljs-comment\">-- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">global</span> slow_query_log=<span class=\"hljs-keyword\">ON</span>;\n<span class=\"hljs-comment\">-- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒</span>\n<span class=\"hljs-keyword\">set</span> long_query_time = <span class=\"hljs-number\">0.1</span>;</code></pre>\n\n<p>日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。</p>\n</li>\n<li><p>explain分析查询。具体使用参考<strong>执行计划</strong>部分内容。</p>\n</li>\n<li><p>profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 查看是否开启profiling</span>\n<span class=\"hljs-keyword\">select</span> @@profiling;\n<span class=\"hljs-comment\">-- 开profiling。注意测试完关闭该特性，否则耗费资源</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 查看所有记录profile的SQL</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">profiles</span>;\n<span class=\"hljs-comment\">-- 查看指定ID的SQL的详情</span>\n<span class=\"hljs-keyword\">show</span> profile <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">query</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 测试完，关闭该特性</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">0</span>;</code></pre>\n\n</li>\n</ol>\n<h4 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h4><p>当MySQL发现性能问题。以下是一些优化思路。</p>\n<ol>\n<li>优化SQL语句。以下是一些SQL使用建议<ul>\n<li>当结果集只有一行数据时使用LIMIT 1</li>\n<li>多用like、不用null和where</li>\n<li>在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销</li>\n<li>避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。</li>\n<li>使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li>\n<li>用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度</li>\n<li>尽可能的使用NOT NULL</li>\n<li>拆分大的DELETE 或INSERT 语句</li>\n<li>查询的列越小越快</li>\n</ul>\n</li>\n<li>建立索引。索引建立参考上面部分。索引使用建议<ul>\n<li>索引字段上不用mysql函数</li>\n<li>在= 、group by 和 order by字段上面加上索引</li>\n<li>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>\n<li>在使用in的时候可以尝试使用exists试试</li>\n<li>在join的时候减少extra字段中临时表的数量</li>\n<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>\n<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>\n</ul>\n</li>\n</ol>\n<p>参考：<a href=\"https://blog.csdn.net/tongdanping/article/details/79878302\">https://blog.csdn.net/tongdanping/article/details/79878302</a></p>\n<p>​            <a href=\"https://juejin.im/post/5a52386d51882573443c852a\">https://juejin.im/post/5a52386d51882573443c852a</a><br>​            <a href=\"https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie\">https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"索引原理分析\"><a href=\"#索引原理分析\" class=\"headerlink\" title=\"索引原理分析\"></a>索引原理分析</h3><p>MySQL的索引是由<strong>存储引擎</strong>来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。MySQL的InnoDB引擎就是基于B+Tree索引的。</p>\n<p>聚簇索引和非聚簇索引：<a href=\"https://www.cnblogs.com/rjzheng/p/9915754.html\">https://www.cnblogs.com/rjzheng/p/9915754.html</a></p>\n<p>B+tree</p>\n<h4 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a>索引分类</h4><ol>\n<li><p>主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>普通索引：用表中的普通列构建的索引，没有任何限制</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>全文索引：用大文本对象的列构建的索引</p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</code></pre>\n</li>\n<li><p>组合索引：用多个列组合构建的索引，这多个列中的值<strong>不允许有空值</strong></p>\n<pre><code class=\"hljs mysql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</code></pre>\n\n<ul>\n<li>遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引*<strong>*相当于建立了col1,col1col2,col1col2col3三个索引**</strong>，而col2或者col3是不能使用索引的。</li>\n<li>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h4><h5 id=\"什么时候使用索引\"><a href=\"#什么时候使用索引\" class=\"headerlink\" title=\"什么时候使用索引\"></a>什么时候使用索引</h5><ul>\n<li><p>主键自动建立唯一索引</p>\n</li>\n<li><p>经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引</p>\n</li>\n<li><p>作为排序的列要建立索引</p>\n</li>\n<li><p>查询中与其他表关联的字段，外键关系建立索引</p>\n</li>\n<li><p>高并发条件下倾向组合索引</p>\n</li>\n<li><p>用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</p>\n</li>\n</ul>\n<h5 id=\"什么时候不要使用索引\"><a href=\"#什么时候不要使用索引\" class=\"headerlink\" title=\"什么时候不要使用索引\"></a>什么时候不要使用索引</h5><ul>\n<li>经常增删改的列不要建立索引</li>\n<li>有大量重复的列不建立索引</li>\n<li>表记录太少不要建立索引</li>\n</ul>\n<h5 id=\"如何使用索引\"><a href=\"#如何使用索引\" class=\"headerlink\" title=\"如何使用索引\"></a>如何使用索引</h5><ol>\n<li><p>查看表中的索引</p>\n<pre><code class=\"hljs mysql\">SHOW INDEX FROM tablename</code></pre>\n</li>\n<li><p>查看查询语句使用索引的情况，查询语句加<strong>explain</strong></p>\n<pre><code class=\"hljs mysql\">explain SELECT * FROM table_name WHERE column_1&#x3D;&#39;123&#39;;</code></pre>\n</li>\n<li><p>创建索引</p>\n<pre><code class=\"hljs mysql\">-- 创建表时添加所有，index\nCREATE TABLE mytable(  \n    ID INT NOT NULL,   \n    username VARCHAR(16) NOT NULL,  \n    INDEX [indexName] (username(length))  \n);\n-- 创建表之后添加索引\nALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n-- 或者\nCREATE INDEX index_name ON my_table(column_name);</code></pre>\n</li>\n<li><p>删除索引</p>\n<pre><code class=\"hljs mysql\">DROP INDEX my_index ON tablename;\nALTER TABLE table_name DROP INDEX index_name;</code></pre>\n</li>\n<li><p>根据索引查询，以下为使用的一部分</p>\n<pre><code class=\"hljs mysql\">SELECT * FROM table_name WHERE column_1&#x3D;column_2;-- (为column_1建立了索引)\nSELECT * FROM table_name WHERE column_1 LIKE &#39;三%&#39;\nSELECT * FROM table_name WHERE column_1 LIKE &#39;_好_&#39;</code></pre>\n\n</li>\n</ol>\n<h5 id=\"索引失效原因\"><a href=\"#索引失效原因\" class=\"headerlink\" title=\"索引失效原因\"></a>索引失效原因</h5><ul>\n<li>在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</li>\n<li>在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。</li>\n<li>LIKE操作中，’%aaa%’不会使用索引，也就是索引会失效，但是‘aaa%’可以使用索引。</li>\n<li>在索引的列上使用表达式或者函数会使索引失效，例如：select * from users where YEAR(adddate)&lt;2007</li>\n<li>在查询条件中使用不等于，包括&lt;符号、&gt;符号和！=会导致索引失效。特别的是如果对主键索引使用！=则不会使索引失效，如果对主键索引或者整数类型的索引使用&lt;符号或者&gt;符号不会使索引失效。（不等于，包括&lt;符号、&gt;符号和！，如果占总记录的比例很小的话，也不会失效）</li>\n<li>在查询条件中使用IS NULL或者IS NOT NULL会导致索引失效。</li>\n<li>字符串不加单引号会导致索引失效。更准确的说是类型不一致会导致失效，比如字段email是字符串类型的，使用WHERE email=99999 则会导致失败。</li>\n<li>在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来</li>\n<li>如果排序的字段使用了索引，那么select的字段也要是索引字段，否则索引失效。特别的是如果排序的是主键索引则select * 也不会导致索引失效。</li>\n<li>尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引</li>\n</ul>\n<h3 id=\"执行计划\"><a href=\"#执行计划\" class=\"headerlink\" title=\"执行计划\"></a>执行计划</h3><p>简单来说，执行计划是Mysql执行一条sql 时的表现，包括SQL查询的顺序、是否使用索引、以及使用的索引信息等内容，通常用于SQL的性能分析、优化等场景。</p>\n<p>基本语法是：SQL语句前面添加关键字 explain</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">explain</span> <span class=\"hljs-keyword\">select</span> * <span class=\"hljs-keyword\">from</span> stu <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span> &gt;=<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-keyword\">name</span></code></pre>\n\n<p>mysql 执行计划主要包含以下信息</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>partitions</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_length</th>\n<th>ref</th>\n<th>rows</th>\n<th>extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p><strong>id</strong> 表示各个子查询执行的顺序</p>\n<ul>\n<li>id 相同执行顺序由上至下</li>\n<li>id 不同，id 值越大越先被执行</li>\n</ul>\n</li>\n<li><p><strong>select_type</strong> 查询数据的操作类型</p>\n<table>\n<thead>\n<tr>\n<th>select_type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>不包含任何子查询或union等查询</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>包含子查询最外层查询就显示为 <code>PRIMARY</code></td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>在<code>select</code>或 <code>where</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td><code>from</code>字句中包含的查询</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>出现在<code>union</code>后的查询语句中</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>从UNION中获取结果集</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>table</strong> 输出的行所引用的表</p>\n</li>\n<li><p><strong>partitions</strong> 如果查询是基于分区表的话，显示查询将访问的分区。</p>\n</li>\n<li><p><strong>type</strong> 表示访问类型，性能由高到底，system const 性能最高，ALL性能最低。一般来说，得保证查询至少达到range级别，最好能达到ref。</p>\n<table>\n<thead>\n<tr>\n<th>type</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>system const</td>\n<td>连接类型的特例，查询的表为系统表</td>\n</tr>\n<tr>\n<td>const</td>\n<td>使用主键或者唯一索引，且匹配的结果只有一条记录</td>\n</tr>\n<tr>\n<td>eq_ref</td>\n<td>在<code>join</code>查询中使用<code>PRIMARY KEY</code>or<code>UNIQUE NOT NULL</code>索引关联</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>使用非唯一索引查找数据</td>\n</tr>\n<tr>\n<td>fulltext</td>\n<td>使用全文索引</td>\n</tr>\n<tr>\n<td>ref_or_null</td>\n<td>对<code>Null</code>进行索引的优化的 ref</td>\n</tr>\n<tr>\n<td>unique_subquery</td>\n<td>在子查询中使用 eq_ref</td>\n</tr>\n<tr>\n<td>index_subquery</td>\n<td>在子查询中使用 ref</td>\n</tr>\n<tr>\n<td>range</td>\n<td>索引范围查找</td>\n</tr>\n<tr>\n<td>index</td>\n<td>遍历索引</td>\n</tr>\n<tr>\n<td>ALL</td>\n<td>扫描全表数据</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>possible_keys</strong> 指出MySQL能使用哪个索引在该表中找到行。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能。</p>\n</li>\n<li><p><strong>key</strong> 显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL</p>\n</li>\n<li><p><strong>key_length</strong> 表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度</p>\n</li>\n<li><p><strong>ref</strong> 显示该表的索引字段关联了哪张表的哪个字段</p>\n</li>\n<li><p><strong>rows</strong> 根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>\n</li>\n<li><p><strong>extra</strong> 包含不适合在其他列中显示但十分重要的额外信息</p>\n<table>\n<thead>\n<tr>\n<th>extra</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Using filesort</td>\n<td>表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。</td>\n</tr>\n<tr>\n<td>using temporary</td>\n<td>查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。</td>\n</tr>\n<tr>\n<td>using index</td>\n<td>使用覆盖索引，避免了访问表的数据行。效率不错</td>\n</tr>\n<tr>\n<td>Using where</td>\n<td>sql使用了where过滤,效率较高</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"性能分析思路\"><a href=\"#性能分析思路\" class=\"headerlink\" title=\"性能分析思路\"></a>性能分析思路</h3><h4 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h4><ol>\n<li><p>通过命令查看MySQL的状态，来找到系统瓶颈。以下都是已经登录mysql 之后使用的命令。</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息,show status like ‘XXX’</span>\nshow status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量,show variables like ‘XXX’</span>\nshow variables;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示InnoDB存储引擎的状态</span>\nshow engine innodb status;\n<span class=\"hljs-meta\">#</span><span class=\"bash\">查看当前SQL执行，包括执行状态、是否锁表等</span>\nshow processlist;</code></pre>\n\n<p>以下为退出MySQL登录之后执行</p>\n<pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 显示状态信息</span>\nmysqladmin extended-status -u username -p password\n<span class=\"hljs-meta\">#</span><span class=\"bash\">显示系统变量</span>\nmysqladmin variables -u root -p password</code></pre>\n\n<p>常用的主要是show status和show processlist</p>\n</li>\n<li><p>慢日志查询。慢查询日志可以帮助我们知道哪些SQL语句执行效率低下</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 检查是否开启</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">variables</span> <span class=\"hljs-keyword\">like</span> <span class=\"hljs-string\">&#x27;%slow%&#x27;</span>;\n<span class=\"hljs-comment\">-- 如果没有开启，也可以在运行时开启这个参数。说明是动态参数</span>\n<span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">global</span> slow_query_log=<span class=\"hljs-keyword\">ON</span>;\n<span class=\"hljs-comment\">-- 设置慢查询记录查询耗时多长的SQL,这里演示用100毫秒</span>\n<span class=\"hljs-keyword\">set</span> long_query_time = <span class=\"hljs-number\">0.1</span>;</code></pre>\n\n<p>日志文件在/var/lib/mysql/mysql目录下，如果不在查看下MySQL的配置文件。</p>\n</li>\n<li><p>explain分析查询。具体使用参考<strong>执行计划</strong>部分内容。</p>\n</li>\n<li><p>profiling分析查询。通过profiling命令得到更准确的SQL执行消耗系统资源的信息。profiling默认是关闭的。</p>\n<pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 查看是否开启profiling</span>\n<span class=\"hljs-keyword\">select</span> @@profiling;\n<span class=\"hljs-comment\">-- 开profiling。注意测试完关闭该特性，否则耗费资源</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 查看所有记录profile的SQL</span>\n<span class=\"hljs-keyword\">show</span> <span class=\"hljs-keyword\">profiles</span>;\n<span class=\"hljs-comment\">-- 查看指定ID的SQL的详情</span>\n<span class=\"hljs-keyword\">show</span> profile <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">query</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">-- 测试完，关闭该特性</span>\n<span class=\"hljs-keyword\">set</span> profiling=<span class=\"hljs-number\">0</span>;</code></pre>\n\n</li>\n</ol>\n<h4 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h4><p>当MySQL发现性能问题。以下是一些优化思路。</p>\n<ol>\n<li>优化SQL语句。以下是一些SQL使用建议<ul>\n<li>当结果集只有一行数据时使用LIMIT 1</li>\n<li>多用like、不用null和where</li>\n<li>在join的时候中结果集更小的部分join更大的部分，这样可以减少缓存的开销</li>\n<li>避免SELECT *，始终指定你需要的列。从表中读取越多的数据，查询会变得更慢。</li>\n<li>使用连接（JOIN）来代替子查询(Sub-Queries) : 连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</li>\n<li>用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度</li>\n<li>尽可能的使用NOT NULL</li>\n<li>拆分大的DELETE 或INSERT 语句</li>\n<li>查询的列越小越快</li>\n</ul>\n</li>\n<li>建立索引。索引建立参考上面部分。索引使用建议<ul>\n<li>索引字段上不用mysql函数</li>\n<li>在= 、group by 和 order by字段上面加上索引</li>\n<li>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li>\n<li>在使用in的时候可以尝试使用exists试试</li>\n<li>在join的时候减少extra字段中临时表的数量</li>\n<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>\n<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>\n</ul>\n</li>\n</ol>\n<p>参考：<a href=\"https://blog.csdn.net/tongdanping/article/details/79878302\">https://blog.csdn.net/tongdanping/article/details/79878302</a></p>\n<p>​            <a href=\"https://juejin.im/post/5a52386d51882573443c852a\">https://juejin.im/post/5a52386d51882573443c852a</a><br>​            <a href=\"https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie\">https://kaimingwan.com/post/shu-ju-ku/mysqlxing-neng-fen-xi-fang-fa-gong-ju-jing-yan-zong-jie</a></p>\n"},{"title":"golang 之 cgo","date":"2018-08-30T10:00:12.000Z","index_img":["/images/golang/012_cgo_0.jpg"],"_content":"\n使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。\n\n### cgo 的简单例子\n\n让我们从一个简单的cgo 例子说起\n\n```go\npackage main\n//#include <stdio.h>\n//#include <stdlib.h>\nimport \"C\" //该语句要单独写一行\n\nimport (\n   \"unsafe\"\n)\n\nfunc main() {\n   //C.CString将go string 转换成C string\n   s := C.CString(\"Hello, World\\n\")\n   // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n   // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n   // 而且这种内存泄露pprof 也定位不出来\n   defer C.free(unsafe.Pointer(s))\n   //C.puts 函数向标准输出窗口打印，\n   C.puts(s)\n}\n```\n\n虽然上面的代码有注释了，但是还是有一些需要特别注意的。\n\n1. 第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo\n\n   ```go\n   //#include <stdio.h>\n   //#include <stdlib.h>\n   import \"C\"\n   ```\n\n2. 第二个是main 函数里面的内容\n\n   ```go\n   func main() {\n      //C.CString将go string 转换成C string\n      s := C.CString(\"Hello, World\\n\")\n      // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n      // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n      // 而且这种内存泄露pprof 也定位不出来\n      defer C.free(unsafe.Pointer(s))\n      //C.puts 函数向标准输出窗口打印，\n      C.puts(s)\n   }\n   ```\n\n   - Go代码中的`s`变量在传递给c代码使用完成之后，需要调用`C.free`进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。\n\n     ![](/images/golang/string.jpg)\n\n     从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。\n\n     我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了\n\n     ```go\n     // Go string to C string\n     // The C string is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CString(string) *C.char\n     \n     // 这个文档上的大概意思是\n     // C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）\n     ```\n\n     我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。\n\n     ```go\n     // Go []byte slice to C array\n     // The C array is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CBytes([]byte) unsafe.Pointer\n     \n     // C string to Go string\n     func C.GoString(*C.char) string\n     \n     // C data with explicit length to Go string\n     func C.GoStringN(*C.char, C.int) string\n     \n     // C data with explicit length to Go []byte\n     func C.GoBytes(unsafe.Pointer, C.int) []byte\n     ```\n\n     一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。\n     所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即`free`）传入的这份内存。\n     所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。\n\n     \n\n   - 其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过`unsafe.Pointer`获取原始指针进行传递。`unsafe.Pointer`是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。\n\nGo语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考[Go语言高级编程](https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html)\n\n### Go 和 C 之间的数组传递\n\n#### Go数组到C \n\n我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint loop(int** list_data, int leng, char** data)\n{\n  int* m = (int*)list_data;\n  int sum = 0;\n  for(int i=0; i<leng; i++)\n  {\n    sum += m[i];\n  }\n  *data = \"finised task\";\n  return sum;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc GoSilence2CArray() {\n\tvar ids = []int32{1, 2, 3, 5}\n\tvar res *C.char\n\tlength := C.int(len(ids))\n\tle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n}\nfunc main() {\n\tGoSilence2CArray()\n}\n```\n\n整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。\n\n```go\n//正确写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n//错误写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids)), length, &res)\n```\n\nSlice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&ids，那相当于把ids这个数据结构的地址处的数据强制转换为`(**C.int)`。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是`(**C.int)(unsafe.Pointer(&ids[0]))`。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)\n\n#### C数组到Go slice\n\n还是直接看例子\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct{\n   char* name;\n}person;\n\nperson* get_person(int n){\n   person* ret = (person*)malloc(sizeof(person) * n);\n   for(int i=0;i<n;i++){\n      ret[i].name=\"wu\";\n   }\n   return ret;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc CArray2GoSilence() {\n\tsize := 2\n\tperson := C.get_person(C.int(size))\n\tperson_array := (*[1 << 30]C.person)(unsafe.Pointer(person))\n\tvar names []string\n\tfor i := 0; i < size; i++ {\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = append(names, name)\n\t}\n\tfor _, name := range names {\n\t\tfmt.Println(name)\n\t}\n\tC.free(unsafe.Pointer(person))\n}\nfunc main() {\n\tCArray2GoSilence()\n}\n```\n\nC语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。`(*[1 << 30]C.person)(unsafe.Pointer(person))` 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。\n\n### cgo利用pkg_config 使用第三方的so库\n\n#### pkg_config\n\n我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。**pkg-config** 是一个在[源代码](https://zh.wikipedia.org/wiki/源代码)[编译](https://zh.wikipedia.org/wiki/编译)时查询已安装的[库](https://zh.wikipedia.org/wiki/库)的使用接口的计算机工具[软件](https://zh.wikipedia.org/wiki/软件)。pkg-config原本是设计用于[Linux](https://zh.wikipedia.org/wiki/Linux)的，但现在在各个版本的[BSD](https://zh.wikipedia.org/wiki/BSD)、[windows](https://zh.wikipedia.org/wiki/Windows)、[Mac OS X](https://zh.wikipedia.org/wiki/Mac_OS_X)和[Solaris](https://zh.wikipedia.org/wiki/Solaris)上都有着可用的版本。\n\n那么pkg-config有什么作用呢？\n\n1. 检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。\n2. 获得编译预处理参数，如宏定义，头文件的位置。\n3. 得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。\n4. 自动加入所依赖的其它库的设置。\n\npkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于[libpng](https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1)的.pc文件的样例:\n\n```shell\nprefix=/usr/local\nexec_prefix=${prefix}\nlibdir=${exec_prefix}/lib\nincludedir=${exec_prefix}/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L${libdir} -lpng12 -lz\nCflags: -I${includedir}/libpng12\n```\n\n这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。\n\npkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。\n\n#### cgo 使用pkg-config\n\n我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分\n\n```go\npackage cgo\n// #cgo pkg-config: megproduct\n// #cgo CXXFLAGS: -std=c++11\n// #include \"plate.h\"\n// #include \"stdlib.h\"\nimport \"C\"\n//后续使用方法和go 调用C的方式一致了\n```\n\n我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。\n\n我们来看下megproduct.pc 是咋样的\n\n```shell\nprefix=/go/DATA/plate-sdk-190710\nlibdir=${prefix}/lib\nincludedir=${prefix}/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: ${libdir}/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I${includedir}\n```\n\n使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config\n\n\n\n本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。\n\n\n\n参考：[Go语言使用cgo时的内存管理笔记](https://www.pengrl.com/p/29054/)\n\n​\t\t\t[官方文档](https://golang.org/cmd/cgo/)\n\n​\t\t\t[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)","source":"_posts/012_golang之cgo.md","raw":"---\ntitle: golang 之 cgo\ndate: 2018-08-30 18:00:12\nindex_img:\n- /images/golang/012_cgo_0.jpg\ntags: \n- golang cgo\ncategories:\n- golang\n---\n\n使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。\n\n### cgo 的简单例子\n\n让我们从一个简单的cgo 例子说起\n\n```go\npackage main\n//#include <stdio.h>\n//#include <stdlib.h>\nimport \"C\" //该语句要单独写一行\n\nimport (\n   \"unsafe\"\n)\n\nfunc main() {\n   //C.CString将go string 转换成C string\n   s := C.CString(\"Hello, World\\n\")\n   // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n   // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n   // 而且这种内存泄露pprof 也定位不出来\n   defer C.free(unsafe.Pointer(s))\n   //C.puts 函数向标准输出窗口打印，\n   C.puts(s)\n}\n```\n\n虽然上面的代码有注释了，但是还是有一些需要特别注意的。\n\n1. 第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo\n\n   ```go\n   //#include <stdio.h>\n   //#include <stdlib.h>\n   import \"C\"\n   ```\n\n2. 第二个是main 函数里面的内容\n\n   ```go\n   func main() {\n      //C.CString将go string 转换成C string\n      s := C.CString(\"Hello, World\\n\")\n      // C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，\n      // 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，\n      // 而且这种内存泄露pprof 也定位不出来\n      defer C.free(unsafe.Pointer(s))\n      //C.puts 函数向标准输出窗口打印，\n      C.puts(s)\n   }\n   ```\n\n   - Go代码中的`s`变量在传递给c代码使用完成之后，需要调用`C.free`进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。\n\n     ![](/images/golang/string.jpg)\n\n     从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。\n\n     我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了\n\n     ```go\n     // Go string to C string\n     // The C string is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CString(string) *C.char\n     \n     // 这个文档上的大概意思是\n     // C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）\n     ```\n\n     我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。\n\n     ```go\n     // Go []byte slice to C array\n     // The C array is allocated in the C heap using malloc.\n     // It is the caller's responsibility to arrange for it to be\n     // freed, such as by calling C.free (be sure to include stdlib.h\n     // if C.free is needed).\n     func C.CBytes([]byte) unsafe.Pointer\n     \n     // C string to Go string\n     func C.GoString(*C.char) string\n     \n     // C data with explicit length to Go string\n     func C.GoStringN(*C.char, C.int) string\n     \n     // C data with explicit length to Go []byte\n     func C.GoBytes(unsafe.Pointer, C.int) []byte\n     ```\n\n     一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。\n     所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即`free`）传入的这份内存。\n     所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。\n\n     \n\n   - 其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过`unsafe.Pointer`获取原始指针进行传递。`unsafe.Pointer`是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。\n\nGo语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考[Go语言高级编程](https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html)\n\n### Go 和 C 之间的数组传递\n\n#### Go数组到C \n\n我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint loop(int** list_data, int leng, char** data)\n{\n  int* m = (int*)list_data;\n  int sum = 0;\n  for(int i=0; i<leng; i++)\n  {\n    sum += m[i];\n  }\n  *data = \"finised task\";\n  return sum;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc GoSilence2CArray() {\n\tvar ids = []int32{1, 2, 3, 5}\n\tvar res *C.char\n\tlength := C.int(len(ids))\n\tle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n}\nfunc main() {\n\tGoSilence2CArray()\n}\n```\n\n整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。\n\n```go\n//正确写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids[0])), length, &res)\n//错误写法\nle := C.loop((**C.int)(unsafe.Pointer(&ids)), length, &res)\n```\n\nSlice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&ids，那相当于把ids这个数据结构的地址处的数据强制转换为`(**C.int)`。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是`(**C.int)(unsafe.Pointer(&ids[0]))`。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)\n\n#### C数组到Go slice\n\n还是直接看例子\n\n```go\npackage main\n/*\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct{\n   char* name;\n}person;\n\nperson* get_person(int n){\n   person* ret = (person*)malloc(sizeof(person) * n);\n   for(int i=0;i<n;i++){\n      ret[i].name=\"wu\";\n   }\n   return ret;\n}\n*/\nimport \"C\" //该语句要单独写一行\nimport (\n\t\"unsafe\"\n\t\"fmt\"\n)\nfunc CArray2GoSilence() {\n\tsize := 2\n\tperson := C.get_person(C.int(size))\n\tperson_array := (*[1 << 30]C.person)(unsafe.Pointer(person))\n\tvar names []string\n\tfor i := 0; i < size; i++ {\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = append(names, name)\n\t}\n\tfor _, name := range names {\n\t\tfmt.Println(name)\n\t}\n\tC.free(unsafe.Pointer(person))\n}\nfunc main() {\n\tCArray2GoSilence()\n}\n```\n\nC语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。`(*[1 << 30]C.person)(unsafe.Pointer(person))` 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。\n\n### cgo利用pkg_config 使用第三方的so库\n\n#### pkg_config\n\n我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。**pkg-config** 是一个在[源代码](https://zh.wikipedia.org/wiki/源代码)[编译](https://zh.wikipedia.org/wiki/编译)时查询已安装的[库](https://zh.wikipedia.org/wiki/库)的使用接口的计算机工具[软件](https://zh.wikipedia.org/wiki/软件)。pkg-config原本是设计用于[Linux](https://zh.wikipedia.org/wiki/Linux)的，但现在在各个版本的[BSD](https://zh.wikipedia.org/wiki/BSD)、[windows](https://zh.wikipedia.org/wiki/Windows)、[Mac OS X](https://zh.wikipedia.org/wiki/Mac_OS_X)和[Solaris](https://zh.wikipedia.org/wiki/Solaris)上都有着可用的版本。\n\n那么pkg-config有什么作用呢？\n\n1. 检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。\n2. 获得编译预处理参数，如宏定义，头文件的位置。\n3. 得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。\n4. 自动加入所依赖的其它库的设置。\n\npkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于[libpng](https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1)的.pc文件的样例:\n\n```shell\nprefix=/usr/local\nexec_prefix=${prefix}\nlibdir=${exec_prefix}/lib\nincludedir=${exec_prefix}/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L${libdir} -lpng12 -lz\nCflags: -I${includedir}/libpng12\n```\n\n这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。\n\npkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。\n\n#### cgo 使用pkg-config\n\n我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分\n\n```go\npackage cgo\n// #cgo pkg-config: megproduct\n// #cgo CXXFLAGS: -std=c++11\n// #include \"plate.h\"\n// #include \"stdlib.h\"\nimport \"C\"\n//后续使用方法和go 调用C的方式一致了\n```\n\n我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。\n\n我们来看下megproduct.pc 是咋样的\n\n```shell\nprefix=/go/DATA/plate-sdk-190710\nlibdir=${prefix}/lib\nincludedir=${prefix}/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: ${libdir}/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I${includedir}\n```\n\n使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config\n\n\n\n本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。\n\n\n\n参考：[Go语言使用cgo时的内存管理笔记](https://www.pengrl.com/p/29054/)\n\n​\t\t\t[官方文档](https://golang.org/cmd/cgo/)\n\n​\t\t\t[slice的使用和内部结构](http://blog.golang.org/go-slices-usage-and-internals)","slug":"012_golang之cgo","published":1,"updated":"2021-03-10T06:16:56.348Z","_id":"ckm31tvuq000m17ym6lwtdn81","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。</p>\n<h3 id=\"cgo-的简单例子\"><a href=\"#cgo-的简单例子\" class=\"headerlink\" title=\"cgo 的简单例子\"></a>cgo 的简单例子</h3><p>让我们从一个简单的cgo 例子说起</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n\n<span class=\"hljs-keyword\">import</span> (\n   <span class=\"hljs-string\">&quot;unsafe&quot;</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<p>虽然上面的代码有注释了，但是还是有一些需要特别注意的。</p>\n<ol>\n<li><p>第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span></code></pre>\n</li>\n<li><p>第二个是main 函数里面的内容</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<ul>\n<li><p>Go代码中的<code>s</code>变量在传递给c代码使用完成之后，需要调用<code>C.free</code>进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。</p>\n<p><img src=\"/images/golang/string.jpg\"></p>\n<p>从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。</p>\n<p>我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go string to C string</span>\n<span class=\"hljs-comment\">// The C string is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CString</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>)</span> *<span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">char</span></span>\n\n<span class=\"hljs-comment\">// 这个文档上的大概意思是</span>\n<span class=\"hljs-comment\">// C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）</span></code></pre>\n\n<p>我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go []byte slice to C array</span>\n<span class=\"hljs-comment\">// The C array is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CBytes</span><span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">unsafe</span>.<span class=\"hljs-title\">Pointer</span></span>\n\n<span class=\"hljs-comment\">// C string to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoString</span><span class=\"hljs-params\">(*C.char)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoStringN</span><span class=\"hljs-params\">(*C.char, C.<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go []byte</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoBytes</span><span class=\"hljs-params\">(unsafe.Pointer, C.<span class=\"hljs-keyword\">int</span>)</span> []<span class=\"hljs-title\">byte</span></span></code></pre>\n\n<p>一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。<br>所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即<code>free</code>）传入的这份内存。<br>所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过<code>unsafe.Pointer</code>获取原始指针进行传递。<code>unsafe.Pointer</code>是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。</li>\n</ul>\n<p>Go语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考<a href=\"https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html\">Go语言高级编程</a></p>\n<h3 id=\"Go-和-C-之间的数组传递\"><a href=\"#Go-和-C-之间的数组传递\" class=\"headerlink\" title=\"Go 和 C 之间的数组传递\"></a>Go 和 C 之间的数组传递</h3><h4 id=\"Go数组到C\"><a href=\"#Go数组到C\" class=\"headerlink\" title=\"Go数组到C\"></a>Go数组到C</h4><p>我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">int loop(int** list_data, int leng, char** data)</span>\n<span class=\"hljs-comment\">&#123;</span>\n<span class=\"hljs-comment\">  int* m = (int*)list_data;</span>\n<span class=\"hljs-comment\">  int sum = 0;</span>\n<span class=\"hljs-comment\">  for(int i=0; i&lt;leng; i++)</span>\n<span class=\"hljs-comment\">  &#123;</span>\n<span class=\"hljs-comment\">    sum += m[i];</span>\n<span class=\"hljs-comment\">  &#125;</span>\n<span class=\"hljs-comment\">  *data = &quot;finised task&quot;;</span>\n<span class=\"hljs-comment\">  return sum;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GoSilence2CArray</span><span class=\"hljs-params\">()</span></span> &#123;\n\t<span class=\"hljs-keyword\">var</span> ids = []<span class=\"hljs-keyword\">int32</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>&#125;\n\t<span class=\"hljs-keyword\">var</span> res *C.char\n\tlength := C.<span class=\"hljs-keyword\">int</span>(<span class=\"hljs-built_in\">len</span>(ids))\n\tle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tGoSilence2CArray()\n&#125;</code></pre>\n\n<p>整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//正确写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n<span class=\"hljs-comment\">//错误写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids)), length, &amp;res)</code></pre>\n\n<p>Slice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&amp;ids，那相当于把ids这个数据结构的地址处的数据强制转换为<code>(**C.int)</code>。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是<code>(**C.int)(unsafe.Pointer(&amp;ids[0]))</code>。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看<a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n<h4 id=\"C数组到Go-slice\"><a href=\"#C数组到Go-slice\" class=\"headerlink\" title=\"C数组到Go slice\"></a>C数组到Go slice</h4><p>还是直接看例子</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">typedef struct&#123;</span>\n<span class=\"hljs-comment\">   char* name;</span>\n<span class=\"hljs-comment\">&#125;person;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">person* get_person(int n)&#123;</span>\n<span class=\"hljs-comment\">   person* ret = (person*)malloc(sizeof(person) * n);</span>\n<span class=\"hljs-comment\">   for(int i=0;i&lt;n;i++)&#123;</span>\n<span class=\"hljs-comment\">      ret[i].name=&quot;wu&quot;;</span>\n<span class=\"hljs-comment\">   &#125;</span>\n<span class=\"hljs-comment\">   return ret;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CArray2GoSilence</span><span class=\"hljs-params\">()</span></span> &#123;\n\tsize := <span class=\"hljs-number\">2</span>\n\tperson := C.get_person(C.<span class=\"hljs-keyword\">int</span>(size))\n\tperson_array := (*[<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">30</span>]C.person)(unsafe.Pointer(person))\n\t<span class=\"hljs-keyword\">var</span> names []<span class=\"hljs-keyword\">string</span>\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = <span class=\"hljs-built_in\">append</span>(names, name)\n\t&#125;\n\t<span class=\"hljs-keyword\">for</span> _, name := <span class=\"hljs-keyword\">range</span> names &#123;\n\t\tfmt.Println(name)\n\t&#125;\n\tC.free(unsafe.Pointer(person))\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tCArray2GoSilence()\n&#125;</code></pre>\n\n<p>C语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。<code>(*[1 &lt;&lt; 30]C.person)(unsafe.Pointer(person))</code> 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。</p>\n<h3 id=\"cgo利用pkg-config-使用第三方的so库\"><a href=\"#cgo利用pkg-config-使用第三方的so库\" class=\"headerlink\" title=\"cgo利用pkg_config 使用第三方的so库\"></a>cgo利用pkg_config 使用第三方的so库</h3><h4 id=\"pkg-config\"><a href=\"#pkg-config\" class=\"headerlink\" title=\"pkg_config\"></a>pkg_config</h4><p>我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。<strong>pkg-config</strong> 是一个在<a href=\"https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81\">源代码</a><a href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91\">编译</a>时查询已安装的<a href=\"https://zh.wikipedia.org/wiki/%E5%BA%93\">库</a>的使用接口的计算机工具<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6\">软件</a>。pkg-config原本是设计用于<a href=\"https://zh.wikipedia.org/wiki/Linux\">Linux</a>的，但现在在各个版本的<a href=\"https://zh.wikipedia.org/wiki/BSD\">BSD</a>、<a href=\"https://zh.wikipedia.org/wiki/Windows\">windows</a>、<a href=\"https://zh.wikipedia.org/wiki/Mac_OS_X\">Mac OS X</a>和<a href=\"https://zh.wikipedia.org/wiki/Solaris\">Solaris</a>上都有着可用的版本。</p>\n<p>那么pkg-config有什么作用呢？</p>\n<ol>\n<li>检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。</li>\n<li>获得编译预处理参数，如宏定义，头文件的位置。</li>\n<li>得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。</li>\n<li>自动加入所依赖的其它库的设置。</li>\n</ol>\n<p>pkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于<a href=\"https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1\">libpng</a>的.pc文件的样例:</p>\n<pre><code class=\"hljs shell\">prefix=/usr/local\nexec_prefix=$&#123;prefix&#125;\nlibdir=$&#123;exec_prefix&#125;/lib\nincludedir=$&#123;exec_prefix&#125;/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L$&#123;libdir&#125; -lpng12 -lz\nCflags: -I$&#123;includedir&#125;/libpng12</code></pre>\n\n<p>这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。</p>\n<p>pkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。</p>\n<h4 id=\"cgo-使用pkg-config\"><a href=\"#cgo-使用pkg-config\" class=\"headerlink\" title=\"cgo 使用pkg-config\"></a>cgo 使用pkg-config</h4><p>我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> cgo\n<span class=\"hljs-comment\">// #cgo pkg-config: megproduct</span>\n<span class=\"hljs-comment\">// #cgo CXXFLAGS: -std=c++11</span>\n<span class=\"hljs-comment\">// #include &quot;plate.h&quot;</span>\n<span class=\"hljs-comment\">// #include &quot;stdlib.h&quot;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span>\n<span class=\"hljs-comment\">//后续使用方法和go 调用C的方式一致了</span></code></pre>\n\n<p>我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。</p>\n<p>我们来看下megproduct.pc 是咋样的</p>\n<pre><code class=\"hljs shell\">prefix=/go/DATA/plate-sdk-190710\nlibdir=$&#123;prefix&#125;/lib\nincludedir=$&#123;prefix&#125;/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: $&#123;libdir&#125;/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I$&#123;includedir&#125;</code></pre>\n\n<p>使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config</p>\n<p>本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。</p>\n<p>参考：<a href=\"https://www.pengrl.com/p/29054/\">Go语言使用cgo时的内存管理笔记</a></p>\n<p>​            <a href=\"https://golang.org/cmd/cgo/\">官方文档</a></p>\n<p>​            <a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用golang开发有段时间，公司内部很多产品都是用golang开发的，除了底层核心的算法层是用C++ 写的，其他基本都是利用go进行封装对外提供给客户。由于底层是使用的是c++，上层使用的go，所以避免不了使用的cgo了。那什么是cgo呢？简单来说cgo支持创建调用C代码的Go包。下面我们来一步一步介绍cgo。</p>\n<h3 id=\"cgo-的简单例子\"><a href=\"#cgo-的简单例子\" class=\"headerlink\" title=\"cgo 的简单例子\"></a>cgo 的简单例子</h3><p>让我们从一个简单的cgo 例子说起</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n\n<span class=\"hljs-keyword\">import</span> (\n   <span class=\"hljs-string\">&quot;unsafe&quot;</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<p>虽然上面的代码有注释了，但是还是有一些需要特别注意的。</p>\n<ol>\n<li><p>第二行到第五行，需要注意的是#include 前面的//，不要认为是注释。这里的意思是引用了C的标准库。这个//的注释是叫preamble。必须和底下的import “C” 中间挨着不能有空行的。否则会导致后面的编译无法通过。当然除了//也可以使用/**/。同时这里的import “C” 需要和其他的import 隔开，并不能放到同一个import中，否则程序无法检测是否包含cgo</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span></code></pre>\n</li>\n<li><p>第二个是main 函数里面的内容</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n   <span class=\"hljs-comment\">//C.CString将go string 转换成C string</span>\n   s := C.CString(<span class=\"hljs-string\">&quot;Hello, World\\n&quot;</span>)\n   <span class=\"hljs-comment\">// C.CString() 返回的 C 字符串是在堆上新创建的并且不受 GC 的管理，</span>\n   <span class=\"hljs-comment\">// 使用完后需要自行调用 C.free() 释放，否则会造成内存泄露，</span>\n   <span class=\"hljs-comment\">// 而且这种内存泄露pprof 也定位不出来</span>\n   <span class=\"hljs-keyword\">defer</span> C.free(unsafe.Pointer(s))\n   <span class=\"hljs-comment\">//C.puts 函数向标准输出窗口打印，</span>\n   C.puts(s)\n&#125;</code></pre>\n\n<ul>\n<li><p>Go代码中的<code>s</code>变量在传递给c代码使用完成之后，需要调用<code>C.free</code>进行释放。首先我们需要先看下golang的字符串和C中的字符串在底层中的内存模型。</p>\n<p><img src=\"/images/golang/string.jpg\"></p>\n<p>从上图中我们可以看出golang 和 C 字符串在底层中的内存模型是不一样的。golang 字串符串并没有用 ‘\\0’ 终止符标识字符串的结束，因此直接将 golang 字符串底层数据指针传递给 C 函数是不行的。一种方案类似切片的传递一样将字符串数据指针和长度传递给 C 函数后，C 函数实现中自行申请一段内存拷贝字符串数据然后加上未层终止符后再使用。更好的方案是使用标准库提供的 C.CString()将 golang 的字符串转换成 C 字符串然后传递给 C 函数调用。</p>\n<p>我们看下官方文档对CString的说明。所以我们也就知道C.free的作用是什么了</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go string to C string</span>\n<span class=\"hljs-comment\">// The C string is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CString</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>)</span> *<span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">char</span></span>\n\n<span class=\"hljs-comment\">// 这个文档上的大概意思是</span>\n<span class=\"hljs-comment\">// C string在C的堆上使用malloc申请。调用者有责任在合适的时候对该字符串进行释放，释放方式可以是调用C.free（调用C.free需包含stdlib.h）</span></code></pre>\n\n<p>我们来看看其他几种C类型和Go类型相互转换的。可以看出CBytes 也是需要我们手动free的。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// Go []byte slice to C array</span>\n<span class=\"hljs-comment\">// The C array is allocated in the C heap using malloc.</span>\n<span class=\"hljs-comment\">// It is the caller&#x27;s responsibility to arrange for it to be</span>\n<span class=\"hljs-comment\">// freed, such as by calling C.free (be sure to include stdlib.h</span>\n<span class=\"hljs-comment\">// if C.free is needed).</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">CBytes</span><span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">unsafe</span>.<span class=\"hljs-title\">Pointer</span></span>\n\n<span class=\"hljs-comment\">// C string to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoString</span><span class=\"hljs-params\">(*C.char)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go string</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoStringN</span><span class=\"hljs-params\">(*C.char, C.<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span>\n\n<span class=\"hljs-comment\">// C data with explicit length to Go []byte</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span>.<span class=\"hljs-title\">GoBytes</span><span class=\"hljs-params\">(unsafe.Pointer, C.<span class=\"hljs-keyword\">int</span>)</span> []<span class=\"hljs-title\">byte</span></span></code></pre>\n\n<p>一般来说，c语言里都是秉承哪个模块申请就由哪个模块释放的原则，因为跨库申请释放可能由于各自链接的内存管理库不一致导致出现难以排查的bug。并且换个角度来说，被调用模块也无法知道传入的内存是在堆上申请还是栈上申请的，是否需要释放。<br>所以Go传入c模块的内存，c模块也许会对这块内存再次进行拷贝，但是c模块肯定不会释放（即<code>free</code>）传入的这份内存。<br>所以，一般来说，Go在调用完c函数之后，Go需要释放拷贝生成的这块内存。</p>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>其中需要留意的是unsafe.Pointer 这个函数。消除内存拷贝可以通过<code>unsafe.Pointer</code>获取原始指针进行传递。<code>unsafe.Pointer</code>是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。</li>\n</ul>\n<p>Go语言中数值类型和C语言数据类型基本上是相似的。但是还是有不同的。这里就不详细介绍了。更多的cgo 类型装换可以参考<a href=\"https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-03-cgo-types.html\">Go语言高级编程</a></p>\n<h3 id=\"Go-和-C-之间的数组传递\"><a href=\"#Go-和-C-之间的数组传递\" class=\"headerlink\" title=\"Go 和 C 之间的数组传递\"></a>Go 和 C 之间的数组传递</h3><h4 id=\"Go数组到C\"><a href=\"#Go数组到C\" class=\"headerlink\" title=\"Go数组到C\"></a>Go数组到C</h4><p>我们还是直接来看下例子。我们在C 中遍历数组，并计算数组内值的和。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">int loop(int** list_data, int leng, char** data)</span>\n<span class=\"hljs-comment\">&#123;</span>\n<span class=\"hljs-comment\">  int* m = (int*)list_data;</span>\n<span class=\"hljs-comment\">  int sum = 0;</span>\n<span class=\"hljs-comment\">  for(int i=0; i&lt;leng; i++)</span>\n<span class=\"hljs-comment\">  &#123;</span>\n<span class=\"hljs-comment\">    sum += m[i];</span>\n<span class=\"hljs-comment\">  &#125;</span>\n<span class=\"hljs-comment\">  *data = &quot;finised task&quot;;</span>\n<span class=\"hljs-comment\">  return sum;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GoSilence2CArray</span><span class=\"hljs-params\">()</span></span> &#123;\n\t<span class=\"hljs-keyword\">var</span> ids = []<span class=\"hljs-keyword\">int32</span>&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>&#125;\n\t<span class=\"hljs-keyword\">var</span> res *C.char\n\tlength := C.<span class=\"hljs-keyword\">int</span>(<span class=\"hljs-built_in\">len</span>(ids))\n\tle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n\tfmt.Println(le)\n\tfmt.Println(C.GoString(res))\n\tfmt.Println(ids)\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tGoSilence2CArray()\n&#125;</code></pre>\n\n<p>整个例子需要注意的就是调用C.loop 函数的时候，将Go中的Slice传给C函数。其中最重要的loop的第一个参数，将数组转换的代码了。我们来看以下使用loop函数的写法。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">//正确写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids[<span class=\"hljs-number\">0</span>])), length, &amp;res)\n<span class=\"hljs-comment\">//错误写法</span>\nle := C.loop((**C.<span class=\"hljs-keyword\">int</span>)(unsafe.Pointer(&amp;ids)), length, &amp;res)</code></pre>\n\n<p>Slice在Go中实际上不是一个完全意义上的数组，它只是一种数据结构，带有若干头部。如果直接&amp;ids，那相当于把ids这个数据结构的地址处的数据强制转换为<code>(**C.int)</code>。这样导致的后果完全不可期，运行时core掉是再正常不过的后果。所以正确的写法应该是<code>(**C.int)(unsafe.Pointer(&amp;ids[0]))</code>。从slice的第一个元素地址开始。对于slice的内部数据结构可以查看<a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n<h4 id=\"C数组到Go-slice\"><a href=\"#C数组到Go-slice\" class=\"headerlink\" title=\"C数组到Go slice\"></a>C数组到Go slice</h4><p>还是直接看例子</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-comment\">/*</span>\n<span class=\"hljs-comment\">#include &lt;stdio.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;string.h&gt;</span>\n<span class=\"hljs-comment\">#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">typedef struct&#123;</span>\n<span class=\"hljs-comment\">   char* name;</span>\n<span class=\"hljs-comment\">&#125;person;</span>\n<span class=\"hljs-comment\"></span>\n<span class=\"hljs-comment\">person* get_person(int n)&#123;</span>\n<span class=\"hljs-comment\">   person* ret = (person*)malloc(sizeof(person) * n);</span>\n<span class=\"hljs-comment\">   for(int i=0;i&lt;n;i++)&#123;</span>\n<span class=\"hljs-comment\">      ret[i].name=&quot;wu&quot;;</span>\n<span class=\"hljs-comment\">   &#125;</span>\n<span class=\"hljs-comment\">   return ret;</span>\n<span class=\"hljs-comment\">&#125;</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-comment\">//该语句要单独写一行</span>\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;unsafe&quot;</span>\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CArray2GoSilence</span><span class=\"hljs-params\">()</span></span> &#123;\n\tsize := <span class=\"hljs-number\">2</span>\n\tperson := C.get_person(C.<span class=\"hljs-keyword\">int</span>(size))\n\tperson_array := (*[<span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">30</span>]C.person)(unsafe.Pointer(person))\n\t<span class=\"hljs-keyword\">var</span> names []<span class=\"hljs-keyword\">string</span>\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; size; i++ &#123;\n\t\tname := C.GoString(person_array[i].name)\n\t\tnames = <span class=\"hljs-built_in\">append</span>(names, name)\n\t&#125;\n\t<span class=\"hljs-keyword\">for</span> _, name := <span class=\"hljs-keyword\">range</span> names &#123;\n\t\tfmt.Println(name)\n\t&#125;\n\tC.free(unsafe.Pointer(person))\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tCArray2GoSilence()\n&#125;</code></pre>\n\n<p>C语言中的数组与Go语言中的数组差异较大，后者是值类型，而前者与C中的指针大部分场合都可以随意转换。目前似乎无法直接显式的在两者之间进行转型，官方文档也没有说明。但我们可以通过编写转换函数，将C的数组转换为Go的Slice。<code>(*[1 &lt;&lt; 30]C.person)(unsafe.Pointer(person))</code> 是获取足够大的内存地址，然后通过遍历该数组的地址。获取数组的元素。可以在for中将元素添加到slice中。</p>\n<h3 id=\"cgo利用pkg-config-使用第三方的so库\"><a href=\"#cgo利用pkg-config-使用第三方的so库\" class=\"headerlink\" title=\"cgo利用pkg_config 使用第三方的so库\"></a>cgo利用pkg_config 使用第三方的so库</h3><h4 id=\"pkg-config\"><a href=\"#pkg-config\" class=\"headerlink\" title=\"pkg_config\"></a>pkg_config</h4><p>我们在使用第三方库的时候就少不了使用第三方库的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库的位置。<strong>pkg-config</strong> 是一个在<a href=\"https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81\">源代码</a><a href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91\">编译</a>时查询已安装的<a href=\"https://zh.wikipedia.org/wiki/%E5%BA%93\">库</a>的使用接口的计算机工具<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6\">软件</a>。pkg-config原本是设计用于<a href=\"https://zh.wikipedia.org/wiki/Linux\">Linux</a>的，但现在在各个版本的<a href=\"https://zh.wikipedia.org/wiki/BSD\">BSD</a>、<a href=\"https://zh.wikipedia.org/wiki/Windows\">windows</a>、<a href=\"https://zh.wikipedia.org/wiki/Mac_OS_X\">Mac OS X</a>和<a href=\"https://zh.wikipedia.org/wiki/Solaris\">Solaris</a>上都有着可用的版本。</p>\n<p>那么pkg-config有什么作用呢？</p>\n<ol>\n<li>检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。</li>\n<li>获得编译预处理参数，如宏定义，头文件的位置。</li>\n<li>得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。</li>\n<li>自动加入所依赖的其它库的设置。</li>\n</ol>\n<p>pkg-config是如和得到这些信息呢？为了让pkg-config可以得到这些信息，要求库的提供者，提供一个.pc文件。以下是这是一个用于<a href=\"https://zh.wikipedia.org/w/index.php?title=Libpng&action=edit&redlink=1\">libpng</a>的.pc文件的样例:</p>\n<pre><code class=\"hljs shell\">prefix=/usr/local\nexec_prefix=$&#123;prefix&#125;\nlibdir=$&#123;exec_prefix&#125;/lib\nincludedir=$&#123;exec_prefix&#125;/include\n  \nName: libpng12\nDescription: Loads and saves PNG files\nVersion: 1.2.8\nLibs: -L$&#123;libdir&#125; -lpng12 -lz\nCflags: -I$&#123;includedir&#125;/libpng12</code></pre>\n\n<p>这个文件告诉我们这些库可以在/usr/local/lib找到，头文件可以在/usr/local/include里找到，库的名字是libpng12并且版本号是1.2.8。它也提供了用于编译依赖于libpng的源代码时需要的链接器参数。</p>\n<p>pkg-config默认会去/usr/local/lib/pkgconfig目录下，寻找.pc文件。</p>\n<h4 id=\"cgo-使用pkg-config\"><a href=\"#cgo-使用pkg-config\" class=\"headerlink\" title=\"cgo 使用pkg-config\"></a>cgo 使用pkg-config</h4><p>我们先来看下cgo 中使用pkg-config的例子。以下是我做餐盘识别项目中涉及到cgo部分</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> cgo\n<span class=\"hljs-comment\">// #cgo pkg-config: megproduct</span>\n<span class=\"hljs-comment\">// #cgo CXXFLAGS: -std=c++11</span>\n<span class=\"hljs-comment\">// #include &quot;plate.h&quot;</span>\n<span class=\"hljs-comment\">// #include &quot;stdlib.h&quot;</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;C&quot;</span>\n<span class=\"hljs-comment\">//后续使用方法和go 调用C的方式一致了</span></code></pre>\n\n<p>我们可以看到cgo有配置pkg-config的配置文件megproduct.pc，这个pc文件可以放在/usr/local/lib/pkgconfig目录下，也可以将其添加到环境变量PKG_CONFIG_PATH中。根据megproduct.pc 查找库的头文件和so文件。</p>\n<p>我们来看下megproduct.pc 是咋样的</p>\n<pre><code class=\"hljs shell\">prefix=/go/DATA/plate-sdk-190710\nlibdir=$&#123;prefix&#125;/lib\nincludedir=$&#123;prefix&#125;/include\n\nName: megproduct\nDescription: megproduct, built in megproduct\nVersion: 1.1\nRequires:\nLibs: $&#123;libdir&#125;/libmegproduct.so\nLibs.private: -Wl,--push-state,--as-needed,-lpthread,-lrt,-ldl,-lm,--pop-state\nCflags: -I$&#123;includedir&#125;</code></pre>\n\n<p>使用pkg-config少了很多配置的文件。所以如果使用第三方库进行cgo 开发还是建议使用pkg-config</p>\n<p>本篇文章更多讲的是cgo的使用，并没有涉及到底层cgo的内部实现，后续如果有时间会对cgo 底层的实现讲解。</p>\n<p>参考：<a href=\"https://www.pengrl.com/p/29054/\">Go语言使用cgo时的内存管理笔记</a></p>\n<p>​            <a href=\"https://golang.org/cmd/cgo/\">官方文档</a></p>\n<p>​            <a href=\"http://blog.golang.org/go-slices-usage-and-internals\">slice的使用和内部结构</a></p>\n"},{"title":"golang 之 slice & defer 关键字","date":"2018-09-10T11:53:22.000Z","index_img":["/images/golang/013_go_0.jpg"],"_content":"\n今天我们讲讲golang的slice和defer。\n\nslice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。\n\n在正式开始讲slice之前我们来说一说golang 中的`defer`，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？\n\n```go\npackage main\nimport \"fmt\"\nfunc f() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\nfunc f2() (r int) {\n\tt := 5\n\tdefer func() {\n\t\tt = t + 5\n\t}()\n\treturn t\n}\nfunc f3() (r int) {\n\tdefer func(r int) {\n\t\tr = r + 5\n\t}(r)\n\treturn 1\n}\n\nfunc main() {\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n}\n```\n\n答案留在最后讲解\n\n### slice\n\n#### 数组\n\n在说slice之前，我们先来了解下数组。\n\n数组是指定长度和元素类型的数据集合。比如以下数组\n\n```go\nvar intArr [3]int//创建了长度为3的int数组\na[0]=1 //根据索引访问元素\nfmt.println(a[1])//int 类型数组默认值为0\n```\n\n数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。\n\n#### slice\n\n在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义\n\n```go\ntype slice struct {\n\tarray unsafe.Pointer// 指向底层数组的指针\n\tlen   int// 长度，切片可用元素的个数，slice的下标不能超过长度 \n\tcap   int// 容量 >= 长度，在底层不扩容的情况下，cap是len的最大限度\n}\n```\n\n需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。\n\n##### slice的扩容\n\n在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的\n\n```go\n// growslice handles slice growth during append.\n// It is passed the slice element type, the old slice, and the desired new minimum capacity,\n// and it returns a new slice with at least that capacity, with the old data\n// copied into it.\n// The new slice's length is set to the old slice's length,\n// NOT to the new requested capacity.\n// This is for codegen convenience. The old slice's length is used immediately\n// to calculate where to write new values during an append.\n// TODO: When the old backend is gone, reconsider this decision.\n// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.\nfunc growslice(et *_type, old slice, cap int) slice {\n\t//忽略部分源码\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\t// Check 0 < newcap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// Set newcap to the requested cap when\n\t\t\t// the newcap calculation overflowed.\n\t\t\tif newcap <= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n//忽略部分源码\n\treturn slice{p, old.len, newcap}\n}\n```\n\n当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是\n\n- 如果新的大小是当前大小2倍以上，则大小增长为新大小\n- 如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。\n\n扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 `growslice` 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。\n\n##### nil slice 和空slice\n\nnil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。\n\n而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。\n\nnil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 `nil` 切片。\n\n| 创建方式  | nil切片              | 空切片                  |\n| --------- | -------------------- | ----------------------- |\n| 方式一    | var s1 []int         | var s2 = []int{}        |\n| 方式二    | var s4 = *new([]int) | var s3 = make([]int, 0) |\n| 长度      | 0                    | 0                       |\n| 容量      | 0                    | 0                       |\n| 和nil比较 | true                 | false                   |\n\n#### slice 和unsafe.Pointer相互转换\n\n在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。\n\n我们先来看看从slice中获取一块内存地址\n\n```go\nslice:=make([]int,10)\nptr:=unsafe.Pointer(&slice[0])//获取数组中第一个元素的内存地址\n```\n\n从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式\n\n第一种，先将`ptr`强制类型转换为另一种指针，一个指向`[1<<10]int`数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是`s`就是一个10个元素的slice。\n\n```go\nvar ptr unsafe.Pointer\ns := ((*[1<<10]int)(ptr))[:10]\n```\n\n第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1<<10意思是相同的\n\n```go\nvar ptr unsafe.Pointer\nvar s1 = struct {\n    addr uintptr\n    len int\n    cap int\n}{ptr, length, length}\ns := *(*[]byte)(unsafe.Pointer(&s1))\n```\n\n第三种方法，通过reflect.SliceHeader的方式来构造slice。\n\n```go\nvar o []byte\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = uintptr(ptr)\n```\n\n### defer\n\n不知道你是否得出文章开始代码的正确结果呢？\n\n `defer` 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解**return xxx这一条语句并不是一条原子指令!**\n\n函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。\n\ndefer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。\n\n其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:\n\n```shell\n返回值 = xxx\n调用defer函数\n空的return\n```\n\n 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码\n\n```go\nfunc f() (result int) {\n\tresult = 0 //return语句不是一条原子调用，return xxx其实是赋值＋ret指令\n\tfunc() { //defer被插入到return之前执行，也就是赋返回值和ret指令之间\n\t\tresult++\n\t}()\n\treturn\n}\nfunc f2() (r int) {\n\tt := 5\n\tr = t //赋值指令\n\tfunc() { //defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过\n\t\tt = t + 5\n\t}()\n\treturn //空的return指令\n}\nfunc f3() (r int) {\n\tr = 1 //给返回值赋值\n\tfunc(r int) { //这里改的r是传值传进去的r，不会改变要返回的那个r值\n\t\tr = r + 5\n\t}(r)\n\treturn //空的return\n}\n```\n\n接下来我们来看看另外一小段代码\n\n```go\nfunc main(){\n  startedAt := time.Now()\n\tdefer fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n}\n//输出结果并不是1s，而是几百纳秒\n```\n\n上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 `defer` 关键字会立刻对函数中引用的外部参数进行拷贝，所以 `time.Since(startedAt)` 的结果不是在 `main` 函数退出之前计算的，而是在 `defer` 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下`defer` 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。\n\n\n\n参考：[深入解析go中slice底层实现](https://halfrost.com/go_slice/)\n\n[深度解析Go语音之slice](https://www.cnblogs.com/qcrao-2018/p/10631989.html)\n\n[深入解析Go](https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html)\n\n","source":"_posts/013_golang之slice_map.md","raw":"---\ntitle: golang 之 slice & defer 关键字\ndate: 2018-09-10 19:53:22\nindex_img:\n- /images/golang/013_go_0.jpg\ntags: \n- golang\ncategories:\n- golang\n---\n\n今天我们讲讲golang的slice和defer。\n\nslice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。\n\n在正式开始讲slice之前我们来说一说golang 中的`defer`，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？\n\n```go\npackage main\nimport \"fmt\"\nfunc f() (result int) {\n\tdefer func() {\n\t\tresult++\n\t}()\n\treturn 0\n}\nfunc f2() (r int) {\n\tt := 5\n\tdefer func() {\n\t\tt = t + 5\n\t}()\n\treturn t\n}\nfunc f3() (r int) {\n\tdefer func(r int) {\n\t\tr = r + 5\n\t}(r)\n\treturn 1\n}\n\nfunc main() {\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n}\n```\n\n答案留在最后讲解\n\n### slice\n\n#### 数组\n\n在说slice之前，我们先来了解下数组。\n\n数组是指定长度和元素类型的数据集合。比如以下数组\n\n```go\nvar intArr [3]int//创建了长度为3的int数组\na[0]=1 //根据索引访问元素\nfmt.println(a[1])//int 类型数组默认值为0\n```\n\n数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。\n\n#### slice\n\n在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义\n\n```go\ntype slice struct {\n\tarray unsafe.Pointer// 指向底层数组的指针\n\tlen   int// 长度，切片可用元素的个数，slice的下标不能超过长度 \n\tcap   int// 容量 >= 长度，在底层不扩容的情况下，cap是len的最大限度\n}\n```\n\n需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。\n\n##### slice的扩容\n\n在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的\n\n```go\n// growslice handles slice growth during append.\n// It is passed the slice element type, the old slice, and the desired new minimum capacity,\n// and it returns a new slice with at least that capacity, with the old data\n// copied into it.\n// The new slice's length is set to the old slice's length,\n// NOT to the new requested capacity.\n// This is for codegen convenience. The old slice's length is used immediately\n// to calculate where to write new values during an append.\n// TODO: When the old backend is gone, reconsider this decision.\n// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.\nfunc growslice(et *_type, old slice, cap int) slice {\n\t//忽略部分源码\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\t// Check 0 < newcap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// Set newcap to the requested cap when\n\t\t\t// the newcap calculation overflowed.\n\t\t\tif newcap <= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n//忽略部分源码\n\treturn slice{p, old.len, newcap}\n}\n```\n\n当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是\n\n- 如果新的大小是当前大小2倍以上，则大小增长为新大小\n- 如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。\n\n扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 `growslice` 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。\n\n##### nil slice 和空slice\n\nnil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。\n\n而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。\n\nnil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 `nil` 切片。\n\n| 创建方式  | nil切片              | 空切片                  |\n| --------- | -------------------- | ----------------------- |\n| 方式一    | var s1 []int         | var s2 = []int{}        |\n| 方式二    | var s4 = *new([]int) | var s3 = make([]int, 0) |\n| 长度      | 0                    | 0                       |\n| 容量      | 0                    | 0                       |\n| 和nil比较 | true                 | false                   |\n\n#### slice 和unsafe.Pointer相互转换\n\n在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。\n\n我们先来看看从slice中获取一块内存地址\n\n```go\nslice:=make([]int,10)\nptr:=unsafe.Pointer(&slice[0])//获取数组中第一个元素的内存地址\n```\n\n从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式\n\n第一种，先将`ptr`强制类型转换为另一种指针，一个指向`[1<<10]int`数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是`s`就是一个10个元素的slice。\n\n```go\nvar ptr unsafe.Pointer\ns := ((*[1<<10]int)(ptr))[:10]\n```\n\n第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1<<10意思是相同的\n\n```go\nvar ptr unsafe.Pointer\nvar s1 = struct {\n    addr uintptr\n    len int\n    cap int\n}{ptr, length, length}\ns := *(*[]byte)(unsafe.Pointer(&s1))\n```\n\n第三种方法，通过reflect.SliceHeader的方式来构造slice。\n\n```go\nvar o []byte\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = uintptr(ptr)\n```\n\n### defer\n\n不知道你是否得出文章开始代码的正确结果呢？\n\n `defer` 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解**return xxx这一条语句并不是一条原子指令!**\n\n函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。\n\ndefer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。\n\n其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:\n\n```shell\n返回值 = xxx\n调用defer函数\n空的return\n```\n\n 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码\n\n```go\nfunc f() (result int) {\n\tresult = 0 //return语句不是一条原子调用，return xxx其实是赋值＋ret指令\n\tfunc() { //defer被插入到return之前执行，也就是赋返回值和ret指令之间\n\t\tresult++\n\t}()\n\treturn\n}\nfunc f2() (r int) {\n\tt := 5\n\tr = t //赋值指令\n\tfunc() { //defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过\n\t\tt = t + 5\n\t}()\n\treturn //空的return指令\n}\nfunc f3() (r int) {\n\tr = 1 //给返回值赋值\n\tfunc(r int) { //这里改的r是传值传进去的r，不会改变要返回的那个r值\n\t\tr = r + 5\n\t}(r)\n\treturn //空的return\n}\n```\n\n接下来我们来看看另外一小段代码\n\n```go\nfunc main(){\n  startedAt := time.Now()\n\tdefer fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n}\n//输出结果并不是1s，而是几百纳秒\n```\n\n上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 `defer` 关键字会立刻对函数中引用的外部参数进行拷贝，所以 `time.Since(startedAt)` 的结果不是在 `main` 函数退出之前计算的，而是在 `defer` 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下`defer` 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。\n\n\n\n参考：[深入解析go中slice底层实现](https://halfrost.com/go_slice/)\n\n[深度解析Go语音之slice](https://www.cnblogs.com/qcrao-2018/p/10631989.html)\n\n[深入解析Go](https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html)\n\n","slug":"013_golang之slice_map","published":1,"updated":"2021-03-10T06:19:48.980Z","_id":"ckm31xp90000p17ym38ti1zp2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天我们讲讲golang的slice和defer。</p>\n<p>slice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。</p>\n<p>在正式开始讲slice之前我们来说一说golang 中的<code>defer</code>，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> t\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n&#125;</code></pre>\n\n<p>答案留在最后讲解</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>在说slice之前，我们先来了解下数组。</p>\n<p>数组是指定长度和元素类型的数据集合。比如以下数组</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> intArr [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">//创建了长度为3的int数组</span>\na[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//根据索引访问元素</span>\nfmt.<span class=\"hljs-built_in\">println</span>(a[<span class=\"hljs-number\">1</span>])<span class=\"hljs-comment\">//int 类型数组默认值为0</span></code></pre>\n\n<p>数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。</p>\n<h4 id=\"slice-1\"><a href=\"#slice-1\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p>在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> slice <span class=\"hljs-keyword\">struct</span> &#123;\n\tarray unsafe.Pointer<span class=\"hljs-comment\">// 指向底层数组的指针</span>\n\t<span class=\"hljs-built_in\">len</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 长度，切片可用元素的个数，slice的下标不能超过长度 </span>\n\t<span class=\"hljs-built_in\">cap</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 容量 &gt;= 长度，在底层不扩容的情况下，cap是len的最大限度</span>\n&#125;</code></pre>\n\n<p>需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。</p>\n<h5 id=\"slice的扩容\"><a href=\"#slice的扩容\" class=\"headerlink\" title=\"slice的扩容\"></a>slice的扩容</h5><p>在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// growslice handles slice growth during append.</span>\n<span class=\"hljs-comment\">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span>\n<span class=\"hljs-comment\">// and it returns a new slice with at least that capacity, with the old data</span>\n<span class=\"hljs-comment\">// copied into it.</span>\n<span class=\"hljs-comment\">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span>\n<span class=\"hljs-comment\">// NOT to the new requested capacity.</span>\n<span class=\"hljs-comment\">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span>\n<span class=\"hljs-comment\">// to calculate where to write new values during an append.</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> When the old backend is gone, reconsider this decision.</span>\n<span class=\"hljs-comment\">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">growslice</span><span class=\"hljs-params\">(et *_type, old slice, <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">slice</span></span> &#123;\n\t<span class=\"hljs-comment\">//忽略部分源码</span>\n\tnewcap := old.<span class=\"hljs-built_in\">cap</span>\n\tdoublecap := newcap + newcap\n\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">cap</span> &gt; doublecap &#123;\n\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t<span class=\"hljs-keyword\">if</span> old.<span class=\"hljs-built_in\">len</span> &lt; <span class=\"hljs-number\">1024</span> &#123;\n\t\t\tnewcap = doublecap\n\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t\t<span class=\"hljs-comment\">// Check 0 &lt; newcap to detect overflow</span>\n\t\t\t<span class=\"hljs-comment\">// and prevent an infinite loop.</span>\n\t\t\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class=\"hljs-built_in\">cap</span> &#123;\n\t\t\t\tnewcap += newcap / <span class=\"hljs-number\">4</span>\n\t\t\t&#125;\n\t\t\t<span class=\"hljs-comment\">// Set newcap to the requested cap when</span>\n\t\t\t<span class=\"hljs-comment\">// the newcap calculation overflowed.</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> newcap &lt;= <span class=\"hljs-number\">0</span> &#123;\n\t\t\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n<span class=\"hljs-comment\">//忽略部分源码</span>\n\t<span class=\"hljs-keyword\">return</span> slice&#123;p, old.<span class=\"hljs-built_in\">len</span>, newcap&#125;\n&#125;</code></pre>\n\n<p>当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是</p>\n<ul>\n<li>如果新的大小是当前大小2倍以上，则大小增长为新大小</li>\n<li>如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</li>\n</ul>\n<p>扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p>\n<h5 id=\"nil-slice-和空slice\"><a href=\"#nil-slice-和空slice\" class=\"headerlink\" title=\"nil slice 和空slice\"></a>nil slice 和空slice</h5><p>nil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。</p>\n<p>而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。</p>\n<p>nil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p>\n<table>\n<thead>\n<tr>\n<th>创建方式</th>\n<th>nil切片</th>\n<th>空切片</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>方式一</td>\n<td>var s1 []int</td>\n<td>var s2 = []int{}</td>\n</tr>\n<tr>\n<td>方式二</td>\n<td>var s4 = *new([]int)</td>\n<td>var s3 = make([]int, 0)</td>\n</tr>\n<tr>\n<td>长度</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>容量</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>和nil比较</td>\n<td>true</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"slice-和unsafe-Pointer相互转换\"><a href=\"#slice-和unsafe-Pointer相互转换\" class=\"headerlink\" title=\"slice 和unsafe.Pointer相互转换\"></a>slice 和unsafe.Pointer相互转换</h4><p>在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。</p>\n<p>我们先来看看从slice中获取一块内存地址</p>\n<pre><code class=\"hljs go\">slice:=<span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-number\">10</span>)\nptr:=unsafe.Pointer(&amp;slice[<span class=\"hljs-number\">0</span>])<span class=\"hljs-comment\">//获取数组中第一个元素的内存地址</span></code></pre>\n\n<p>从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式</p>\n<p>第一种，先将<code>ptr</code>强制类型转换为另一种指针，一个指向<code>[1&lt;&lt;10]int</code>数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是<code>s</code>就是一个10个元素的slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\ns := ((*[<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">10</span>]<span class=\"hljs-keyword\">int</span>)(ptr))[:<span class=\"hljs-number\">10</span>]</code></pre>\n\n<p>第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1&lt;&lt;10意思是相同的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\n<span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">struct</span> &#123;\n    addr <span class=\"hljs-keyword\">uintptr</span>\n    <span class=\"hljs-built_in\">len</span> <span class=\"hljs-keyword\">int</span>\n    <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>\n&#125;&#123;ptr, length, length&#125;\ns := *(*[]<span class=\"hljs-keyword\">byte</span>)(unsafe.Pointer(&amp;s1))</code></pre>\n\n<p>第三种方法，通过reflect.SliceHeader的方式来构造slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> o []<span class=\"hljs-keyword\">byte</span>\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = <span class=\"hljs-keyword\">uintptr</span>(ptr)</code></pre>\n\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p>不知道你是否得出文章开始代码的正确结果呢？</p>\n<p> <code>defer</code> 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解<strong>return xxx这一条语句并不是一条原子指令!</strong></p>\n<p>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</p>\n<p>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。</p>\n<p>其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:</p>\n<pre><code class=\"hljs shell\">返回值 = xxx\n调用defer函数\n空的return</code></pre>\n\n<p> 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tresult = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">//return语句不是一条原子调用，return xxx其实是赋值＋ret指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到return之前执行，也就是赋返回值和ret指令之间</span>\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\tr = t <span class=\"hljs-comment\">//赋值指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span>\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return指令</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tr = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//给返回值赋值</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123; <span class=\"hljs-comment\">//这里改的r是传值传进去的r，不会改变要返回的那个r值</span>\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return</span>\n&#125;</code></pre>\n\n<p>接下来我们来看看另外一小段代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;\n  startedAt := time.Now()\n\t<span class=\"hljs-keyword\">defer</span> fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n&#125;\n<span class=\"hljs-comment\">//输出结果并不是1s，而是几百纳秒</span></code></pre>\n\n<p>上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻对函数中引用的外部参数进行拷贝，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下<code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。</p>\n<p>参考：<a href=\"https://halfrost.com/go_slice/\">深入解析go中slice底层实现</a></p>\n<p><a href=\"https://www.cnblogs.com/qcrao-2018/p/10631989.html\">深度解析Go语音之slice</a></p>\n<p><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">深入解析Go</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天我们讲讲golang的slice和defer。</p>\n<p>slice是go里面一个很重要的数据结构，使用这种结构来管理数据集合。slice 类似其他语言中的数组，但是又有一些其他不同的属性。</p>\n<p>在正式开始讲slice之前我们来说一说golang 中的<code>defer</code>，原本觉得自己对defer有一定了解了。但是昨天看了一本书，才发现自己对defer 的了解是这么浅，在没有运行以下代码前你能否得出正确答案呢？运行代码之后能否回答为什么？</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123;\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> t\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;\n\tfmt.Println(f())\n\tfmt.Println(f2())\n\tfmt.Println(f3())\n&#125;</code></pre>\n\n<p>答案留在最后讲解</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>在说slice之前，我们先来了解下数组。</p>\n<p>数组是指定长度和元素类型的数据集合。比如以下数组</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> intArr [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">//创建了长度为3的int数组</span>\na[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//根据索引访问元素</span>\nfmt.<span class=\"hljs-built_in\">println</span>(a[<span class=\"hljs-number\">1</span>])<span class=\"hljs-comment\">//int 类型数组默认值为0</span></code></pre>\n\n<p>数组不需要显式初始化。Go的数组是值类型。数组变量表示整个数组，它不是指向数组的第一个元素的指针，这就意味着赋值和函数传参操作时，将会复制数组的内容（后续和slice对比，slice是创建指针指向地址）。可以写一个简单的程序将数组的地址打印出来，进行对比。</p>\n<h4 id=\"slice-1\"><a href=\"#slice-1\" class=\"headerlink\" title=\"slice\"></a>slice</h4><p>在实际使用中我们很少使用到数组，因为数组不够灵活。比如：一旦数组中的数据足够大，每次使用数组都要重新复制一遍，耗费大量内存和时间。slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。我们来看下slice在源码中的定义</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">type</span> slice <span class=\"hljs-keyword\">struct</span> &#123;\n\tarray unsafe.Pointer<span class=\"hljs-comment\">// 指向底层数组的指针</span>\n\t<span class=\"hljs-built_in\">len</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 长度，切片可用元素的个数，slice的下标不能超过长度 </span>\n\t<span class=\"hljs-built_in\">cap</span>   <span class=\"hljs-keyword\">int</span><span class=\"hljs-comment\">// 容量 &gt;= 长度，在底层不扩容的情况下，cap是len的最大限度</span>\n&#125;</code></pre>\n\n<p>需要注意的是：底层数组是可以被多个slice同时指向的，也就是对一个slice的元素进行修改会影响到其他的slice。</p>\n<h5 id=\"slice的扩容\"><a href=\"#slice的扩容\" class=\"headerlink\" title=\"slice的扩容\"></a>slice的扩容</h5><p>在对slice进行append等操作时，可能会造成slice的自动扩容。我们来看下源码是怎么扩容的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-comment\">// growslice handles slice growth during append.</span>\n<span class=\"hljs-comment\">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span>\n<span class=\"hljs-comment\">// and it returns a new slice with at least that capacity, with the old data</span>\n<span class=\"hljs-comment\">// copied into it.</span>\n<span class=\"hljs-comment\">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span>\n<span class=\"hljs-comment\">// NOT to the new requested capacity.</span>\n<span class=\"hljs-comment\">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span>\n<span class=\"hljs-comment\">// to calculate where to write new values during an append.</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> When the old backend is gone, reconsider this decision.</span>\n<span class=\"hljs-comment\">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">growslice</span><span class=\"hljs-params\">(et *_type, old slice, <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">slice</span></span> &#123;\n\t<span class=\"hljs-comment\">//忽略部分源码</span>\n\tnewcap := old.<span class=\"hljs-built_in\">cap</span>\n\tdoublecap := newcap + newcap\n\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">cap</span> &gt; doublecap &#123;\n\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t<span class=\"hljs-keyword\">if</span> old.<span class=\"hljs-built_in\">len</span> &lt; <span class=\"hljs-number\">1024</span> &#123;\n\t\t\tnewcap = doublecap\n\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t\t<span class=\"hljs-comment\">// Check 0 &lt; newcap to detect overflow</span>\n\t\t\t<span class=\"hljs-comment\">// and prevent an infinite loop.</span>\n\t\t\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class=\"hljs-built_in\">cap</span> &#123;\n\t\t\t\tnewcap += newcap / <span class=\"hljs-number\">4</span>\n\t\t\t&#125;\n\t\t\t<span class=\"hljs-comment\">// Set newcap to the requested cap when</span>\n\t\t\t<span class=\"hljs-comment\">// the newcap calculation overflowed.</span>\n\t\t\t<span class=\"hljs-keyword\">if</span> newcap &lt;= <span class=\"hljs-number\">0</span> &#123;\n\t\t\t\tnewcap = <span class=\"hljs-built_in\">cap</span>\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n<span class=\"hljs-comment\">//忽略部分源码</span>\n\t<span class=\"hljs-keyword\">return</span> slice&#123;p, old.<span class=\"hljs-built_in\">len</span>, newcap&#125;\n&#125;</code></pre>\n\n<p>当slice中的cap不够使用是会调用growslice函数进行扩容，具体的扩容规则是</p>\n<ul>\n<li>如果新的大小是当前大小2倍以上，则大小增长为新大小</li>\n<li>如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</li>\n</ul>\n<p>扩容之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。最后向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p>\n<h5 id=\"nil-slice-和空slice\"><a href=\"#nil-slice-和空slice\" class=\"headerlink\" title=\"nil slice 和空slice\"></a>nil slice 和空slice</h5><p>nil slice 是描述一个不存在的切片，也就是说它的指针指向nil，没有实际上地址，长度和容量也都为0。</p>\n<p>而空的切片是是描述空的一个集合，但是它的指针指向了一个地址，长度和容量也为0。</p>\n<p>nil切片和空切片很相似，长度和容量都是0，官方建议尽量使用 <code>nil</code> 切片。</p>\n<table>\n<thead>\n<tr>\n<th>创建方式</th>\n<th>nil切片</th>\n<th>空切片</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>方式一</td>\n<td>var s1 []int</td>\n<td>var s2 = []int{}</td>\n</tr>\n<tr>\n<td>方式二</td>\n<td>var s4 = *new([]int)</td>\n<td>var s3 = make([]int, 0)</td>\n</tr>\n<tr>\n<td>长度</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>容量</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>和nil比较</td>\n<td>true</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<h4 id=\"slice-和unsafe-Pointer相互转换\"><a href=\"#slice-和unsafe-Pointer相互转换\" class=\"headerlink\" title=\"slice 和unsafe.Pointer相互转换\"></a>slice 和unsafe.Pointer相互转换</h4><p>在上一篇的cgo 部分中将c的数组转到go slice 部分中有涉及到unsafe.Pointer。</p>\n<p>我们先来看看从slice中获取一块内存地址</p>\n<pre><code class=\"hljs go\">slice:=<span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-number\">10</span>)\nptr:=unsafe.Pointer(&amp;slice[<span class=\"hljs-number\">0</span>])<span class=\"hljs-comment\">//获取数组中第一个元素的内存地址</span></code></pre>\n\n<p>从内存指针构造出Go的slice结构会比较麻烦，总共有三种方式</p>\n<p>第一种，先将<code>ptr</code>强制类型转换为另一种指针，一个指向<code>[1&lt;&lt;10]int</code>数组的指针，这里数组大小其实是假的。然后用slice操作取出这个数组的前10个，于是<code>s</code>就是一个10个元素的slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\ns := ((*[<span class=\"hljs-number\">1</span>&lt;&lt;<span class=\"hljs-number\">10</span>]<span class=\"hljs-keyword\">int</span>)(ptr))[:<span class=\"hljs-number\">10</span>]</code></pre>\n\n<p>第二种，模拟go 底层的slice结构，将结构体赋值给s。和第一种相比，这里的cap和1&lt;&lt;10意思是相同的</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> ptr unsafe.Pointer\n<span class=\"hljs-keyword\">var</span> s1 = <span class=\"hljs-keyword\">struct</span> &#123;\n    addr <span class=\"hljs-keyword\">uintptr</span>\n    <span class=\"hljs-built_in\">len</span> <span class=\"hljs-keyword\">int</span>\n    <span class=\"hljs-built_in\">cap</span> <span class=\"hljs-keyword\">int</span>\n&#125;&#123;ptr, length, length&#125;\ns := *(*[]<span class=\"hljs-keyword\">byte</span>)(unsafe.Pointer(&amp;s1))</code></pre>\n\n<p>第三种方法，通过reflect.SliceHeader的方式来构造slice。</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-keyword\">var</span> o []<span class=\"hljs-keyword\">byte</span>\nsliceHeader := (*reflect.SliceHeader)((unsafe.Pointer(&amp;o)))\nsliceHeader.Cap = length\nsliceHeader.Len = length\nsliceHeader.Data = <span class=\"hljs-keyword\">uintptr</span>(ptr)</code></pre>\n\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p>不知道你是否得出文章开始代码的正确结果呢？</p>\n<p> <code>defer</code> 会在当前函数或者方法返回之前执行传入的函数。它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。要真正理解文章前面的问题，我们要理解<strong>return xxx这一条语句并不是一条原子指令!</strong></p>\n<p>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</p>\n<p>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。</p>\n<p>其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:</p>\n<pre><code class=\"hljs shell\">返回值 = xxx\n调用defer函数\n空的return</code></pre>\n\n<p> 这样你就能理解为啥会得出文章一开始函数的结果了。我们来查看下改写之后的代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(result <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tresult = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">//return语句不是一条原子调用，return xxx其实是赋值＋ret指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到return之前执行，也就是赋返回值和ret指令之间</span>\n\t\tresult++\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tt := <span class=\"hljs-number\">5</span>\n\tr = t <span class=\"hljs-comment\">//赋值指令</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span>\n\t\tt = t + <span class=\"hljs-number\">5</span>\n\t&#125;()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return指令</span>\n&#125;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123;\n\tr = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">//给返回值赋值</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(r <span class=\"hljs-keyword\">int</span>)</span></span> &#123; <span class=\"hljs-comment\">//这里改的r是传值传进去的r，不会改变要返回的那个r值</span>\n\t\tr = r + <span class=\"hljs-number\">5</span>\n\t&#125;(r)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-comment\">//空的return</span>\n&#125;</code></pre>\n\n<p>接下来我们来看看另外一小段代码</p>\n<pre><code class=\"hljs go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;\n  startedAt := time.Now()\n\t<span class=\"hljs-keyword\">defer</span> fmt.Println(time.Since(startedAt))\n\ttime.Sleep(time.Second)\n&#125;\n<span class=\"hljs-comment\">//输出结果并不是1s，而是几百纳秒</span></code></pre>\n\n<p>上面的输出结果背后的原因是什么呢？经过分析，我们会发现调用 <code>defer</code> 关键字会立刻对函数中引用的外部参数进行拷贝，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出。当然上面的解决办法是很简单的。只要defer 那添加一个匿名函数就可以解决了。我们总结一下<code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果。</p>\n<p>参考：<a href=\"https://halfrost.com/go_slice/\">深入解析go中slice底层实现</a></p>\n<p><a href=\"https://www.cnblogs.com/qcrao-2018/p/10631989.html\">深度解析Go语音之slice</a></p>\n<p><a href=\"https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html\">深入解析Go</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckhvmkcwm0002dwym4gq4a8rw","category_id":"ckhvmkcwr0008dwym98tc83k7","_id":"ckhvmkcww000jdwym9ut41ehf"},{"post_id":"ckhvmkcx40011dwymdm28at48","category_id":"ckhvmkcxj0028dwym43x6g8cs","_id":"ckhvmkcxm002ndwym6p7e1wm0"},{"post_id":"ckhvmkcxa001ldwym1fm4402x","category_id":"ckhvmkcxn002pdwymb8e95evh","_id":"ckhvmkcxo002xdwym4zzz6mmg"},{"post_id":"ckhvmkcxh0023dwymgasxc6j0","category_id":"ckhvmkcxn002pdwymb8e95evh","_id":"ckhvmkcxr0039dwymb4lk083f"},{"post_id":"ckm0gaqs20000mjyma9m06wty","category_id":"ckhvmkcwu000edwymceidbx4g","_id":"ckm0gaqs40002mjym4t436rx0"},{"post_id":"ckm0h4bfu000019ym8pk6cdzt","category_id":"ckhvmkcxc001sdwymfdrn180a","_id":"ckm0h4bg1000219ymgpq2db7p"},{"post_id":"ckm1g7wpm000022ymd4f9dt6h","category_id":"ckhvmkcxc001sdwymfdrn180a","_id":"ckm1g7wps000222ym9y3qepxg"},{"post_id":"ckm1nvl4g0000qjym3m7gdltq","category_id":"ckhvmkcwu000edwymceidbx4g","_id":"ckm1nvl4j0002qjymcu2bad9z"},{"post_id":"ckm2uej100000d5ym2nhy02jg","category_id":"ckhvmkcwn0003dwym311x62d8","_id":"ckm2uej190002d5ymh0xx7ehf"},{"post_id":"ckm310lw9000117ym2jyk5agw","category_id":"ckhvmkcxo002udwymdah8hon8","_id":"ckm310lwa000317ym1vbbfg26"},{"post_id":"ckm31ea07000717ymh0hq0hg4","category_id":"ckhvmkcww000kdwym8d6j6pju","_id":"ckm31ea09000917ymej6v80th"},{"post_id":"ckm31eeoo000a17ymai1zc3hy","category_id":"ckhvmkcww000kdwym8d6j6pju","_id":"ckm31eeop000c17ym8bra2h7a"},{"post_id":"ckm31emoh000d17ymbvjw9rlh","category_id":"ckhvmkcww000kdwym8d6j6pju","_id":"ckm31emoi000f17ymhabxeobm"},{"post_id":"ckm31ewrt000g17ymb70ahjxx","category_id":"ckhvmkcww000kdwym8d6j6pju","_id":"ckm31ewru000i17ymhsu499o6"},{"post_id":"ckm31f4et000j17ym81ne5wj8","category_id":"ckhvmkcww000kdwym8d6j6pju","_id":"ckm31f4eu000l17yme0vg404n"},{"post_id":"ckm31tvuq000m17ym6lwtdn81","category_id":"ckhvmkcwr0008dwym98tc83k7","_id":"ckm31tvus000o17ym33796xit"},{"post_id":"ckm31xp90000p17ym38ti1zp2","category_id":"ckhvmkcwr0008dwym98tc83k7","_id":"ckm31xp91000r17ym7eus2ebj"}],"PostTag":[{"post_id":"ckhvmkcwm0002dwym4gq4a8rw","tag_id":"ckhvmkcws0009dwym9jwi50ra","_id":"ckhvmkcwv000hdwymblwm9akb"},{"post_id":"ckhvmkcxh0023dwymgasxc6j0","tag_id":"ckhvmkcxc001tdwym2hzobzoe","_id":"ckhvmkcxj002adwymh00vdd7d"},{"post_id":"ckhvmkcx40011dwymdm28at48","tag_id":"ckhvmkcxj0029dwym273m332b","_id":"ckhvmkcxl002jdwymcd4zbwiz"},{"post_id":"ckhvmkcxa001ldwym1fm4402x","tag_id":"ckhvmkcxp002zdwym761ka165","_id":"ckhvmkcxq0035dwym46lyej8f"},{"post_id":"ckm0gaqs20000mjyma9m06wty","tag_id":"ckhvmkcxm002mdwym1zs3a1zv","_id":"ckm0gaqs40001mjym7e6p7pse"},{"post_id":"ckm0h4bfu000019ym8pk6cdzt","tag_id":"ckhvmkcxl002hdwym2av47id6","_id":"ckm0h4bg1000119ym6lxrefnw"},{"post_id":"ckm1g7wpm000022ymd4f9dt6h","tag_id":"ckhvmkcxm002mdwym1zs3a1zv","_id":"ckm1g7wps000122ym8ztphp8y"},{"post_id":"ckm1nvl4g0000qjym3m7gdltq","tag_id":"ckhvmkcxm002mdwym1zs3a1zv","_id":"ckm1nvl4j0001qjymg8w680wb"},{"post_id":"ckm2uej100000d5ym2nhy02jg","tag_id":"ckhvmkcxm002mdwym1zs3a1zv","_id":"ckm30wxgy000017ym1omb17z7"},{"post_id":"ckm310lw9000117ym2jyk5agw","tag_id":"ckhvmkcxc001tdwym2hzobzoe","_id":"ckm310lwa000217ym873b1v67"},{"post_id":"ckm31ea07000717ymh0hq0hg4","tag_id":"ckhvmkcwx000ldwymesmjc1so","_id":"ckm31ea08000817ym8izy0ee1"},{"post_id":"ckm31eeoo000a17ymai1zc3hy","tag_id":"ckhvmkcwx000ldwymesmjc1so","_id":"ckm31eeop000b17ym5bmdg2dp"},{"post_id":"ckm31emoh000d17ymbvjw9rlh","tag_id":"ckhvmkcwx000ldwymesmjc1so","_id":"ckm31emoi000e17ymfxgfh1tz"},{"post_id":"ckm31ewrt000g17ymb70ahjxx","tag_id":"ckhvmkcwx000ldwymesmjc1so","_id":"ckm31ewru000h17ym09z2cpsw"},{"post_id":"ckm31f4et000j17ym81ne5wj8","tag_id":"ckhvmkcwx000ldwymesmjc1so","_id":"ckm31f4et000k17ym354obdlu"},{"post_id":"ckm31tvuq000m17ym6lwtdn81","tag_id":"ckhvmkcxg0021dwym8l5580mn","_id":"ckm31tvur000n17ymc6e2b456"},{"post_id":"ckm31xp90000p17ym38ti1zp2","tag_id":"ckhvmkcws0009dwym9jwi50ra","_id":"ckm31xp90000q17ym1bsu5xv6"}],"Tag":[{"name":"开发效率","_id":"ckhvmkcwo0004dwym4q029mg0"},{"name":"golang","_id":"ckhvmkcws0009dwym9jwi50ra"},{"name":"Linux","_id":"ckhvmkcwu000fdwym8pjwh4ye"},{"name":"mysql","_id":"ckhvmkcwx000ldwymesmjc1so"},{"name":"react-native","_id":"ckhvmkcxa001kdwyma2u180gj"},{"name":"扩展","_id":"ckhvmkcxc001tdwym2hzobzoe"},{"name":"golang cgo","_id":"ckhvmkcxg0021dwym8l5580mn"},{"name":"jna","_id":"ckhvmkcxj0029dwym273m332b"},{"name":"Python","_id":"ckhvmkcxl002hdwym2av47id6"},{"name":"shell","_id":"ckhvmkcxm002mdwym1zs3a1zv"},{"name":"随笔","_id":"ckhvmkcxp002zdwym761ka165"},{"name":"react web","_id":"ckhvmkcxq0034dwymcsbdcb3k"}]}}